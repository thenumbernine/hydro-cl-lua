--[[
predefined vars:
	clcpu = (in run.lua, preceding this) use experimental cl-cpu CL-to-C OpenCL wrapper
	dim =
	gridSize =
	fluxLimiter =
	boundary =
	integrator =
	eqn =
	mins =
	maxs =
	float = set to true to use 32 bit float instead of 64 
	half = set to true to use 16 bit float instead of 64
	cpu = set to use CPU instead of GPU
	sys = subsystem to run under.  options are 'imguiapp', 'glapp', 'console'
	useGLSharing = set to false to disable GL sharing.  automatically false if sys=console.
	platform = name or numeric index of which OpenCL platform to use.  see clinfo utility (or my cl/tests/info.lua script) for identifying platforms.
	device = name or numeric index of which OpenCL device to use.
	disableFont = set to disable loading of the font.png file.  automatically true if sys=console.
	vsync = set to enable vsync and slow down the simulation
	createAnimation = set to start off creating an animation / framedump
	exitTime = start the app running, and exit it after the simulation reaches this time
	verbose = output extra stuff

	run = start the simulation running.  Setting 'exitTime' or 'sys=console' also starts the simulation running.

	showfps = print the updates/second to console
	trackvars = comma-separated list of variable names to print to the console every FPS print
	tick = how often to update the console for fps or trackvars
	
	checknans = stop if a NaN or infinity is found

	displayvars = comma-separated predefined display vars to use

	coordVerbose = output extra info from coord/coord.lua

	display_useCoordMap = set this gui option 
	displayDim = override dimension of display (useful for displaying 3D simulations as 1D graphs)

	intVerbose = output extra info from int/*.lua
	intBEEpsilon = backwards Euler stop on residual less than this epsilon
	intBERestart = backwards Euler GMRES restart
	intBEMaxIter = backwards Euler Krylov max iter

	noDivPoissonSolver = 'jacobi' or 'krylov'
	selfGravPoissonSolver
	selfGravPoissonMaxIter
	selfGravVerbose
	selfGravLinearSolver = 'conjgrad', 'conjres', 'bicgstab', 'gmres'

	bssnUseCache = set to false to ignore the cached equations generated by symmath

	usecachedcode = set to true to use the code in cache-cl instead of regenerating it

	printBufs

	config = specify alternative config file.  default is config.lua (TODO configs/default.lua)
--]]
cmdline = cmdline or {}	--global

local fromlua = require 'ext.fromlua'
for _,w in ipairs(arg or {}) do
	local k,v = w:match'^(.-)=(.*)$'
	if k then
		pcall(function()
			cmdline[k] = fromlua(v)
		end)
		if cmdline[k] == nil then cmdline[k] = v end
	else
		cmdline[w] = true
	end
end

local bit = require 'bit'
local ffi = require 'ffi'
local cl = require 'ffi.OpenCL'
local io = require 'ext.io'
local class = require 'ext.class'
local math = require 'ext.math'
local table = require 'ext.table'
local file = require 'ext.file'
local range = require 'ext.range'
local template = require 'template'
local CLEnv = require 'cl.obj.env'
local clnumber = require 'cl.obj.number'
local vec4d = require 'vec-ffi.vec4d'
local vec3d = require 'vec-ffi.vec3d'
local CartesianCoord = require 'coord.cartesian'

--[[
TODO 'targetPlatform'?
options: console, glapp, imguiapp
--]]
local targetSystem = cmdline.sys or 'imguiapp'

-- allow the global to be set
-- if we are disabling the gui then replace the imgui and tooltip requires, so we don't try to unnecessarily load it
if __disableGUI__ then targetSystem = 'glapp' end
if __useConsole__ then targetSystem = 'console' end

-- TODO make this work with the fallback mechanism as well
-- -- that will probalby mean lots of pcalls around requires
local gl
local sdl
local GLProgram
local GLGradientTex
local GLTex2D
local Font
local Mouse
if targetSystem ~= 'console' then
	gl = require 'gl'
	sdl = require 'ffi.sdl'
	GLProgram = require 'gl.program'
	GLGradientTex = require 'gl.gradienttex'
	GLTex2D = require 'gl.tex2d'
	Font = require 'gui.font'
	Mouse = require 'gui.mouse'
end

-- TODO here if we have glapp and imguiapp present
-- but we're in console mode
-- then we need to figure this out somehow
-- but we won't figure it out until SDL_Init is run, inside GLApp:run()
-- ... is there any way to detect if SDL_Init can init without performing the init?
-- or is there any way to move the :run() into this protected area, so we can bail out depending on the subsystem (without actually loading all the hydro-cl init stuff)
-- until then ... you have to explicitly state sys=console
-- TODO move App:init code into a separate function, then in the loader here try calling :init (and :initGL) and only if all succeeds *THEN* run our :appInit()
-- TODO unless we are still returning a class, in which case this should all be moved into the class's :init() code ... and then we change is-a with has-a, until init() is done, then we swap it back with is-a
local ig, tooltip
local baseSystems = {
	{imguiapp = function() 
		ig = require 'ffi.imgui'
		tooltip  = require 'tooltip'
		return require 'imguiapp' 
	end},
	{glapp = function() 
		
		package.loaded['ffi.imgui'] = {disabled=true}
		package.loaded.tooltip = {disabled=true}
		ig = require 'ffi.imgui'
		tooltip  = require 'tooltip'
		
		return require 'glapp' 
	end},
	{console = function()
		
		package.loaded.ig = {disabled=true}
		package.loaded.gl = {disabled=true}
		package.loaded['gl.report'] = {disabled=true}
		
		local cl = class()
		function cl:requestExit() self.done = true end
		function cl:run()
			if self.initGL then self:initGL(gl, 'none') end
			repeat
				if self.update then self:update() end
			until self.done
			if self.exit then self:exit() end
		end
		return cl
	end},
}

local HydroCLApp
for i,sys in ipairs(baseSystems) do
	local name, loader = next(sys)
	if targetSystem == name then
		--print('trying to load system '..name..'...')
		xpcall(function()
			HydroCLApp = class(loader())
		end, function(err)
			io.stderr:write('...load failed with error:')
			io.stderr:write(err..'\n'..debug.traceback())
		end)
		if HydroCLApp then break end
		io.stderr:write(targetSystem..'failed\n')
		if i < #baseSystems then
			targetSystem = next(baseSystems[i+1])
			io.stderr:write('falling back to '..targetSystem..'\n')
		end
	end
end
if not HydroCLApp then
	error 'Somehow you exhausted all possible targets.  At least the console system should have loaded.  Something must be wrong.'
end

-- TODO organize this all better
-- this is up above if the autosearch passes imguiapp
-- and it is here if the cmdline explicitly asks for glapp or console
if not ig then
	package.loaded['ffi.imgui'] = {disabled=true}
	package.loaded.tooltip = {disabled=true}
	ig = require 'ffi.imgui'
	tooltip  = require 'tooltip'
end

HydroCLApp.title = 'Hydrodynamics in OpenCL'

-- list from https://en.wikipedia.org/wiki/Flux_limiter
HydroCLApp.limiters = table{
	{name='donor cell', code='return 0.;'},
	{name='Lax-Wendroff', code='return 1.;'},
	{name='Beam-Warming', code='return r;'},
	{name='Fromm', code='return .5 * (1. + r);'},
	{name='CHARM', code='return max(0., r) * (3. * r + 1.) / ((r + 1.) * (r + 1.));'},
	{name='HCUS', code='return max(0., 1.5 * (r + fabs(r)) / (r + 2.));'},
	{name='HQUICK', code='return max(0., 2. * (r + fabs(r)) / (r + 3.));'},
	{name='Koren', code='return max(0., min(2. * r, min((1. + 2. * r) / 3., 2.)));'},
	{name='minmod', code='return max(0., min(r, 1.));'},
	{name='Oshker', code='return max(0., min(r, 1.5));	//replace 1.5 with 1 <= beta <= 2'},
	{name='ospre', code='return .5 * (r * r + r) / (r * r + r + 1.);'},
	{name='smart', code='return max(0., min(2. * r, min(.25 + .75 * r, 4.)));'},
	{name='Sweby', code='return max(0., max(min(1.5 * r, 1.), min(r, 1.5)));	//replace 1.5 with 1 <= beta <= 2'},
	{name='UMIST', code='return max(0., min(min(2. * r, .75 + .25 * r), min(.25 + .75 * r, 2.)));'},
	{name='van Albada 1', code='return (r * r + r) / (r * r + 1.);'},
	{name='van Albada 2', code='return 2. * r / (r * r + 1.);'},
	{name='van Leer', code='return max(0., r) * 2. / (1. + r);'},	--return (r + fabs(r)) / (1. + fabs(r));
	{name='monotized central', code='return max(0., min(2., min(.5 * (1. + r), 2. * r)));'},
	{name='superbee', code='return max((real)0., (real)max((real)min((real)1., (real)2. * r), (real)min((real)2., r)));'},
	{name='Barth-Jespersen', code='return .5 * (r + 1.) * min(1., min(4. * r / (r + 1.), 4. / (r + 1.)));'},
}
HydroCLApp.limiterNames = HydroCLApp.limiters:mapi(function(limiter) return limiter.name end)

--[[
setup for the solver
args has: platAndDevicesNames
override this for specific experiments
this can't override float vs double precision yet

make sure to call this after 'real' is defined
 specifically the call to 'refreshGridSize' within it
--]]
function HydroCLApp:setup(args)
	args.self = self
	args.cmdline = cmdline
	args.table = table
	local keys = table.keys(args)
	local cfgfile = cmdline.config or 'config.lua'
	assert(load([[
local ]]..keys:concat', '..[[ = ...
]] .. file[cfgfile]))(
	keys:mapi(function(key) return args[key] end):unpack()
)
end

local useClipPlanes
if useClipPlanes then
-- TODO put all the display3D_slices stuff in its own file
local rotateClip = ffi.new('int[1]', 0)
local function makeDefaultPlane(i)
	assert(i >= 1 and i <= 4)
	local plane = vec4d(0,0,0,0)
	plane.s[math.min(i,3)-1] = -1
	return plane
end
local clipInfos = range(4):mapi(function(i)
	return {
		enabled = i == 3,
		plane = makeDefaultPlane(i),
	}
end)
end

if targetSystem ~= 'console' then
	-- needs to go before display2DMethods
	require 'draw.2d_heatmap'(HydroCLApp)
	require 'draw.2d_graph'(HydroCLApp)
end

-- needs to go before initGL
local display2DMethods = table{
	{Heatmap = HydroCLApp.display2D_Heatmap},
	{Graph = HydroCLApp.display2D_Graph},
}

if targetSystem ~= 'console' then
	require 'draw.3d_slice'(HydroCLApp)
	require 'draw.3d_ray'(HydroCLApp)
	require 'draw.3d_iso'(HydroCLApp)
end

local display3DMethods = table{
	{Slices = HydroCLApp.display3D_Slice},
	{Raytrace = HydroCLApp.display3D_Ray},
	{Isosurfaces = HydroCLApp.display3D_Isosurface},
}
local display3DMethodNames =  display3DMethods:mapi(function(kv)
	return (next(kv))
end)


--[[ Cheap output of the state each frame so I can compare it to other solvers.
-- 	This is what the dump-to-file is supposed to also do.
local printStateFile = io.open('out.txt', 'w')
local function printState(solver)
	local ptr = solver.UBufObj:toCPU()
	
	local cols = {0, 1, 4}
	
	for i=0,solver.numCells-1 do
		-- matching the cl defs:
		local dx = (solver.maxs[1] - solver.mins[1]) / (tonumber(solver.gridSize.x) - (2*solver.numGhost))
		local x = (i + .5 - solver.numGhost) * dx + solver.mins[1]
		printStateFile:write(solver.t,'\t',x)
		for _,j in ipairs(cols) do	-- only use rho, mx, ETotal
		--for j=0,solver.eqn.numStates-1 do
			printStateFile:write('\t',ptr[j + solver.eqn.numStates * i])
		end
		printStateFile:write'\n'
	end
	printStateFile:write'\n'
	printStateFile:flush()
end
--]]

function HydroCLApp:initGL(...)
	if HydroCLApp.super
	and HydroCLApp.super.initGL 
	then
		HydroCLApp.super.initGL(self, ...)
	end

	self.cmdline = cmdline
	self.targetSystem = targetSystem

	if cmdline.vsync then
		-- Latest intel-opencl-icd drivers are freezing my system, only for this program, and I don't know why.  Turning on vsync seems to fix it.
		sdl.SDL_GL_SetSwapInterval(1)
	end

	-- This used to be on by default, 
	-- but for now the 'calcDisplayVarToTex' code has grown out of hand and now doubles the compile times
	-- and I can't perceive a performance difference with or without it,
	-- so I will keep this disabled for now.
	--local useGLSharing = true
	local useGLSharing = false

	if cmdline.useGLSharing ~= nil then useGLSharing = cmdline.useGLSharing end
	if self.targetSystem == 'console' then useGLSharing = false end

	-- TODO if no identifier was specified by the cmdline then favor cl_khr_gl_sharing, cl_khr_fp64, cl_khr_3d_image_writes
	local function getterForIdent(ident, identType)
		return function(objs)
			if ident == nil then return objs end	-- use all
			-- use a sepcific device
			-- TODO how to specify using multiple devices?
			for i,obj in ipairs(objs) do
				if type(ident) == 'number' then
					if ident == i then return {obj} end
				elseif type(ident) == 'string' then
					if ident == obj:getName() then return {obj} end
				end
			end
			error("couldn't find "..identType)
		end
	end

	self.verbose = cmdline.verbose
	self.env = CLEnv{
		precision = cmdline.float and 'float' or (cmdline.half and 'half' or nil),
		cpu = cmdline.cpu,
		useGLSharing = useGLSharing,
		verbose = self.verbose,
		getPlatform = getterForIdent(cmdline.platform, 'platform'),
		getDevices = getterForIdent(cmdline.device, 'device'),
	}
	local platAndDevicesNames = table{
		self.env.platform,
		table.unpack(self.env.devices)
	}:mapi(function(x) return x:getName() end):concat'/'

	self.exitTime = cmdline.exitTime
	if self.exitTime 
	or cmdline.run 
	or self.targetSystem == 'console'
	then 
		self.running = true 
	end

	self.createAnimation = cmdline.createAnimation

	self.useGLSharing = self.env.useGLSharing
	self.ctx = self.env.ctx
	self.real = self.env.real
	
	--half cannot be a kernel param, so this is a proxy type
	self.realparam = self.real == 'half' and 'float' or self.real

	do
		local code = template(file['math.types.h'], {app=self})
		xpcall(function()
			ffi.cdef(code)
		end, function(err)
			print(require 'template.showcode'(code))
			error(err)
		end)
	end

	self.solvers = table()

	self:setup{platAndDevicesNames=platAndDevicesNames}
	if #self.solvers == 0 then
		print("You didn't add any solvers in the HydroCLApp:setup() function.  Did you forget something?")
	end
	
	
	-- this will be per-solver
	-- but is also tightly linked to the structured grid solvers
	-- used for 1D
	if self.targetSystem ~= 'console' then
		-- This only looks good when overlaying vector fields on top of other graphs.
		-- When it comes to separate variables, they usually look better apart.
		self.displayAllTogether = false	--self.solvers[1] and self.solvers[1].dim > 1 or false

		self.displayBilinearTextures = true

		self.gradientTex = GLGradientTex(1024, {
		-- [[ white, rainbow, black
	--		{0,0,0,.5},	-- black ... ? maybe I shouldn't be using black...
			{0,0,1,.8},	-- blue
			{0,1,1,.8},	-- cyan
			{0,1,0,.8},	-- green
			{1,1,0,.8},	-- yellow
			{1,.5,0,.8},	-- orange
			{1,0,0,.8},	-- red
			{1,1,1,.8},	-- white
		--]]
		--[[ stripes 
			range(32):mapi(function(i)
				return ({
					{0,0,0,0},
					{1,1,1,1},
				})[i%2+1]
			end):unpack()
		--]]
		}, false)
		-- don't wrap the colors, but do use GL_REPEAT
		self.gradientTex:setWrap{s = gl.GL_REPEAT}

		-- init all resources for all draw methods, so the user can switch between methods quickly
		for _,solver in ipairs(self.solvers) do
			solver:initDraw()
		end


		self.isobarShader = GLProgram{
			vertexCode = [[
varying vec4 color;
void main() {
	color = gl_Color;
	gl_Position = ftransform();
}
]],
		fragmentCode = [[
varying vec4 color;
void main() {
	float dx_dz = dFdx(gl_FragCoord.z);
	float dy_dz = dFdy(gl_FragCoord.z);

	vec3 n = normalize(vec3(dx_dz, dy_dz, 10.));

	gl_FragColor = vec4(color.rgb * n.z, color.a);
}
]],
		}

		if not cmdline.disableFont then
			local fonttex = GLTex2D{
				filename = 'font.png',
				minFilter = gl.GL_LINEAR_MIPMAP_LINEAR,
				magFilter = gl.GL_LINEAR,
			}
			if not pcall(function()
				gl.glGenerateMipmap(gl.GL_TEXTURE_2D) 
			end) then
				gl.glTexParameteri(fonttex.target, gl.GL_TEXTURE_MIN_FILTER, gl.GL_NEAREST)
				gl.glTexParameteri(fonttex.target, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR) 
			end
			self.font = Font{tex = fonttex}
		end

		-- todo reorganize me
		self.display2DMethodsEnabled = display2DMethods:mapi(function(method, index)
			local name, func = next(method)
			return index == 1, name
		end)

		self.orthoView = require 'view.ortho'()
		self.frustumView = require 'view.frustum'()
		self.view = (#self.solvers > 0 and self.solvers[1].dim == 3) and self.frustumView or self.orthoView
	
		if #self.solvers > 0 then
			local solver = self.solvers[1]
			if solver.dim == 2 
			and self.display_useCoordMap 
			and CartesianCoord.is(solver.coord)
			then
				local orthoSize = 1
				for j=1,solver.dim do
					self.orthoView.pos[j] = .5 * (solver.mins[j] + solver.maxs[j])
					orthoSize = math.max(orthoSize, solver.maxs[j] - solver.mins[j])
				end
				self.orthoView.zoom[1] = 1/orthoSize
				self.orthoView.zoom[2] = 1/orthoSize
			end
		end
	end

if printState then
	for _,solver in ipairs(self.solvers) do
		printState(solver)
	end
end

end

--[[
rendering:
graph variables - many - 1D and 2D ... and hypercoordinates in 3D?
heatmap variable - 2D only
volumetric variable - 3D only 
point cloud? i.e. cheap volumetric?
slices? another cheap volumetric?
--]]

--[[

display options
	ortho vs frustum for 2D, (ortho only for 1D, frustum-only for 3D?)
	graph variable(s?) for 1D and 2D
	1D graph: whether the y axis is auto-scaling or fixed
	heatmap variable(s?) for 2D
	2D heatmap: whether the color range is auto-scaling or fixed
	2D graph: whether the z-axis is auto-scaling or fixed
	volumetric variable(s?) for 3D
	3D volumetric: whether the color range is auto-scaling or fixed
	3D volumetric alpha / gamma values

gui:
	checkbox next to each variable for quickly adding and removing views (based on the first / primary var in the view)
	list of views, with their details next to them, for adding and removing more variables

--]]

local View = class()

local Display = class()

function Display:init(args)
	self.ortho = true

	self.mins = vec3(-1,-1,-1)
	self.maxs = vec3(1,1,1)
	
	--[[
	var name, does it contribute to the graph space autoscale range? 
	--]]
	self.graphVars = table()
	
	--[[
	var name, heatmap scale min/max, heatmap autoscale? texture, alpha
	--]]
	self.heatMapVars = table()
end

-- whether to output a text file that holds all variable ranges
-- TODO how about some way to track any variable in the gui?
local dumpFile = {
	enabled = false,
}

function dumpFile:update(app, t)
	if not self.enabled then return end

	local f = self.file
	if not f then
		f = io.open('var-ranges.txt', 'w')
		self.file = f
		
		-- don't change any vars while outputting or else your rows won't match your header
		f:write'#t'
		
		for _,solver in ipairs(app.solvers) do 
			--[[ display variables:
			for _,var in ipairs(solver.displayVars) do
				if var.enabled then
					f:write('\t',var.name..'_min')
					f:write('\t',var.name..'_max')
				end
			end
			--]]
			-- [[ gmres error
			f:write'\tgmres_err'
			f:write'\tgmres_iter'
			--]]
		end
		f:write'\n'
		f:flush()
	end
	
	f:write(t)
	for _,solver in ipairs(app.solvers) do 
		--[[ display variables:
		for _,var in ipairs(solver.displayVars) do
			if var.enabled then
				local ymin, ymax = solver:calcDisplayVarRange(var)
				-- TODO adjust the range by units
				f:write(('\t%.16e'):format(ymin))
				f:write(('\t%.16e'):format(ymax))
			end
		end
		--]]
		-- [[ gmres residual
		f:write('\t'..solver.integrator.lastResidual)
		f:write('\t'..solver.integrator.lastIter)
		--]]
	end
	f:write'\n'
	f:flush()
end


-- dropdown options
HydroCLApp.screenshotExts = {'png', 'bmp', 'jpeg', 'tiff', 'fits', 'tga', 'ppm'}
-- dropdown index
HydroCLApp.screenshotExtIndex = 1

function HydroCLApp:screenshot()
	local ext = self.screenshotExts[self.screenshotExtIndex]

	-- TODO only once upon init?
	if not io.fileexists'screenshots' then
		-- don't assert -- if it already exists the cmd will fail
		os.execute'mkdir screenshots'
	end

	-- make a new subdir for each application instance ... ?
	if not self.screenshotDir then
		self.screenshotDir = os.date('%Y.%m.%d-%H.%M.%S')
		local dir = 'screenshots/'..self.screenshotDir
		assert(not io.fileexists(dir), "found a duplicate screenshot timestamp subdir")
	
		-- bleh, windows.
		-- TODO a mkdir for everyone, either in ext.file or get lfs working with luajit 
		if ffi.os == 'Windows' then dir = dir:gsub('/', '\\') end
		assert(os.execute('mkdir '..dir))
		
		self.screenshotIndex = 0
	end

	local fn = ('screenshots/'..self.screenshotDir..'/%05d.'..ext):format(self.screenshotIndex)
	self.screenshotIndex = self.screenshotIndex + 1
	self:screenshotToFile(fn)
end

function HydroCLApp:screenshotToFile(fn)
	local Image = require 'image'
	local w, h = self:size()
	if self.ssimg then
		if w ~= self.ssimg.width or h ~= self.ssimg.height then
			self.ssimg = nil
			self.ssflipped = nil
		end
	end
	if not self.ssimg then
		-- using 3 channels had some alignment problems ... there's a bug to fix somewhere, maybe in the png write function?
		self.ssimg = Image(w, h, 4, 'unsigned char')
		self.ssflipped = Image(w, h, 4, 'unsigned char')
	end
	gl.glReadPixels(0, 0, w, h, gl.GL_RGBA, gl.GL_UNSIGNED_BYTE, self.ssimg.buffer) 
	-- reverse rows ...
	-- TODO maybe ... for all projection matrix setups, have them check a screenshot flag and automatically flip?
	for y=0,h-1 do
		ffi.copy(
			self.ssflipped.buffer + (h-y-1) * w * 4,
			self.ssimg.buffer + y * w * 4,
			w * 4)
	end
	-- full alpha
	for i=0,w*h-1 do
		self.ssflipped.buffer[3+4*i] = 255
	end
	self.ssflipped:save(fn)
end

local mouse = Mouse and Mouse() or nil

local function canHandleMouse()
	if not mouse then return false end
	if rawget(ig, 'disabled') then return false end
	return not ig.igGetIO()[0].WantCaptureMouse
end

local function canHandleKeyboard()
	if rawget(ig, 'disabled') then return false end
	return not ig.igGetIO()[0].WantCaptureKeyboard
end

HydroCLApp.running = false
--HydroCLApp.running = true

local pushVarNamesEnabled

-- any smaller than this and the font starts to screw up (maybe because it is using floating point?)
local minDeltaY = 1e-5

function HydroCLApp:update(...)
	if canHandleMouse() then
		mouse:update()
	end
	if self.running then
		if self.running == 'step' then 
			print('performing single step...')
			self.running = false
		end

		-- update the one furthest behind
		local oldestSolver = self.solvers:inf(function(a,b)
			return a.t < b.t
		end)
		if oldestSolver then 
			-- check before :update(), in case we want to exit at t=0
			if self.exitTime and oldestSolver.t >= self.exitTime then
				self:requestExit()
				return
			end		
			
if cmdline.printBufs then
	print(('t = %f'):format(oldestSolver.t))
end
			oldestSolver:update() 

if cmdline.printBufs then
	print'UBuf post-update:'
	oldestSolver:printBuf(oldestSolver.UBufObj)	--, nil, nil, 24, 31)
end

if printState then
	for _,solver in ipairs(self.solvers) do
		printState(solver)
	end
end


			-- TODO should the time be oldestSolver.t after oldestSolver just updated?
			-- or - if dumpFile is enabled - should we re-search-out the oldest solver and use its time?
			dumpFile:update(self, oldestSolver.t)
		end
	else	
		-- clear all 'lastFrameTime's of solvers so the rough fps calcs don't get messed with
		for _,solver in ipairs(self.solvers) do
			solver.lastFrameTime = nil
		end
	end

	if self.targetSystem == 'console' then return end

	gl.glClear(bit.bor(gl.GL_COLOR_BUFFER_BIT, gl.GL_DEPTH_BUFFER_BIT))


-- TODO FIXME temp hack for composite solvers
local flattenedSolvers = table(self.solvers)
do
	local i = 1
	while i <= #flattenedSolvers do
		local solver = flattenedSolvers[i]
		if solver.solvers then
			flattenedSolvers:append(solver.solvers)
			flattenedSolvers:remove(i)
			i = i - 1
		end
		i = i + 1
	end
end
local displaySolvers = flattenedSolvers

	local w, h = self:size()

	local varNamesEnabled = table()
	local varNamesEnabledByName = {}
	for _,solver in ipairs(displaySolvers) do
		for i,var in ipairs(solver.displayVars) do
			if var.enabled then
				if not varNamesEnabledByName[var.name] then
					varNamesEnabled:insert(var.name)
					varNamesEnabledByName[var.name] = true
				end
			end
		end
	end

	local graphsWide = math.ceil(math.sqrt(#varNamesEnabled))
	local graphsHigh = math.ceil(#varNamesEnabled/graphsWide)
	local graphCol = 0
	local graphRow = 0

	if self.displayAllTogether then
		graphsWide = 1
		graphsHigh = 1
	end

	local ar = (w / graphsWide) / (h / graphsHigh)

	local mouseClickedOnVar
				
	-- varymin/max is the variable range
	local varymin, varymax

	local useLog
	local vectorField
	for _,varName in ipairs(varNamesEnabled) do
		local xmin, xmax, ymin, ymax
		for _,solver in ipairs(displaySolvers) do
			local var = solver.displayVarForName[varName]
			
			if var and var.enabled
			--and solver.visiblePtr and solver.visiblePtr[0] 
			then
				useLog = var.useLog
				local component = solver.displayComponentFlatList[var.component]
				vectorField = solver:isVarTypeAVectorField(component.type)
				local solverxmin, solverxmax = solver.mins[1], solver.maxs[1]
				solverxmin, solverxmax = 1.1 * solverxmin - .1 * solverxmax, 1.1 * solverxmax - .1 * solverxmin
				if (cmdline.displayDim or solver.dim) > 1 then
					local center = .5 * (solverxmin + solverxmax)
					solverxmin = (solverxmin - center) * ar + center
					solverxmax = (solverxmax - center) * ar + center
				end
	
				-- solverymin/max is the view range
				local solverymin, solverymax


				if (cmdline.displayDim or solver.dim) > 1 then
					solverymin, solverymax = solver.mins[2], solver.maxs[2]
					solverymin, solverymax = 1.1 * solverymin - .1 * solverymax, 1.1 * solverymax - .1 * solverymin
				else
					if vectorField then
						solverymin, solverymax = solver:calcDisplayVarRange(var, component.magn)
					else
						solverymin, solverymax = solver:calcDisplayVarRange(var)
					end

					local thisvarymin, thisvarymax = solverymin, solverymax
					varymin = varymin and math.min(thisvarymin, varymin) or thisvarymin
					varymax = varymax and math.max(thisvarymax, varymax) or thisvarymax
					
					if useLog then
						solverymin = math.log(solverymin, 10)
						solverymax = math.log(solverymax, 10)
						if not math.isfinite(solverymin) then solverymin = -math.huge end
						if not math.isfinite(solverymax) then solverymax = -math.huge end
						solverymin = math.max(-30, solverymin)
						solverymax = math.max(-30, solverymax)
						solverymax = math.max(solverymax, solverymin + minDeltaY)
					end
					
					if solverymin
					and solverymax
					and solverymin == solverymin
					and solverymax == solverymax
					then
						local base = 10	-- round to nearest base-10
						local scale = 10 -- ...with increments of 10
						solverymin, solverymax = 1.1 * solverymin - .1 * solverymax, 1.1 * solverymax - .1 * solverymin
						local newymin = (solverymin < 0 and -1 or 1) * (math.abs(solverymin) == math.huge and 1e+100 or base ^ math.log(math.abs(solverymin), base))
						local newymax = (solverymax < 0 and -1 or 1) * (math.abs(solverymax) == math.huge and 1e+100 or base ^ math.log(math.abs(solverymax), base))
						solverymin, solverymax = newymin, newymax
						do
							local deltaY = solverymax - solverymin
							if deltaY < minDeltaY then
								solverymax = solverymax + .5 * minDeltaY
								solverymin = solverymin - .5 * minDeltaY
							end
						end
					end
				end
				
				xmin = xmin or solverxmin
				xmax = xmax or solverxmax
				ymin = ymin or solverymin
				ymax = ymax or solverymax
				
				if xmin and solverxmin then xmin = math.min(xmin, solverxmin) end
				if xmax and solverxmax then xmax = math.max(xmax, solverxmax) end
				if ymin and solverymin then ymin = math.min(ymin, solverymin) end
				if ymax and solverymax then ymax = math.max(ymax, solverymax) end
			end
		end
		
		if not xmin or not xmax or xmin ~= xmin or xmax ~= xmax then
			xmin = -5
			xmax = 5
		end
		if not ymin or not ymax or ymin ~= ymin or ymax ~= ymax then
			ymin = -5
			ymax = 5
		end

		local mouseOverThisGraph
		local mouseInGraphX
		local mouseInGraphY
		if self.displayAllTogether then
			mouseOverThisGraph = true
			mouseInGraphX = mouse.pos[1]
			mouseInGraphY = mouse.pos[2]
		else
			local vpxmin = graphCol / graphsWide * w
			local vpymin = (1 - (graphRow + 1) / graphsHigh) * h
			local vpw = w / graphsWide
			local vph = h / graphsHigh
			gl.glViewport(vpxmin, vpymin, vpw, vph)
			local mx = mouse.pos[1] * self.width
			local my = mouse.pos[2] * self.height
			if mx >= vpxmin and mx < vpxmin + vpw
			and my >= vpymin and my < vpymin + vph
			then
				mouseOverThisGraph = true
				mouseInGraphX = (mx - vpxmin) / vpw
				mouseInGraphY = (my - vpymin) / vph
				if mouse.leftClick then
					mouseClickedOnVar = varName
				end
			end
		end
		if self.showMouseCoords 
		and mouseOverThisGraph
		and (cmdline.displayDim or displaySolvers[1].dim) == 2
		then
			local xmin, xmax, ymin, ymax
			if self.view.getOrthoBounds then
				xmin, xmax, ymin, ymax = self.view:getOrthoBounds(ar)
			else
				xmin, xmax, ymin, ymax = graph_xmin, graph_ymin, graph_xmax, graph_ymax
			end
			
			-- frustum doesn't have these ...
			if xmax and ymax and xmin and ymin then
				self.mouseCoord[1] = mouseInGraphX * (xmax - xmin) + xmin
				self.mouseCoord[2] = mouseInGraphY * (ymax - ymin) + ymin
			end
		end


		-- TODO maybe find the first solver for this var and use it to choose 1D,2D,3D
		local dim = cmdline.displayDim or displaySolvers[1].dim
		
		if not vectorField then
			if dim == 1 then
				self:display1D(displaySolvers, varName, ar, xmin, ymin, xmax, ymax, useLog, varymin, varymax)
			elseif dim == 2 then
				self:display2D(displaySolvers, varName, ar, xmin, ymin, xmax, ymax)
			elseif dim == 3 then
				self:display3D(displaySolvers, varName, ar, xmin, ymin, xmax, ymax)
			end
		else
			--if self.enableVectorField then
			self:displayVectorField(displaySolvers, ar, varName, xmin, ymin, xmax, ymax)
			--end
		end

		-- TODO make this custom per-display-method
		-- (that would also let us do one less tex bind/unbind)
		if mouseOverThisGraph 
		and self.showMouseCoords
		and dim == 2
		then
			local half = require 'half'
			local toreal, fromreal = half.toreal, half.fromreal
			
			self.mouseCoordValue = ''
			for i,solver in ipairs(displaySolvers) do 
			local var = solver.displayVarForName[varName]
				if var and var.enabled then
					-- translate the mouse coords to texture coords
					-- and read the texel at the mouse position
					if self.display_useCoordMap 
						and not CartesianCoord.is(solver.coord)
					then
						--print'FIXME'
						-- run coords through inverse
					else
						--local tcX = (self.mouseCoord[1] - solver.mins[1]) / (solver.maxs[1] - solver.mins[1])
						--local tcY = (self.mouseCoord[2] - solver.mins[2]) / (solver.maxs[2] - solver.mins[2])
						local tcX = (self.mouseCoord[1] + 1) * .5
						local tcY = (self.mouseCoord[2] + 1) * .5
						-- TODO something equivalent for 3D ... somehow ...
						if tcX >= 0 and tcX < 1
						and tcY >= 0 and tcY < 1
						then
							-- TODO this is going to include ghost cells...
							local size = var.getBuffer().sizevec or solver.gridSize
							local texX = math.floor(tcX * tonumber(size.x))
							local texY = math.floor(tcY * tonumber(size.y))
							if self.useGLSharing then
								print'FIXME'
								--gl.glGetTexSubImage ... why isn't this in any OpenGL header?
							else
								-- ... if we know we're always copying intermediately to reduceBuf then we can use that instead
								-- in fact, we can even use the CPU intermediate buffer
									-- right now I'm copying halfs from cl to gl as-is, so calcDisplayVarToTexPtr will have half data for half and float data otherwise
								local ptr = ffi.cast(self.real == 'half' and 'real*' or 'float*', solver.calcDisplayVarToTexPtr)
								local channels = vectorField and 3 or 1
								local sep = ''
								self.mouseCoordValue = self.mouseCoordValue .. tostring(texX)..','..tostring(texY)..': '
								for j=0,channels-1 do
									self.mouseCoordValue = self.mouseCoordValue .. sep .. fromreal(ptr[j + channels * (texX + size.x * texY)])
									sep = ', '
								end
								self.mouseCoordValue = self.mouseCoordValue .. '\n'
							end
						end
					end
				end
			end
		end
	
		if not self.displayAllTogether then
			graphCol = graphCol + 1
			if graphCol == graphsWide then
				graphCol = 0
				graphRow = graphRow + 1
			end
		end
	end

	gl.glViewport(0,0,w,h)
	gl.glMatrixMode(gl.GL_PROJECTION)
	gl.glLoadIdentity()
	gl.glOrtho(0, w/h, 0, 1, -1, 1)
	gl.glMatrixMode(gl.GL_MODELVIEW)
	gl.glLoadIdentity()

	if self.font then
		local solverNames = displaySolvers:mapi(function(solver)
			return {
				text = ('(%.3f) %s'):format(solver.t, solver.name),
				color = solver.color,
			}
		end)
		local fontSizeX = .02
		local fontSizeY = .02
		local maxlen = solverNames:mapi(function(solverName)
			return self.font:draw{
				text = solverName.text,
				fontSize = {fontSizeX, -fontSizeY},
				dontRender = true,
				multiLine = false,
			}
		end):inf()
		for i,solverName in ipairs(solverNames) do
			self.font:draw{
				pos = {w/h-maxlen,fontSizeY*(i+1)},
				text = solverName.text,
				color = {solverName.color[1], solverName.color[2], solverName.color[3],1},
				fontSize = {fontSizeX, -fontSizeY},
				multiLine = false,
			}
		end
	end

	-- screenshot before gui
	if self.createAnimation then 
		self:screenshot() 
		if self.createAnimation == 'once' then
			self.createAnimation = nil
		end
	end

	if HydroCLApp.super
	and HydroCLApp.super.update 
	then
		HydroCLApp.super.update(self, ...)
	end

	if mouseClickedOnVar then
		if not pushVarNamesEnabled then
			pushVarNamesEnabled = table(varNamesEnabled)
			-- and disable all except the one we clicked
			for _,solver in ipairs(displaySolvers) do
				for i,var in ipairs(solver.displayVars) do
					var.enabled = var.name == mouseClickedOnVar
				end
			end
		else
			-- restore those that were pushed
			for _,solver in ipairs(displaySolvers) do
				for i,var in ipairs(solver.displayVars) do
					var.enabled = pushVarNamesEnabled:find(var.name)
				end
			end
			pushVarNamesEnabled = nil
		end
	end

end

if targetSystem ~= 'console' then
	require 'draw.1d'(HydroCLApp)
end

function HydroCLApp:drawGradientLegend(ar, varName, valueMin, valueMax)
	self.orthoView:projection(ar)
	self.orthoView:modelview()
	local xmin, xmax, ymin, ymax = self.orthoView:getOrthoBounds(ar)
	
	if self.font then
		local palwidth = (xmax - xmin) * .1
		self.gradientTex:enable()
		self.gradientTex:bind(0)
		gl.glBegin(gl.GL_QUADS)
		gl.glColor3f(1,1,1)
		gl.glTexCoord1f(0) gl.glVertex2f(xmin, ymin)
		gl.glTexCoord1f(0) gl.glVertex2f(xmin + palwidth, ymin)
		gl.glTexCoord1f(1) gl.glVertex2f(xmin + palwidth, ymax)
		gl.glTexCoord1f(1) gl.glVertex2f(xmin, ymax)
		gl.glEnd()
		self.gradientTex:unbind()
		self.gradientTex:disable()

		local fontSizeX = (xmax - xmin) * .025
		local fontSizeY = (ymax - ymin) * .025
		local ystep = 10^(math.log(ymax - ymin, 10) - 1.5)
		for y=math.floor(ymin/ystep)*ystep,math.ceil(ymax/ystep)*ystep,ystep do
			local value = (y - ymin) * (valueMax - valueMin) / (ymax - ymin) + valueMin
			local absvalue = math.abs(value)
			self.font:draw{
				pos={xmin * .99 + xmax * .01, y + fontSizeY * .5},
				text=(
					(absvalue > 1e+5 or absvalue < 1e-5)
					and ('%.5e'):format(value) or ('%.5f'):format(value)),
				color = {1,1,1,1},
				fontSize={fontSizeX, -fontSizeY},
				multiLine=false,
			}
		end
		self.font:draw{
			pos = {xmin, ymax, gridz},
			text = varName,
			color = {1,1,1,1},
			fontSize = {fontSizeX, -fontSizeY},
			multiLine = false,
		}
	end
end

--[[ 
Alright, with the advent of the mesh solvers, now the display code gets a bit more confusing.
The previous display code was all specific to grid solvers.  But now I need a separate branch here for the mesh solver display.
So it would be best to just move the display code into the solver.
But then what about overlapping display across multiple solvers?  
Especially the 1D display that needs to get info from all solvers in order to correctly calculate the graph bounds.
Until then, I'll just change the 2D heatmap display to only work with grid solvers, and make an alternative one to work with non-grid solvers.
--]]
function HydroCLApp:display2D(...)
	for _,method in ipairs(display2DMethods) do
		local name, func = next(method)
		if self.display2DMethodsEnabled[name] then
			func(self, ...)
		end
	end
end

function HydroCLApp:display3D(...)
	self.display3DMethod = self.display3DMethod or 1 
	select(2, next(display3DMethods[self.display3DMethod]))(self, ...)
end

if targetSystem ~= 'console' then
	--require 'draw.vectorfield'.applyToApp(HydroCLApp)
	require 'draw.vectorfield2'.applyToApp(HydroCLApp)
end


HydroCLApp.display_useCoordMap = cmdline.display_useCoordMap 
if HydroCLApp.display_useCoordMap == nil then HydroCLApp.display_useCoordMap = true end

function HydroCLApp:updateGUI()
	if ig.igCollapsingHeader'simulation' then
		if ig.igButton(self.running and 'Stop' or 'Start') then
			self.running = not self.running
		end
		ig.igSameLine()
		if ig.igButton'Step' then
			self.running = 'step'
		end
		ig.igSameLine()
		if ig.igButton'Reset' then
			print'resetting...'
			for _,solver in ipairs(self.solvers) do
				solver:resetState()
			end
			self.running = false
		end
		
		if ig.igButton'Save' then
			-- save as cfits 
			for i,solver in ipairs(self.solvers) do
				solver:save(tostring(i))
			end
		end
		
		-- dump min/max(/avg?) of displayvars to a .txt file
		tooltip.checkboxTable('dump to text file', dumpFile, 'enabled')

		if ig.igButton'Screenshot' then
			self:screenshot()
		end
		ig.igSameLine()

		tooltip.comboTable('screenshot ext', self, 'screenshotExtIndex', self.screenshotExts)

		if ig.igButton(self.createAnimation and 'stop frame dump' or 'start frame dump') then
			self.createAnimation = not self.createAnimation
		end

		tooltip.checkboxTable('stack graphs', self, 'displayAllTogether')

		tooltip.checkboxTable('bilinear textures', self, 'displayBilinearTextures')

		if ig.igRadioButtonBool('ortho', self.view == self.orthoView) then
			self.view = self.orthoView
		end
		ig.igSameLine()
		if ig.igRadioButtonBool('frustum', self.view == self.frustumView) then
			self.view = self.frustumView
		end
	
		-- TODO flag for separate/combined displays (esp for ortho view)

		-- TODO flag to toggle slice vs volume display
		-- or maybe checkboxes for each kind?
		
		if self.solvers[1] then
			local dim = self.solvers[1].dim
			if dim == 2 then
				ig.igPushIDStr'2D'
				for i,method in ipairs(display2DMethods) do
					if i > 1 then ig.igSameLine() end
					local name, func = next(method)
					tooltip.checkboxTable(name, self.display2DMethodsEnabled, name)
				end
				
				if self.display2DMethodsEnabled.Graph 
				and self.draw2DGraph
				then
					tooltip.intTable('graph step', self.draw2DGraph, 'step')
				end
				
				ig.igPopID()
			
			elseif dim == 3 then
				ig.igPushIDStr'3D'
				tooltip.comboTable('Display Method', self, 'display3DMethod', display3DMethodNames)
				
				-- if we're doing 3D slice display 
				if HydroCLApp.display3D_Slice == select(2, next(display3DMethods[self.display3DMethod])) then

if useClipPlanes then
					ig.igRadioButton("rotate camera", rotateClip, 0)
					for i,clipInfo in ipairs(clipInfos) do
						ig.igPushIDStr('clip '..i)
						tooltip.checkbox('clip', clipInfo, 'enabled')
						ig.igSameLine()
						ig.igRadioButton('rotate', rotateClip, i)
						ig.igSameLine()
						if ig.igButton('reset') then
							clipInfo.plane = makeDefaultPlane(i)
						end
						ig.igPopID()
					end				
end					
					local draw3DSlice = self.draw3DSlice
					if draw3DSlice then
						tooltip.sliderTable('alpha', draw3DSlice, 'alpha', 0, 1)
						tooltip.sliderTable('gamma', draw3DSlice, 'alphaGamma', 0, 1)
						tooltip.checkboxTable('isobars', draw3DSlice, 'useIsos')
						if draw3DSlice.useIsos then
							tooltip.intTable('num isobars', draw3DSlice, 'numIsobars')
						end
						tooltip.checkboxTable('lighting', draw3DSlice, 'useLighting')
						tooltip.checkboxTable('pointcloud', draw3DSlice, 'usePoints')
						if not self.draw3DSlice.usePoints then
							tooltip.intTable('num slices', draw3DSlice, 'numSlices')
						end
					end
				end
				ig.igPopID()
			end
		
			--ig.igCheckbox('vector field', self.enableVectorField)
		
			-- for 2D heatmap only:
			tooltip.checkboxTable('display with coord map', self, 'display_useCoordMap')
	
			tooltip.checkboxTable('show coords', self, 'showMouseCoords')
		
			tooltip.numberTable('vector field scale', self, 'displayVectorField_scale')
			--tooltip.sliderTable('vector field scale', self, 'displayVectorField_scale', 0, 100, nil, 10)
			
			tooltip.intTable('vector field step', self, 'displayVectorField_step')
			self.displayVectorField_step = math.max(self.displayVectorField_step, 1)
		end
	end
	
	for i,solver in ipairs(self.solvers) do
		ig.igPushIDStr('solver '..i)
		if ig.igCollapsingHeader(solver.name) then
			-- TODO new window for each
			solver:updateGUI()
		end
		ig.igPopID()
	end

	if self.showMouseCoords then
		ig.igBeginTooltip()
		ig.igText(self:getCoordText())
		ig.igText(self.mouseCoordValue)
		ig.igEndTooltip()
	end
end
HydroCLApp.showMouseCoords = true
HydroCLApp.mouseCoord = {0,0}
HydroCLApp.mouseCoordValue = ''	-- TODO store one per inst of App

function HydroCLApp:getCoordText()
	return ('%f, %f'):format(self.mouseCoord[1], self.mouseCoord[2])
end


local leftShiftDown, rightShiftDown
local leftGuiDown, rightGuiDown
function HydroCLApp:event(event, ...)
	if HydroCLApp.super.event then
		HydroCLApp.super.event(self, event, ...)
	end
	local shiftDown = leftShiftDown or rightShiftDown
	local guiDown = leftGuiDown or rightGuiDown
	if event.type == sdl.SDL_MOUSEMOTION then
		if canHandleMouse() then
			local dx = event.motion.xrel
			local dy = event.motion.yrel
			if mouse.leftDown and not guiDown then
				if shiftDown then
					if dx ~= 0 or dy ~= 0 then
						self.view:mouseZoom(-dy, dy)
					end
				else
					if dx ~= 0 or dy ~= 0 then
						self.view:mousePan(dx, dy, self:size())
					end
				end
			end
		end
	elseif event.type == sdl.SDL_KEYDOWN then
		if event.key.keysym.sym == sdl.SDLK_LSHIFT then
			leftShiftDown = true
		elseif event.key.keysym.sym == sdl.SDLK_RSHIFT then
			rightShiftDown = true
		elseif event.key.keysym.sym == sdl.SDLK_LGUI then
			leftGuiDown = true
		elseif event.key.keysym.sym == sdl.SDLK_RGUI then
			rightGuiDown = true
		end
	elseif event.type == sdl.SDL_KEYUP then
		if event.key.keysym.sym == sdl.SDLK_LSHIFT then
			leftShiftDown = false
		elseif event.key.keysym.sym == sdl.SDLK_RSHIFT then
			rightShiftDown = false
		elseif event.key.keysym.sym == sdl.SDLK_LGUI then
			leftGuiDown = false
		elseif event.key.keysym.sym == sdl.SDLK_RGUI then
			rightGuiDown = false
		elseif canHandleKeyboard() then
			if event.key.keysym.sym == sdl.SDLK_SPACE then
				self.running = not self.running
			elseif event.key.keysym.sym == ('u'):byte() then
				self.running = 'step'
			elseif event.key.keysym.sym == ('r'):byte() then
				print'resetting...'
				for _,solver in ipairs(self.solvers) do
					solver:resetState()
				end
				self.running = false
			end
		end
	end
end

-- this was a function of its own, but i want it to be per-App (rather than per-Lua)
-- so I'm merging it with App...
function HydroCLApp:uniqueName(name)
	self.allnames = self.allnames or {}
	-- don't use the base name because I'm using the base name in my typedefs per-source file
	for i=1,math.huge do
		local try = name..'_'..i
		if not self.allnames[try] then
			self.allnames[try] = true
			return try
		end
	end
end

return HydroCLApp
