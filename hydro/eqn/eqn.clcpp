namespace Hydro {

//equation parent-class
// TODO crtp this
template<
	typename Child_,
	typename ChildTraits_
>
struct Eqn {
	using Child = Child_;
	using ChildTraits = ChildTraits_;
	using Solver = typename ChildTraits::Solver;
	using Cons = typename ChildTraits::Cons;
	using Prim = typename ChildTraits::Prim;
	using Normal = typename ChildTraits::Normal;
	using Cell = typename ChildTraits::Cell;
	using Eigen = typename ChildTraits::Eigen;
	using Waves = typename ChildTraits::Waves;
	using InitCond = typename ChildTraits::InitCond;

	//default implementation assumes Cons == Prim:

	static constexpr bool roeUseFluxFromCons = <?=eqn.roeUseFluxFromCons?>;

	static inline Prim primFromCons(
		constant Solver const & solver,
		Cons const & U,
		real3 const pt
	)
	//requires std::is_same_v<Prim, Cons>
	{
		return U;
	}

	static inline Cons consFromPrim(
		constant Solver const & solver,
		Prim const & W,
		real3 const pt
	)
	//requires std::is_same_v<Prim, Cons>
	{
		return W;
	}

	// only used by PLM
	static inline Cons apply_dU_dW(
		constant Solver const & solver,
		Prim const & WA,
		Prim const & W,
		real3 const x
	)
	//requires std::is_same_v<Prim, Cons>
	{
		return W;
	}

	// only used by PLM
	static inline Prim apply_dW_dU(
		constant Solver const & solver,
		Prim const & WA,
		Cons const & U,
		real3 const x
	)
	//requires std::is_same_v<Prim, Cons>
	{
		return U;
	}




	// TODO put all the epsilons in one place?
	//static constexpr real faceAreaEpsilon = 1e-7;
	//static constexpr real cellVolumeEpsilon = 1e-7;
	static constexpr real faceAreaEpsilon = 0;
	static constexpr real cellVolumeEpsilon = 0;

	static inline void calcDTCell(
		real & dt,
		constant Solver const & solver,
		global Cons const & U,
		global Cell const & cell
	) {
		auto calcWaves = typename Child::ConsWaveCodeMinMaxAllSides(solver, U, cell.pos);
		<? for side=0,solver.dim-1 do ?>{
			constexpr int side = <?=side?>;
<?
if solver.coord.vectorComponent == "holonomic"
or require "hydro.coord.cartesian":isa(solver.coord)
then ?>
			real const dx = solver.grid_dx[side];
<? else ?>
//// MODULE_DEPENDS: <?=cell_dxs?>
			real const dx = cell_dxs<side>(solver, cell.pos);
<? end ?>
			if (dx > faceAreaEpsilon) {
				auto const n = Normal::template forSide<side>(cell.pos);
				// use cell-centered eigenvalues
				real lambdaMin, lambdaMax;
				calcWaves(solver, n, U, cell.pos, &lambdaMin, &lambdaMax);
				real absLambdaMax = max(fabs(lambdaMin), fabs(lambdaMax));
				absLambdaMax = max((real)1e-9, absLambdaMax);
				dt = (real)min(dt, dx / absLambdaMax);
			}
		}<? end ?>
	}

	static void calcDT(
		constant Solver const & solver,
		global real * const dtBuf,
		global Cons const * const UBuf,
		global Cell const * const cellBuf
<?
if require "hydro.solver.meshsolver":isa(solver) then
?>,
		global <?=face_t?> const * const faces,
		global int const * const cellFaceIndexes
<?
end
?>
	) {
//// MODULE_DEPENDS: <?=SETBOUNDS?>
		<?=SETBOUNDS?>(0,0);

		//write inf to boundary cells
		//TODO why not write inf to boundary cells upon init,
		// and then give this the domain SETBOUNDS_NOGHOST?
		//that would work except that it is writing to reduceBuf, which is reused for any reduce operation
		// like display var min/max ranges
		global real & dt = dtBuf[index];
		dt = INFINITY;

		if (OOB<dim>(solver, i, solver.numGhost, solver.numGhost)) return;
		global Cons const & U = UBuf[index];
		global Cell const & cell = cellBuf[index];
		calcDTCell(
			dt,
			solver,
			U,
			cell
<?
if require "hydro.solver.meshsolver":isa(solver) then
?>			,
			faces,
			cellFaceIndexes
<?
end
?>
		);
	}

};	// struct Eqn

}	// namespace Hydro

// insert here Hydro{ InitCond{} }
// and <?=Solver?>::InitCondC
<?=initCode()?>

//this has to go afer the subclass def ... or TODO template instanciate or something.
#if 0
//// MODULE_DEPENDS: <?=solver_t?> <?=cons_t?> <?=cell_t?> <?=face_t?>
namespace <?=Solver?> {
struct Eqn;
}

// TODO std::forward implementation
kernel void <?=calcDT?>(
	constant <?=solver_t?> const * const psolver,
	global real * const dtBuf,
	global <?=cons_t?> const * const UBuf,
	global <?=cell_t?> const * const cellBuf
<?
if require "hydro.solver.meshsolver":isa(solver) then
?>	,
	global <?=face_t?> const * const faces,
	global int const * const cellFaceIndexes
<?
end
?>
) {
	auto const & solver = *psolver;
	<?=Solver?>::Eqn::calcDT(solver, dtBuf, UBuf, cellBuf
<?
if require "hydro.solver.meshsolver":isa(solver) then
?>, faces, cellFaceIndexes
<?
end
?>	);
}

kernel void <?=applyInitCond?>(
	constant <?=solver_t?> const * const psolver,
	constant <?=initCond_t?> const * const pinitCond,
	global <?=cons_t?> * const UBuf,
	global <?=cell_t?> * const cellBuf
) {
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(0,0);
	<?=Solver?>::Eqn::applyInitCondCell(solver, *pinitCond, UBuf[index], cellBuf[index]);
}

#endif
