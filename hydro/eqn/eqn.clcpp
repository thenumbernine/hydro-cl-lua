namespace Hydro {

//equation parent-class
// TODO crtp this
template<
	typename Base_,
	typename Solver_,
	typename Cons_,
	typename Prim_,
	typename Normal_,
	typename Cell_,
	typename Eigen_,
	typename Waves_,
	typename InitCond_
>
struct Eqn {
	using Base = Base_;
	using Solver = Solver_;
	using Cons = Cons_;
	using Prim = Prim_;
	using Normal = Normal_;
	using Cell = Cell_;
	using Eigen = Eigen_;
	using Waves = Waves_;
	using InitCond = InitCond_;
	//using Cons = typename Base::Cons;
	//using Prim = typename Base::Prim;
	//using Normal = typename Base::Normal;
	//using Cell = typename Base::Cell;
	//using Eigen = typename Base::Eigen;
	//using Waves = typename Base::Waves;
	//using InitCond = typename Base::InitCond;

	//default implementation assumes Cons == Prim:

	static constexpr bool roeUseFluxFromCons = <?=eqn.roeUseFluxFromCons?>;

	static inline Prim primFromCons(
		constant Solver const & solver,
		Cons const & U,
		real3 const pt
	) 
	//requires std::is_same_v<Prim, Cons>
	{
		return U;
	}

	static inline Cons consFromPrim(
		constant Solver const & solver,
		Prim const & W,
		real3 const pt
	)
	//requires std::is_same_v<Prim, Cons>
	{
		return W;
	}

	// only used by PLM
	static inline Cons apply_dU_dW(
		constant Solver const & solver,
		Prim const & WA,
		Prim const & W,
		real3 const x
	)
	//requires std::is_same_v<Prim, Cons>
	{
		return W;
	}

	// only used by PLM
	static inline Prim apply_dW_dU(
		constant Solver const & solver,
		Prim const & WA,
		Cons const & U,
		real3 const x
	)
	//requires std::is_same_v<Prim, Cons>
	{
		return U;
	}




	// TODO put all the epsilons in one place?
	//static constexpr real faceAreaEpsilon = 1e-7;
	//static constexpr real cellVolumeEpsilon = 1e-7;
	static constexpr real faceAreaEpsilon = 0;
	static constexpr real cellVolumeEpsilon = 0;

	static inline void calcDTCell(
		real & dt,
		constant Solver const & solver,
		global Cons const & U,
		global Cell const & cell
	) {
		auto calcWaves = typename Base::ConsWaveCodeMinMaxAllSides(solver, U, cell.pos);
		<? for side=0,solver.dim-1 do ?>{
<?
if solver.coord.vectorComponent == "holonomic"
or require "hydro.coord.cartesian":isa(solver.coord)
then ?>
			real const dx = solver.grid_dx[<?=side?>];
<? else ?>
			real const dx = cell_dx<?=side?>(cell.pos);
<? end ?>
			if (dx > faceAreaEpsilon) {
				auto const n = Normal::template forSide<<?=side?>>(cell.pos);
				// use cell-centered eigenvalues
				real lambdaMin, lambdaMax;
				calcWaves(solver, n, U, cell.pos, &lambdaMin, &lambdaMax);
				real absLambdaMax = max(fabs(lambdaMin), fabs(lambdaMax));
				absLambdaMax = max((real)1e-9, absLambdaMax);
				dt = (real)min(dt, dx / absLambdaMax);
			}
		}<? end ?>
	}

	static void calcDT(
		constant Solver const & solver,
		global real * const dtBuf,
		global Cons const * const UBuf,
		global Cell const * const cellBuf
<?
if require "hydro.solver.meshsolver":isa(solver) then
?>,
		global <?=face_t?> const * const faces,
		global int const * const cellFaceIndexes
<?
end
?>
	) {
//// MODULE_DEPENDS: <?=SETBOUNDS?>		
		<?=SETBOUNDS?>(0,0);
		
		//write inf to boundary cells
		//TODO why not write inf to boundary cells upon init,
		// and then give this the domain SETBOUNDS_NOGHOST?
		//that would work except that it is writing to reduceBuf, which is reused for any reduce operation
		// like display var min/max ranges
		global real & dt = dtBuf[index];
		dt = INFINITY;
		
		if (OOB<dim>(solver, i, solver.numGhost, solver.numGhost)) return;
		global Cons const & U = UBuf[index];
		global Cell const & cell = cellBuf[index];
		calcDTCell(
			dt,
			solver,
			U,
			cell
<?
if require "hydro.solver.meshsolver":isa(solver) then
?>			,
			faces,
			cellFaceIndexes
<?
end
?>
		);
	}

};	// struct Eqn

}	// namespace Hydro


//this has to go afer the subclass def ... or TODO template instanciate or something.
#if 0
//// MODULE_DEPENDS: <?=solver_t?> <?=cons_t?> <?=cell_t?> <?=face_t?>
namespace <?=Equation?> {
struct Eqn;
}

// TODO std::forward implementation
kernel void <?=calcDT?>(
	constant <?=solver_t?> const * const psolver,
	global real * const dtBuf,
	global <?=cons_t?> const * const UBuf,
	global <?=cell_t?> const * const cellBuf
<?
if require "hydro.solver.meshsolver":isa(solver) then
?>	,
	global <?=face_t?> const * const faces,
	global int const * const cellFaceIndexes
<?
end
?>
) {
	auto const & solver = *psolver;
	<?=Equation?>::Eqn::calcDT(solver, dtBuf, UBuf, cellBuf
<?
if require "hydro.solver.meshsolver":isa(solver) then
?>, faces, cellFaceIndexes
<?
end
?>	);
}

kernel void <?=applyInitCond?>(
	constant <?=solver_t?> const * const psolver,
	constant <?=initCond_t?> const * const pinitCond,
	global <?=cons_t?> * const UBuf,
	global <?=cell_t?> * const cellBuf
) {
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(0,0);
	<?=Equation?>::Eqn::applyInitCondCell(solver, *pinitCond, UBuf[index], cellBuf[index]);
}

#endif
