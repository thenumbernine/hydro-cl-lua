//// MODULE_NAME: calcFluxForInterface
//// MODULE_DEPENDS: <?=fluxLimiter?> <?=Solver?> realparam

// Roe solver:

<? 
local useFluxLimiter = solver.fluxLimiter > 1 
	and flux.usesFluxLimiter -- just flux/roe.lua right now
?>

namespace <?=Solver?> {

template<
	typename Eqn,
	bool roeUseFluxFromCons = false
>
struct AddFluxFromCons {};
		
template<
	typename Eqn
>
struct AddFluxFromCons<Eqn, false> {
	static void go(
		constant Solver const & solver,
		Cons & resultFlux,
		Cons const & UL,
		Cons const & UR,
		Cell const & cellL,
		Cell const & cellR,
		Normal const n
	) {
	}
};

// TODO how to sfinae so this doesn't compile when boolean param is false
template<
	typename Eqn
>
struct AddFluxFromCons<Eqn, true> {
	static void go(
		constant Solver const & solver,
		Cons & resultFlux,
		Cons const & UL,
		Cons const & UR,
		Cell const & cellL,
		Cell const & cellR,
		Normal const n
	) {
		// TODO hmm, fluxFromCons vs eigen_fluxTransform using the 'eig' structure
		// fluxFromCons is using the left and right states to create their flux jacobian transform - applied to the left and right states to make the left and right flux vector
		// which is F(U)
		// while eigen_fluxTransform would use the intermediate state to create the flux vector
		// which is dF/dU * dU/dx
		// It turns out dF/dU * U = F *ONLY FOR* the Euler fluid equations, and this is why lots of literature assumes it is true for all equations (when it's not).
		// But that means roeUseFluxFromCons==true's option is the correct one, but not ==false?
		// But Dullemond eqn 6.56 says that the FL and FR come from R Lambda L U = dF/dU * U calculations ...
		// ... which are *ONLY* equal to F in the case of the Euler fluid equations, and systems with linear flux jacobians, (NOT shallow-water).
		// So that would mean this part is wrong.
		// But maybe the description in Dullemond and other sources is wrong.
		// Because this value itself is diff'd across the cell, so it is a 'dF', so you wouldn't want to compute a second 'd' of it via R Lambda L, because that would give you 'd dF'.
		// so roeUseFluxFromCons==true is good.
	
		Cons FL = Eqn::fluxFromCons(solver, UL, cellL, n);
		Cons FR = Eqn::fluxFromCons(solver, UR, cellR, n);

		for (int j = 0; j < numIntStates; ++j) {
			resultFlux.s[j] += .5 * (FL.s[j] + FR.s[j]);
		}
	}
};

struct RoeFlux {

	//TODO entropy fix ... for the Euler equations at least
	static inline Cons calcFluxForInterface(
		constant Solver const & solver,
		
		// 1st order stencil information
		Cons const & UL,
		Cons const & UR,
		Cell const & cellL,
		Cell const & cellR,
		real3 const xInt,
		
		// normal
		Normal const n
	
	<? if useFluxLimiter then ?>
		,
		// dt/dx ... meh
		realparam const dt_dx,
		
		//2nd order stencil information
		Cons const & UL_L,
		Cons const & UL_R,
		Cell const & cellL_L,
		Cell const & cellL_R,
		real3 const xIntL,
		Cons const & UR_L,
		Cons const & UR_R,
		Cell const & cellR_L,
		Cell const & cellR_R,
		real3 const xIntR
	<? end ?>
	) {
		Cons resultFlux;
		Eigen eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);

		auto calcWaves = Eqn::EigenWaveCode(solver, eig, n, xInt);

		Waves fluxEig;
		if constexpr (!Eqn::roeUseFluxFromCons) {
			Cons UAvg;
			for (int j = 0; j < numIntStates; ++j) {
				UAvg.s[j] = .5 * (UL.s[j] + UR.s[j]);
			}
			fluxEig = Eqn::eigen_leftTransform(solver, eig, UAvg, xInt, n);
		}
		
		Cons deltaU;
	<? if useFluxLimiter then ?>	
		Cons deltaUL, deltaUR;
	<? end ?>
		
		for (int j = 0; j < numStates; ++j) {
			deltaU.s[j] = UR.s[j] - UL.s[j];
	<? if useFluxLimiter then ?>		
			deltaUL.s[j] = UR_L.s[j] - UL_L.s[j];
			deltaUR.s[j] = UR_R.s[j] - UL_R.s[j];
	<? end ?>
		}

		Waves deltaUEig = Eqn::eigen_leftTransform(solver, eig, deltaU, xInt, n);
	<? 	if useFluxLimiter then ?>
		Eigen eigL = Eqn::eigen_forInterface(solver, UL_L, UR_L, cellL_L, cellR_L, xIntL, n);
		Eigen eigR = Eqn::eigen_forInterface(solver, UL_R, UR_R, cellL_R, cellR_R, xIntR, n);
		Waves deltaUEigL = Eqn::eigen_leftTransform(solver, eigL, deltaUL, xIntL, n);
		Waves deltaUEigR = Eqn::eigen_leftTransform(solver, eigR, deltaUR, xIntR, n);
	<? 	end ?>

	<? if flux.useEntropyFluxFix then ?>
		real const speedOfSound = eig.Cs; //This is Euler-specific, so TODO abstract this.
		real const lambdaLimitingFactor = <?=clnumber(flux.entropyFluxFixLimitingFactor)?>;
	<? end ?>

		for (int j = 0; j < numWaves; ++j) {
			real lambda = calcWaves(solver, eig, n, xInt, j);

	<? if flux.useEntropyFluxFix then ?>
	// So, here is where the Hartan entropy fix goes.
	// Is it used everywhere the lambdas are used, or only in the Roe flux use of lambdas?
	// Should it go before or after the flux limiter?
			real const dws = lambdaLimitingFactor * speedOfSound;
			if (fabs(lambda) < dws) lambda = sign(lambda) * .5 * (lambda * lambda / dws + dws);
	<? end ?>

		if constexpr (!Eqn::roeUseFluxFromCons) {
			fluxEig.s[j] *= lambda;
		} else {
			fluxEig.s[j] = 0.;
		}
			real sgnLambda = lambda >= 0 ? 1 : -1;

	<? if useFluxLimiter then ?>
			real rEig;
			if (deltaUEig.s[j] == 0) {
				rEig = 0;
			} else {
				if (lambda >= 0) {
					rEig = deltaUEigL.s[j] / deltaUEig.s[j];
				} else {
					rEig = deltaUEigR.s[j] / deltaUEig.s[j];
				}
			}
			real phi = <?=fluxLimiter?>(rEig);
	<? end ?>
			fluxEig.s[j] -= .5 * lambda * deltaUEig.s[j] * (sgnLambda
	<? if useFluxLimiter then ?>
				+ phi * (lambda * (dt_dx) - sgnLambda)
	<? end ?>
			);
		}

		resultFlux = Eqn::eigen_rightTransform(solver, eig, fluxEig, xInt, n);

		//sfinae to hide Eqn::fluxFromCons
		AddFluxFromCons<Eqn, Eqn::roeUseFluxFromCons>::go(solver, resultFlux, UL, UR, cellL, cellR, n);

		return resultFlux;
	}
};

using Flux = RoeFlux;

}	//namespace <?=Solver?>
