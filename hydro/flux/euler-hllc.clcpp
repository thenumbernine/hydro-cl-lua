//// MODULE_NAME: calcFluxForInterface
//// MODULE_DEPENDS: <?=Solver?>

//HLLC based on
//http://math.lanl.gov/~shenli/publications/hllc_mhd.pdf
//2012 Toro, "The HLLC Riemann Solver" presentation: http://marian.fsik.cvut.cz/~bodnar/PragueSum_2012/Toro_2-HLLC-RiemannSolver.pdf
<?
if not require "hydro.eqn.euler":isa(solver.eqn) then 
	error("euler-hllc only works with euler eqn") 
end
?>

namespace <?=Solver?> {

constexpr bool flux_hllc_useInterfaceWaves = true;

enum {
	HLLC_ORIGINAL,
	HLLC_DAVIS_DIRECT,
	HLLC_DAVIS_DIRECT_BOUNDED,
};

struct EulerHLLCFlux {

	static inline Cons calcFluxForInterface(
		constant Solver const & solver,
		Cons const & UL,
		Cons const & UR,
		Cell const & cellL,
		Cell const & cellR,
		real3 const xInt,
		Normal const n
	) {
		Prim WL = Eqn::primFromCons(solver, UL, cellL.pos);
		Prim WR = Eqn::primFromCons(solver, UR, cellR.pos);

		real sL, sR;
		if (flux_hllc_useInterfaceWaves) {
			/*
			get min/max lambdas of UL, UR, and interface U (based on Roe averaging)
			TODO this in a more computationally efficient way
			
			This still needs the 'xInt' arg because some things (eig parameters derived from the averaged parameters, glm-mhd's calcRoeValues, navstokes-wilcox, twofluid-emhd & -lingr, etc) use it, and why recalculate it?
			But mind you not everyone uses the xInt, so it shouldn't always be calculated right?
			This is where fully-analytical implementations are handy (like BSSN is becoming).
			*/
			Eigen eigInt = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);

			real lambdaIntMin, lambdaIntMax;
			Eqn::eigenWaveCodeMinMax(solver, eigInt, n, xInt, &lambdaIntMin, &lambdaIntMax);

			if (solver.flux_hllcMethod == HLLC_DAVIS_DIRECT) {
				sL = lambdaIntMin;
				sR = lambdaIntMax;
			} else if (solver.flux_hllcMethod == HLLC_DAVIS_DIRECT_BOUNDED) {
				real lambdaLMin;
				Eqn::consWaveCodeMinMax(solver, UL, n, cellL.pos, &lambdaLMin, {});
				real lambdaRMax;
				Eqn::consWaveCodeMinMax(solver, UR, n, cellR.pos, {}, &lambdaRMax);

				sL = min(lambdaLMin, lambdaIntMin);
				sR = max(lambdaRMax, lambdaIntMax);
			}
		} else {  // don't use interface waves.  looks no different than above, soo ... why even use interface state waves?
			real sLMin, sLMax;
			Eqn::consWaveCodeMinMax(solver, UL, n, cellL.pos, &sLMin, &sLMax);
			real sRMin, sRMax;
			Eqn::consWaveCodeMinMax(solver, UR, n, cellR.pos, &sRMin, &sRMax);
			sL = min(sLMin, sRMin);
			sR = max(sLMax, sRMax);
		}

		// notice that, for Euler, consWaveCodePrefix calculates v dot n1 ... while here we're using v dot nj
		real3 const vnL = n.vecDotNs(WL.v);
		real3 const vnR = n.vecDotNs(WR.v);

	<? assert(solver.flux.hllcMethod) ?>	
		real const sStar = (WR.rho * vnR.x * (sR - vnR.x) - WL.rho * vnL.x * (sL - vnL.x) + WL.P - WR.P) 
			/ (WR.rho * (sR - vnR.x) - WL.rho * (sL - vnL.x));

		Cons flux;

		if (solver.flux_hllcMethod == 0) {
		
			if (0 <= sL) {
				flux = Eqn::fluxFromCons(solver, UL, cellL, n);
			} else if (sL <= 0. && 0. <= sStar) {
				Cons FL = Eqn::fluxFromCons(solver, UL, cellL, n);
				Cons ULStar;
				ULStar.rho = UL.rho * (sL - vnL.x) / (sL - sStar);
				
				real3 vStar = n.vecFromNs(real3(sStar, vnL.y, vnL.z));
				ULStar.m.x = ULStar.rho * vStar.x;
				ULStar.m.y = ULStar.rho * vStar.y;
				ULStar.m.z = ULStar.rho * vStar.z;
				
				ULStar.ETotal = ULStar.rho * (
					UL.ETotal / UL.rho
					+ (sStar - vnL.x) 
						* (sStar + WL.P / (UL.rho * (sL - vnL.x)))
				);
				for (int i = 0; i < numStates; ++i) {
					flux.ptr[i] = FL.ptr[i] + sL * (ULStar.ptr[i] - UL.ptr[i]);
				}
			} else if (sStar <= 0. && 0. <= sR) {
				Cons FR = Eqn::fluxFromCons(solver, UR, cellR, n);
				Cons URStar;
				URStar.rho = UR.rho * (sR - vnR.x) / (sR - sStar);
				
				real3 vStar = n.vecFromNs(real3(sStar, vnR.y, vnR.z));
				URStar.m.x = URStar.rho * vStar.x;
				URStar.m.y = URStar.rho * vStar.y;
				URStar.m.z = URStar.rho * vStar.z;
				
				URStar.ETotal = URStar.rho * (
					UR.ETotal / UR.rho
					+ (sStar - vnR.x) 
						* (sStar + WR.P / (UR.rho * (sR - vnR.x))));
				for (int i = 0; i < numStates; ++i) {
					flux.ptr[i] = FR.ptr[i] + sR * (URStar.ptr[i] - UR.ptr[i]);
				}
			} else if (sR <= 0) {
				flux = Eqn::fluxFromCons(solver, UR, cellR, n);
	#if 1	//why is this here? for when sStar is not between sL and sR
			} else if (sL <= 0 && 0 <= sR) {
				Cons FL = Eqn::fluxFromCons(solver, UL, cellL, n);
				Cons FR = Eqn::fluxFromCons(solver, UR, cellR, n);
				for (int j = 0; j < numIntStates; ++j) {
					flux.ptr[j] = (sR * FL.ptr[j] - sL * FR.ptr[j] + sL * sR * (UR.ptr[j] - UL.ptr[j])) / (sR - sL);
				}
	#endif
			}

		} else if (solver.flux_hllcMethod == 1) {

			if (0 <= sL) {
				flux = Eqn::fluxFromCons(solver, UL, cellL, n);
			} else if (sL <= 0. && 0. <= sStar) {
				Cons FL = Eqn::fluxFromCons(solver, UL, cellL, n);
				flux.rho = (sStar * (sL * UL.rho - FL.rho)) / (sL - sStar);
			
				real3 ULmn = n.vecDotNs(UL.m);
				real3 FLmn = n.vecDotNs(FL.m);
				flux.m = n.vecFromNs(real3(
					(sStar * (sL * ULmn.x - FLmn.x) + sL * (WL.P + WL.rho * (sL - vnL.x) * (sStar - vnL.x))) / (sL - sStar),
					(sStar * (sL * ULmn.y - FLmn.y)) / (sL - sStar),
					(sStar * (sL * ULmn.z - FLmn.z)) / (sL - sStar)
				));
				
				flux.ETotal = (sStar * (sL * UL.ETotal - FL.ETotal) + sL * (WL.P + WL.rho * (sL - vnL.x) * (sStar - vnL.x)) * sStar) / (sL - sStar);
			} else if (sStar <= 0. && 0. <= sR) {
				Cons FR = Eqn::fluxFromCons(solver, UR, cellR, n);
				flux.rho = (sStar * (sR * UR.rho - FR.rho)) / (sR - sStar);
				
				real3 URmn = n.vecDotNs(UR.m);
				real3 FRmn = n.vecDotNs(FR.m);
				flux.m = n.vecFromNs(real3(
					(sStar * (sR * URmn.x - FRmn.x) + sR * (WR.P + WR.rho * (sR - vnR.x) * (sStar - vnR.x))) / (sR - sStar),
					(sStar * (sR * URmn.y - FRmn.y)) / (sR - sStar),
					(sStar * (sR * URmn.z - FRmn.z)) / (sR - sStar)
				));

				flux.ETotal = (sStar * (sR * UR.ETotal - FR.ETotal) + sR * (WR.P + WR.rho * (sR - vnR.x) * (sStar - vnR.x)) * sStar) / (sR - sStar);
			
			} else if (sR <= 0) {
				flux = Eqn::fluxFromCons(solver, UR, cellR, n);
	#if 1		//why is this here? for when sStar is not between sL and sR
			} else if (sL <= 0 && 0 <= sR) {
				Cons FL = Eqn::fluxFromCons(solver, UL, cellL, n);
				Cons FR = Eqn::fluxFromCons(solver, UR, cellR, n);
				for (int j = 0; j < numIntStates; ++j) {
					flux.ptr[j] = (sR * FL.ptr[j] - sL * FR.ptr[j] + sL * sR * (UR.ptr[j] - UL.ptr[j])) / (sR - sL);
				}
	#endif
			}

		} else if (solver.flux_hllcMethod == 2) {

			if (0 <= sL) {
				flux = Eqn::fluxFromCons(solver, UL, cellL, n);
			} else if (sL <= 0. && 0. <= sStar) {
				Cons FL = Eqn::fluxFromCons(solver, UL, cellL, n);
				real PLR = .5 * (
					WL.P
					+ WR.P
					+ WL.rho * (sL - vnL.x) * (sStar - vnL.x)
					+ WR.rho * (sR - vnR.x) * (sStar - vnR.x)
				);
				flux.rho = (sL * UL.rho - FL.rho) * sStar / (sL - sStar);
				
				real3 ULmn = n.vecDotNs(UL.m);
				real3 FLmn = n.vecDotNs(FL.m);
				flux.m = n.vecFromNs(real3(
					((sL * ULmn.x - FLmn.x) * sStar + sL * PLR) / (sL - sStar),
					sStar * (sL * ULmn.y - FLmn.y) / (sL - sStar),
					sStar * (sL * ULmn.z - FLmn.z) / (sL - sStar)
				));

				flux.ETotal = (sStar * (sL * UL.ETotal - FL.ETotal) + sL * PLR * sStar) / (sL - sStar);
			} else if (sStar <= 0. && 0. <= sR) {
				Cons FR = Eqn::fluxFromCons(solver, UR, cellR, n);
				real PLR = .5 * (WL.P + WR.P + WL.rho * (sL - vnL.x) * (sStar - vnL.x) + WR.rho * (sR - vnR.x) * (sStar - vnR.x));
				flux.rho = sStar * (sR * UR.rho - FR.rho) / (sR - sStar);
				
				real3 URmn = n.vecDotNs(UR.m);
				real3 FRmn = n.vecDotNs(FR.m);
				flux.m = n.vecFromNs(real3(
					//TODO why were these assigns here:?
					(sStar * (sR * URmn.x - FRmn.x) + sR * PLR) / (sR - sStar),
					sStar * (sR * URmn.y - FRmn.y) / (sR - sStar),
					sStar * (sR * URmn.z - FRmn.z) / (sR - sStar)
				));
				
				flux.ETotal = (sStar * (sR * UR.ETotal - FR.ETotal) + sR * PLR * sStar) / (sR - sStar);

			} else if (sR <= 0) {
				flux = Eqn::fluxFromCons(solver, UR, cellR, n);
	#if 1		//why is this here? for when sStar is not between sL and sR
			} else if (sL <= 0 && 0 <= sR) {
				Cons FL = Eqn::fluxFromCons(solver, UL, cellL, n);
				Cons FR = Eqn::fluxFromCons(solver, UR, cellR, n);
				for (int j = 0; j < numIntStates; ++j) {
					flux.ptr[j] = (sR * FL.ptr[j] - sL * FR.ptr[j] + sL * sR * (UR.ptr[j] - UL.ptr[j])) / (sR - sL);
				}
	#endif
			}

		} // solver.flux.hllcMethod
		

		//flux.m = real3_rotToEqn::side(flux.m);
		return flux;
	}
};

using Flux = EulerHLLCFlux;

}	// namespace <?=Solver?>
