<?=eqn:template(require"ext.file""hydro/init/init.clcpp":read())?>

namespace Hydro {

template<
	int dim_,
	typename Prim,
	typename CellArgs,
	typename GetPrimLR
>
struct RiemannProblem {
	static inline void initCond(
		CellArgs & args
	) {
		auto & [solver, initCond, x, U, rho, v, P, ePot, D, B] = args;
		auto mids = .5 * (solver.initCondMins + solver.initCondMaxs);
		bool lhs = true;
		for (int i = 0; i < dim_; ++i) {
			lhs &= x[i] < mids[i];
		}

		if (lhs) {
			GetPrimLR::buildL(args);
		} else {
			GetPrimLR::buildR(args);
		}
	}
};

#if 0	// declare Sod here (verbose atm)
template<
	int dim_,
	typename Prim,
	typename CellArgs
>
struct InitCond_Euler_Sod : public RiemannProblem<
	dim_,
	Prim,
	CellArgs,
	InitCond_Euler_Sod<dim_, Prim, CellArgs>
> {
	static void buildL(CellArgs & args) {
		args.rho = args.initCond.rhoL;
		args.P = args.initCond.PL;
	}
	static void buildR(CellArgs & args) {
		args.rho = args.initCond.rhoR;
		args.P = args.initCond.PR;
	}
};
#endif

template<
	int dim_,
	typename Prim,
	typename CellArgs
> struct InitCond_Euler_spiral {
	static inline void initCond(
		CellArgs & args
	) {
		auto & [solver, ic, x, U, rho, v, P, ePot, D, B] = args;
		auto mids = .5 * (solver.initCondMins + solver.initCondMaxs);
		
		bool lhs = true;
		for (int i = 0; i < dim_; ++i) {
			lhs &= x[i] < mids[i];
		}

//// MODULE_DEPENDS: <?=coordMap?>
		real3 const xc = coordMap(x);
		real const r2 = sqrt(xc.x * xc.x + xc.y * xc.y);
		real const dr2 = r2 - ic.torusGreaterRadius;
		real const tr = sqrt(xc.z * xc.z + dr2 * dr2);		//change this to L1 norm for square toroid
		bool const inside = tr < ic.torusLesserRadius;
		P = ic.P;
		rho = inside ? ic.rhoInside : ic.rhoOutside;
//// MODULE_DEPENDS: units
		v.x = -xc.y / r2 * ic.v / unit_m_per_s;
		v.y =  xc.x / r2 * ic.v / unit_m_per_s;
		D.x = -xc.y / r2 * ic.D / unit_C_per_m2;
		D.y =  xc.x / r2 * ic.D / unit_C_per_m2;
	}
};

}	//namespace Hydro
