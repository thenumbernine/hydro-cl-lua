//// MODULE_NAME: vec3
//// MODULE_TYPE:

//// BEGIN EXCLUDE FOR FFI_CDEF

//////////////////////////////// STL ////////////////////////////////

// TODO from here on down, put in its own header file
// but that means writing these files to the /cache/ident/src location
// or another location, and put that in the include search path of the clcpp compiler

//https://en.cppreference.com/w/cpp/types/integral_constant
namespace std {
	template<typename T, T v>
	struct integral_constant {
		static constexpr T value = v;
		using value_type = T;
		using type = integral_constant; // using injected-class-name
		constexpr operator value_type() const noexcept { return value; }
		constexpr value_type operator()() const noexcept { return value; } // since c++14
	};

	using true_type = integral_constant<bool, true>;
	using false_type = integral_constant<bool, false>;
}

//https://en.cppreference.com/w/cpp/types/void_t
namespace std {
	template<typename...> using void_t = void;
}

//https://en.cppreference.com/w/cpp/types/is_same
namespace std {
	template<typename T, typename U> struct is_same : std::false_type {};
	template<typename T> struct is_same<T, T> : std::true_type {};
	template<typename A, typename B> static constexpr bool is_same_v = is_same<A, B>::value;
}

//https://en.cppreference.com/w/cpp/types/enable_if
namespace std {
	template<bool B, typename T = void> struct enable_if {};
	template<typename T> struct enable_if<true, T> { using type = T; };
	template<bool B, typename T = void> using enable_if_t = typename enable_if<B, T>::type;
}
// best practices:
// enable_if on a defaulted template argument will interfere with template-specialization
// enable_if on a return type will interfere with auto return type
// so it looks like enable_if on defaulted function argument is the best way to go
// except for operators where signature matters

//https://en.cppreference.com/w/cpp/types/conditional
namespace std {
	template<bool B, class T, class F> struct conditional { using type = T; };
	template<class T, class F> struct conditional<false, T, F> { using type = F; };
	template<bool B, class T, class F> using conditional_t = typename conditional<B, T, F>::type;
}

//https://en.cppreference.com/w/cpp/types/type_identity
namespace std {
	template<class T> struct type_identity { using type = T; }; // or use std::type_identity (since C++20)
}

//https://en.cppreference.com/w/cpp/types/is_pointer
namespace std {
	template<typename T> struct is_pointer : std::false_type {};
	template<typename T> struct is_pointer<T*> : std::true_type {};
	template<typename T> struct is_pointer<T* const> : std::true_type {};
	template<typename T> struct is_pointer<T* volatile> : std::true_type {};
	template<typename T> struct is_pointer<T* const volatile> : std::true_type {};
}

//https://en.cppreference.com/w/cpp/types/remove_cv
namespace std {
	template<class T> struct remove_cv                   { using type = T; };
	template<class T> struct remove_cv<const T>          { using type = T; };
	template<class T> struct remove_cv<volatile T>       { using type = T; };
	template<class T> struct remove_cv<const volatile T> { using type = T; };
	template<class T> using remove_cv_t = typename remove_cv<T>::type;
	template<class T> struct remove_const                { using type = T; };
	template<class T> struct remove_const<const T>       { using type = T; };
	template<class T> using remove_const_t = typename remove_const<T>::type;
	template<class T> struct remove_volatile             { using type = T; };
	template<class T> struct remove_volatile<volatile T> { using type = T; };
	template<class T> using remove_volatile_t = typename remove_volatile<T>::type;
}

//https://en.cppreference.com/w/cpp/types/remove_reference
namespace std {
	template<class T> struct remove_reference      { using type = T; };
	template<class T> struct remove_reference<T&>  { using type = T; };
	template<class T> struct remove_reference<T&&> { using type = T; };
	template<class T> using remove_reference_t = typename remove_reference<T>::type;
}

//https://en.cppreference.com/w/cpp/types/remove_cvref
namespace std {
	template< class T >
	struct remove_cvref {
		using type = std::remove_cv_t<std::remove_reference_t<T>>;
	};
	template<class T> using remove_cvref_t = typename remove_cvref<T>::type;
}

//https://en.cppreference.com/w/cpp/types/add_reference
namespace std {
	template<typename T> struct add_lvalue_reference : public type_identity<T&> {};
	template<typename T> struct add_lvalue_reference<T&> : public type_identity<T&> {};
	template<typename T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
	template<typename T> struct add_rvalue_reference : public type_identity<T&&> {};
	template<typename T> struct add_rvalue_reference<T&&> : public type_identity<T&&> {};
	template<typename T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;
}

// based on above
namespace std {
	template<typename T> struct add_pointer : public type_identity<T*> {};
	template<typename T> using add_pointer_t = typename add_pointer<T>::type;
	template<typename T> struct remove_pointer : public type_identity<T> {};
	template<typename T> struct remove_pointer<T*> : public type_identity<T> {};
	template<typename T> using remove_pointer_t = typename remove_pointer<T>::type;
}

//https://en.cppreference.com/w/cpp/utility/declval
namespace std {
	template<typename T>
	constexpr bool always_false = false;

	template<typename T>
	typename std::add_rvalue_reference<T>::type declval() noexcept
	{
		static_assert(always_false<T>, "declval not allowed in an evaluated context");
	}
}

//https://en.cppreference.com/w/cpp/experimental/nonesuch
namespace std {
	struct nonesuch {
		~nonesuch() = delete;
		nonesuch(nonesuch const&) = delete;
		void operator=(nonesuch const&) = delete;
	};
}

//https://en.cppreference.com/w/cpp/experimental/is_detected
namespace std {
	namespace detail {
		template<class Default, class AlwaysVoid,
				  template<class...> class Op, class... Args>
		struct detector {
			using value_t = std::false_type;
			using type = Default;
		};

		template<class Default, template<class...> class Op, class... Args>
		struct detector<Default, std::void_t<Op<Args...>>, Op, Args...> {
			using value_t = std::true_type;
			using type = Op<Args...>;
		};
	} // namespace detail

	template<template<class...> class Op, class... Args>
	using is_detected = typename detail::detector<nonesuch, void, Op, Args...>::value_t;

	template<template<class...> class Op, class... Args>
	using detected_t = typename detail::detector<nonesuch, void, Op, Args...>::type;

	template<class Default, template<class...> class Op, class... Args>
	using detected_or = detail::detector<Default, void, Op, Args...>;

	template<template<class...> class Op, class... Args>
	static constexpr bool is_detected_v = is_detected<Op, Args...>::value;
}

//////////////////////////////// Tensor/Vector.h.h ////////////////////////////////

template<class T>
using has_tensorFlag = decltype(std::declval<T>().isTensorFlag);

template<typename T>
static constexpr bool is_tensor_v = std::is_detected_v<has_tensorFlag, T>;

template<typename A, typename B>
static constexpr bool IsBinaryTensorOp = is_tensor_v<A> && is_tensor_v<B>;

template<typename A, typename B>
static constexpr bool IsBinaryTensorR3xR3Op = IsBinaryTensorOp<A,B>
	&& A::rank == 1 && A::template dim<0> == 3
	&& B::rank == 1 && B::template dim<0> == 3;

template<typename Inner, int localDim>
union vec;

template<typename Inner_>
union sym3;

template<typename Inner>
using vec3 = vec<Inner, 3>;

// row vectors, so a.i.j = a_ij
template<typename Inner>
using mat3x3 = vec3<vec3<Inner>>;

//////////////////////////////// Tensor/Math.h.h ////////////////////////////////

#if 0	// needs iterator
template<
	typename A,
	typename B
>
constexpr auto dot(
	A const & a,
	B const & b,
	std::enable_if_t<IsBinaryTensorOp<A,B>>* = {}
);
#else	//until then, specific overrides ...
// vector-vector
template<typename A, typename B>
constexpr auto dot(
	A const & a,
	B const & b,
	std::enable_if_t<
		is_tensor_v<A> && A::rank == 1 &&
		is_tensor_v<B> && B::rank == 1 &&
		A::template dim<0> == B::template dim<0>
	>* = {}
);

// sym3-sym3
template<typename A, typename B>
constexpr auto dot(
	A const & a,
	B const & b,
	std::enable_if_t<
		is_tensor_v<A> && A::rank == 2 &&
		is_tensor_v<B> && B::rank == 2 &&
		A::template dim<0> == B::template dim<0> &&
		A::template dim<1> == B::template dim<1>
	>* = {}
);
#endif

template<typename T>
constexpr auto lenSq(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>* = {}
);

template<typename T>
constexpr auto length(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>* = {}
);

template<typename A, typename B>
constexpr auto distance(
	A const & a,
	B const & b,
	std::enable_if_t<IsBinaryTensorOp<A,B>>* = {}
);

template<typename T>
constexpr T normalize(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>* = {}
);

#if 0 // needs lambda ctor
template<typename A, typename B>
constexpr auto outer(
	A const & a,
	B const & b,
	std::enable_if_t<IsBinaryTensorOp<A,B>>* = {}
);
#else
template<typename real>
constexpr auto outer(
	vec3<real> const & a,
	vec3<real> const & b
);

// self-outer, returns sym3
template<typename real>
constexpr auto outer(vec3<real> const & a);
#endif

#if 0
template<
	int m = 0,
	int n = 1,
	typename T
>
constexpr auto trace(
	T const & v,
	std::enable_if_t<
		is_tensor_v<T> &&
		m < T::rank &&
		n < T::rank &&
		T::template dim<m> == T::template dim<n>
	>* = {}
);
#else
template<
	int m = 0,
	int n = 1,
	typename real
>
constexpr auto trace(
	sym3<real> const & v
);

template<
	int m = 0,
	int n = 1,
	typename real
>
constexpr auto trace(
	vec3<vec3<real>> const & v
);
#endif

#if 0
determinant
inverse
#else
template<typename real>
constexpr auto determinant(sym3<real> const & m);
template<typename real>
constexpr auto determinant(vec3<vec3<real>> const & m);

template<typename real>
constexpr auto inverse(sym3<real> const & m, real det);
template<typename real>
constexpr auto inverse(vec3<vec3<real>> const & m, real det);

template<typename real>
constexpr auto inverse(sym3<real> const & m);
template<typename real>
constexpr auto inverse(vec3<vec3<real>> const & m);
#endif

// 3D-specific:

template<
	typename A,
	typename B
>
constexpr auto cross(
	A const & a,
	B const & b,
	std::enable_if_t<IsBinaryTensorR3xR3Op<A,B>>* = {}
);

// 3D dimension-swapping functions
// TODO change to make sure it's a tensor of dim 3's all across (irrespective of rank)

template<
	typename T
>
constexpr auto swap(
	T const & v,
	int side,
	std::enable_if_t<is_tensor_v<T>>* = {}
);

template<
	int side,
	typename T
>
constexpr auto rotateFromSide(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>* = {}
);

template<
	int side,
	typename T
>
constexpr auto rotateToSide(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>* = {}
);

template<
	int dim,
	typename T,
	typename N
>
constexpr auto rotateFromInDim(
	T const & v,
	N const & n,
	std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}
);

template<
	int dim,
	typename T,
	typename N
>
constexpr auto rotateToInDim(
	T const & v,
	N const & n,
	std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}
);

//////////////////////////////// Tensor/Vector.h ////////////////////////////////

#define TENSOR_THIS(classname)\
	using This = classname;\
	static constexpr bool isTensorFlag = true;

#define TENSOR_SET_INNER_LOCALDIM_LOCALRANK(Inner_, localDim_, localRank_)\
	using Inner = Inner_;\
	static constexpr int localDim = localDim_;\
	static constexpr int localRank = localRank_;

#define TENSOR_TEMPLATE_T(classname)\
\
	template<typename Inner2>\
	using Template = classname<Inner2>;\
\
	template<typename NewInner>\
	using ReplaceInner = Template<NewInner>;\
\
	template<int newLocalDim>\
	using ReplaceLocalDim = Template<Inner>;

#define TENSOR_TEMPLATE_T_I(classname)\
\
	template<typename Inner2, int localDim2>\
	using Template = classname<Inner2, localDim2>;\
\
	template<typename NewInner>\
	using ReplaceInner = Template<NewInner, localDim>;\
\
	template<int newLocalDim>\
	using ReplaceLocalDim = Template<Inner, newLocalDim>;

#define TENSOR_HEADER_VECTOR_SPECIFIC()\
	static constexpr int localCount = localDim;

// TODO this needs tuple and integer_sequence
#define TENSOR_HEADER()\
\
	static_assert(localCount > 0);\
\
	/*struct NestedPtrTupleImpl {\
		static constexpr auto value() {\
			if constexpr (is_tensor_v<Inner>) {\
				return std::tuple_cat(\
					std::tuple<This*>(),\
					Inner::NestedPtrTupleImpl::value()\
				);\
			} else {\
				*//* while I am at the base of the chain, grab Scalar*//*\
				return std::tuple<This*, Inner*>();\
			}\
		}\
		using type = decltype(value());\
	};\
	using NestedPtrTuple = typename NestedPtrTupleImpl::type;*/\
\
	TENSOR_ADD_SCALAR_IMPL()\
\
	/*using intN = vec<int,rank>;*//*this needs vec to have arbitrary rank ... which needs ... */\
\
	/* TODO arbitrary-dimension ... dim<index> = seq_get_v<index>(dimseq) ... needs integer_sequence to store dimensions */\
	template<int dimIndex>\
	static constexpr int dim = localDim;\
\
	/* TODO: rank = length of dimseq*/\
	TENSOR_ADD_RANK_IMPL()\
\
	/* TODO numNestings = length of tensor tuple ptr */\
	TENSOR_ADD_NUMNESTINGS_IMPL()\
\
	template<typename NewScalar>\
	struct ReplaceScalarImpl {\
		static constexpr auto value() {\
			if constexpr (is_tensor_v<Inner>) {\
				return (ReplaceInner<\
					typename Inner::template ReplaceScalarImpl<NewScalar>::type\
				>*)nullptr;\
			} else {\
				return (ReplaceInner<NewScalar>*)nullptr;\
			}\
		}\
		using type = typename std::remove_pointer_t<decltype(value())>;\
	};\
	template<typename NewScalar>\
	/* TODO need tuples for this */\
	/*using ReplaceScalar = tensorScalarTuple<NewScalar, StorageTuple>;*/\
	using ReplaceScalar = typename ReplaceScalarImpl<NewScalar>::type;

#define TENSOR_HEADER_VECTOR(classname, Inner_, localDim_)\
	TENSOR_THIS(classname)\
	TENSOR_SET_INNER_LOCALDIM_LOCALRANK(Inner_, localDim_, 1)\
	TENSOR_TEMPLATE_T_I(classname)\
	TENSOR_HEADER_VECTOR_SPECIFIC()\
	TENSOR_HEADER()

#define TENSOR_ADD_SCALAR_IMPL()\
	/* TODO instead just count # of tuples in the nested args */\
	/* but ... I need tuples for that ... */\
	struct ScalarImpl {\
		static constexpr auto value() {\
			if constexpr (is_tensor_v<Inner>) {\
				return Inner::ScalarImpl::value();\
			} else {\
				return (Inner*){};\
			}\
		}\
		using type = decltype(value());\
	};\
	using Scalar = typename std::remove_pointer_t<typename ScalarImpl::type>;

#define TENSOR_ADD_RANK_IMPL()\
	struct RankImpl {\
		static constexpr int value() {\
			if constexpr (is_tensor_v<Inner>) {\
				return Inner::RankImpl::value() + localRank;\
			} else {\
				return localRank;\
			}\
		}\
	};\
	static constexpr int rank = RankImpl::value();

#define TENSOR_ADD_NUMNESTINGS_IMPL()\
	struct NumNestingsImpl {\
		static constexpr int value() {\
			if constexpr (is_tensor_v<Inner>) {\
				return Inner::NumNestingsImpl::value() + 1;\
			} else {\
				return 1;\
			}\
		}\
	};\
	static constexpr int numNestings = NumNestingsImpl::value();

#define TENSOR_ADD_CTORS(classname)\
\
	/*default constructor*/\
	constexpr classname()\
	: s{} {}\
\
	/*scalar*/\
	constexpr classname(Scalar const & s_)\
	: s{} {\
		for (int i = 0; i < localCount; ++i) {\
			s[i] = s_;\
		}\
	}\
\
	/*generic tensor/tensor*/\
	template<typename U>\
	constexpr classname(\
		U const & u,\
		std::enable_if_t<U::rank == rank>* = {}\
	) : s{} {\
		for (int i = 0; i < localCount; ++i) {\
			s[i] = u.s[i];\
		}\
	}\
\
	/*generic tensor/tensor move*/\
	template<typename U>\
	constexpr classname(\
		U && u,\
		std::enable_if_t<U::rank == rank>* = {}\
	) : s{} {\
		for (int i = 0; i < localCount; ++i) {\
			s[i] = u.s[i];\
		}\
	}\
/*\
#if 0\
	// TODO needs Common stuff, tuples, functions, apply, write-iterator\
	template<typename Lambda>\
	constexpr classname(\
		Lambda lambda,\
		std::enable_if_t<\
			std::is_same_v<\
				Common::FunctionFromLambda<Lambda>,\
				Common::FunctionFromTupleArgs<Scalar, Common::tuple_rep_t<int, rank>>\
			>\
		>* = {}\
	) {\
		using Func = typename Common::FunctionFromLambda<Lambda>::FuncType;\
		Func f(lambda);\
		auto w = write();\
		for (auto i = w.begin(); i != w.end(); ++i) {\
			*i = std::apply(f, i.readIndex.s);\
		}\
	}\
#elif 0\
// until then I can just use fixed-signature per-rank\
// but I'll still need is_callable or FunctionFromLambda ...\
	template<\
		typename Lambda\
	>\
	constexpr classname(\
		Lambda f,\
		std::enable_if_t<\
			rank == 1\
			//&& is_callable<Lambda>	//TODO implement this\
		>* = {}\
	) : x(f(0)), y(f(1)), z(f(2)) {}\
#endif\
*/\
\
	/*argument constructor*/\
	constexpr classname(\
		Inner const & x_,\
		Inner const & y_,\
		Inner const & z_\
	) : s{x_, y_, z_} {}\
\
	/*argument constructor*/\
	constexpr classname(\
		Inner const & xx_,\
		Inner const & xy_,\
		Inner const & xz_,\
		Inner const & yy_,\
		Inner const & yz_,\
		Inner const & zz_\
	) :	s{xx_, xy_, xz_, yy_, yz_, zz_} {}

#define TENSOR_ADD_VECTOR_OP_EQ(op)\
	constexpr This & operator op(This const & b) {\
		for (int i = 0; i < localCount; ++i) {\
			s[i] op b.s[i];\
		}\
		return *this;\
	}

#define TENSOR_ADD_SCALAR_OP_EQ(op)\
	constexpr This & operator op(Scalar const & b) {\
		for (int i = 0; i < localCount; ++i) {\
			s[i] op b;\
		}\
		return *this;\
	}

#define TENSOR_ADD_UNARY(op)\
	constexpr This operator op() const {\
		This result;\
		for (int i = 0; i < localCount; ++i) {\
			result.s[i] = op s[i];\
		}\
		return result;\
	}

#define TENSOR_ADD_CMP_OP()\
	constexpr bool operator==(This const & b) const {\
		for (int i = 0; i < localCount; ++i) {\
			if (s[i] != b.s[i]) return false;\
		}\
		return true;\
	}\
	constexpr bool operator!=(This const & b) const {\
		return !operator==(b);\
	}

#define TENSOR_ADD_MATH_MEMBER_FUNCS()\
	template<\
		typename B\
	>\
	constexpr auto dot(\
		B const & b,\
		std::enable_if_t<IsBinaryTensorOp<This,B>>* = {}\
	) const {\
		return ::dot(*this, b);\
	}\
\
	constexpr auto lenSq() const {\
		return ::lenSq(*this);\
	}\
\
	constexpr auto length() const {\
		return ::length(*this);\
	}\
\
	template<\
		typename B\
	>\
	constexpr auto distance(\
		B const & b,\
		std::enable_if_t<IsBinaryTensorOp<This,B>>* = {}\
	) const {\
		return ::distance(*this, b);\
	}\
\
	constexpr auto normalize() const {\
		return ::normalize(*this);\
	}\
\
	auto outer() const {\
		return ::outer<This>(*this);\
	}\
\
	template<typename B>\
	auto outer(\
		B const & b,\
		std::enable_if_t<IsBinaryTensorOp<This,B>>* = {}\
	) const {\
		return ::outer<This,B>(*this, b);\
	}\
\
	template<int m=0, int n=1>\
	auto trace() const {\
		return ::trace<m,n,This>(*this);\
	}\
\
	auto determinant() const {\
		return ::determinant(*this);\
	}\
\
	auto inverse() const {\
		return ::inverse(*this);\
	}\
\
	template<typename Det>\
	auto inverse(Det det) const {\
		return ::inverse(*this, det);\
	}\
\
	/* the following are 3D specific: */\
\
	template<typename B>\
	auto cross(\
		B const & b,\
		std::enable_if_t<IsBinaryTensorR3xR3Op<This,B>>* = {}\
	) const {\
		return ::cross(*this, b);\
	}\
\
	/* TODO make global scope methods for these? */\
	/* they are all vec3-specific */\
	/* TODO TODO these implementations are all vec3-specific */\
	/* ALSO do implementations for real3s3, real3x3, and real3x3s3 */\
	/* so maybe I should make them globals after all? */\
	/* for swapping dimensions between x and 012 */\
\
	constexpr auto swap(int side) const {\
		return ::swap(*this, side);\
	}\
\
	/* rotate from a particular side xyz to put x forward */\
	/* all assumed to be 3D rotations */\
	/* used for cartesian 3D grids */\
\
	template<int side>\
	constexpr auto rotateFromSide() const {\
		return ::rotateFromSide<side, This>(*this);\
	}\
\
	/* rotate to put x back to the side */\
\
	template<int side>\
	constexpr auto rotateToSide() const {\
		return ::rotateToSide<side, This>(*this);\
	}\
\
	/*rotate 'n' to x-axis*/\
	/*assumes 'n' is unit*/\
	/* dim = dimension of the rotate operation*/\
\
	template<int dim, typename N>\
	constexpr auto rotateFromInDim(\
		N const & n,\
		std::enable_if_t<is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}\
	) const {\
		return ::rotateFromInDim<dim, This, N>(*this);\
	}\
\
	/*rotate x-axis to 'n'*/\
\
	template<int dim, typename N>\
	constexpr auto rotateToInDim(\
		N const & n,\
		std::enable_if_t<is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}\
	) const {\
		return ::rotateToInDim<dim, This, N>(*this);\
	}\
\
/* "error: parameter may not be qualified with an address space" ... ?????\
	auto rotateX(Scalar const theta) const {\
		Scalar cosTheta = cos(theta);\
		Scalar sinTheta = sin(theta);\
		vec v = *this;\
		Scalar vy = v.y;\
		Scalar vz = v.z;\
		v.y = vy * cosTheta - vz * sinTheta;\
		v.z = vy * sinTheta + vz * cosTheta;\
		return v;\
	}\
\
	auto rotateY(Scalar const theta) const {\
		Scalar cosTheta = cos(theta);\
		Scalar sinTheta = sin(theta);\
		vec v = *this;\
		Scalar vx = v.x;\
		Scalar vz = v.z;\
		v.x = vx * cosTheta + vz * sinTheta;\
		v.z = -vx * sinTheta + vz * cosTheta;\
		return v;\
	}\
\
	auto rotateZ(Scalar const theta) const {\
		Scalar cosTheta = cos(theta);\
		Scalar sinTheta = sin(theta);\
		vec v = *this;\
		Scalar vx = v.x;\
		Scalar vy = v.y;\
		v.x = vx * cosTheta - vy * sinTheta;\
		v.y = vx * sinTheta + vy * cosTheta;\
		return v;\
	}\
*/

#define TENSOR_ADD_OPS(classname)\
	TENSOR_ADD_CTORS(classname)\
	TENSOR_ADD_VECTOR_OP_EQ(+=)\
	TENSOR_ADD_VECTOR_OP_EQ(-=)\
	TENSOR_ADD_VECTOR_OP_EQ(*=)\
	TENSOR_ADD_VECTOR_OP_EQ(/=)\
	TENSOR_ADD_SCALAR_OP_EQ(+=)\
	TENSOR_ADD_SCALAR_OP_EQ(-=)\
	TENSOR_ADD_SCALAR_OP_EQ(*=)\
	TENSOR_ADD_SCALAR_OP_EQ(/=)\
	TENSOR_ADD_UNARY(-)\
	TENSOR_ADD_CMP_OP()\
	TENSOR_ADD_MATH_MEMBER_FUNCS()

#define TENSOR_ADD_VECTOR_CALL_INDEX_PRIMARY()\
	constexpr decltype(auto) operator()(int i) { return s[i]; }\
	constexpr decltype(auto) operator()(int i) const { return s[i]; }\
	constexpr decltype(auto) operator()(int i) constant { return s[i]; }\
	constexpr decltype(auto) operator()(int i) constant const { return s[i]; }

#define TENSOR_ADD_BRACKET_FWD_TO_CALL()\
	constexpr decltype(auto) operator[](int i) { return s[i]; }\
	constexpr decltype(auto) operator[](int i) const { return s[i]; }\
	/* need these or else I get this error: */\
	/* `candidate function not viable: 'this' object is in address space '__constant', but method expects object in address space '__generic'` */\
	constexpr decltype(auto) operator[](int i) constant { return s[i]; }\
	constexpr decltype(auto) operator[](int i) constant const { return s[i]; }

#define TENSOR_ADD_RANK1_CALL_INDEX_AUX()\
\
	TENSOR_ADD_BRACKET_FWD_TO_CALL()\
\
	template<typename... Ints>\
	/*requires Common::is_all_v<int, Ints...>*/\
	constexpr decltype(auto) operator()(int i, Ints... k) { return (*this)(i)(k...); }\
	template<typename... Ints>\
	/*requires Common::is_all_v<int, Ints...>*/\
	constexpr decltype(auto) operator()(int i, Ints... k) const { return (*this)(i)(k...); }\
	template<typename... Ints>\
	/*requires Common::is_all_v<int, Ints...>*/\
	constexpr decltype(auto) operator()(int i, Ints... k) constant { return (*this)(i)(k...); }\
	template<typename... Ints>\
	/*requires Common::is_all_v<int, Ints...>*/\
	constexpr decltype(auto) operator()(int i, Ints... k) constant const { return (*this)(i)(k...); }

#define TENSOR_VECTOR_CLASS_OPS(classname)\
	TENSOR_ADD_OPS(classname)\
	TENSOR_ADD_VECTOR_CALL_INDEX_PRIMARY()\
	TENSOR_ADD_RANK1_CALL_INDEX_AUX()

template<typename Inner_, int localDim_>
union vec {
	TENSOR_HEADER_VECTOR(vec, Inner_, localDim_)
	Inner s[3] = {{}};
	TENSOR_VECTOR_CLASS_OPS(vec)
} <?=app.real=="half" and "__attribute__ ((packed))" or ""?>;

template<typename Inner_>
union vec<Inner_,2> {
	TENSOR_HEADER_VECTOR(vec, Inner_, 2)

	Inner s[localCount] = {{}};
	struct { Inner s0, s1, s2; };
	struct { Inner x, y, z; };
	
	TENSOR_VECTOR_CLASS_OPS(vec)

#if 0
	// 2-component swizzles
#define TENSOR_VEC2_ADD_SWIZZLE2_ij(i, j)\
	auto i ## j () { return vec<std::reference_wrapper<Inner>, 2>(i, j); }\
	auto i ## j () const { return vec<std::reference_wrapper<Inner const>, 2>(i, j); }
#define TENSOR_VEC2_ADD_SWIZZLE2_i(i)\
	TENSOR_VEC2_ADD_SWIZZLE2_ij(i,x)\
	TENSOR_VEC2_ADD_SWIZZLE2_ij(i,y)
#define TENSOR3_VEC2_ADD_SWIZZLE2()\
	TENSOR_VEC2_ADD_SWIZZLE2_i(x)\
	TENSOR_VEC2_ADD_SWIZZLE2_i(y)
	TENSOR3_VEC2_ADD_SWIZZLE2()
	
	// 3-component swizzles
#define TENSOR_VEC2_ADD_SWIZZLE3_ijk(i, j, k)\
	auto i ## j ## k() { return vec<std::reference_wrapper<Inner>, 3>(i, j, k); }\
	auto i ## j ## k() const { return vec<std::reference_wrapper<Inner const>, 3>(i, j, k); }
#define TENSOR_VEC2_ADD_SWIZZLE3_ij(i,j)\
	TENSOR_VEC2_ADD_SWIZZLE3_ijk(i,j,x)\
	TENSOR_VEC2_ADD_SWIZZLE3_ijk(i,j,y)
#define TENSOR_VEC2_ADD_SWIZZLE3_i(i)\
	TENSOR_VEC2_ADD_SWIZZLE3_ij(i,x)\
	TENSOR_VEC2_ADD_SWIZZLE3_ij(i,y)
#define TENSOR3_VEC2_ADD_SWIZZLE3()\
	TENSOR_VEC2_ADD_SWIZZLE3_i(x)\
	TENSOR_VEC2_ADD_SWIZZLE3_i(y)
	TENSOR3_VEC2_ADD_SWIZZLE3()

	// 4-component swizzles
#define TENSOR_VEC2_ADD_SWIZZLE4_ijkl(i, j, k, l)\
	auto i ## j ## k ## l() { return vec<std::reference_wrapper<Inner>, 4>(i, j, k, l); }\
	auto i ## j ## k ## l() const { return vec<std::reference_wrapper<Inner const>, 4>(i, j, k, l); }
#define TENSOR_VEC2_ADD_SWIZZLE4_ijk(i,j,k)\
	TENSOR_VEC2_ADD_SWIZZLE4_ijkl(i,j,k,x)\
	TENSOR_VEC2_ADD_SWIZZLE4_ijkl(i,j,k,y)
#define TENSOR_VEC2_ADD_SWIZZLE4_ij(i,j)\
	TENSOR_VEC2_ADD_SWIZZLE4_ijk(i,j,x)\
	TENSOR_VEC2_ADD_SWIZZLE4_ijk(i,j,y)
#define TENSOR_VEC2_ADD_SWIZZLE4_i(i)\
	TENSOR_VEC2_ADD_SWIZZLE4_ij(i,x)\
	TENSOR_VEC2_ADD_SWIZZLE4_ij(i,y)
#define TENSOR3_VEC2_ADD_SWIZZLE4()\
	TENSOR_VEC2_ADD_SWIZZLE4_i(x)\
	TENSOR_VEC2_ADD_SWIZZLE4_i(y)
	TENSOR3_VEC2_ADD_SWIZZLE4()
#endif
} <?=app.real=="half" and "__attribute__ ((packed))" or ""?>;

template<typename Inner_>
union vec<Inner_,3> {
	TENSOR_HEADER_VECTOR(vec, Inner_, 3)

	Inner s[localCount] = {{}};
	struct { Inner s0, s1, s2; };
	struct { Inner x, y, z; };
	
	TENSOR_VECTOR_CLASS_OPS(vec)

#if 0	//needs std::reference_wrapper
	// 2-component swizzles
#define TENSOR_VEC3_ADD_SWIZZLE2_ij(i, j)\
	auto i ## j () { return vec<std::reference_wrapper<Inner>, 2>(i, j); }\
	auto i ## j () const { return vec<std::reference_wrapper<Inner const>, 2>(i, j); }
#define TENSOR_VEC3_ADD_SWIZZLE2_i(i)\
	TENSOR_VEC3_ADD_SWIZZLE2_ij(i,x)\
	TENSOR_VEC3_ADD_SWIZZLE2_ij(i,y)\
	TENSOR_VEC3_ADD_SWIZZLE2_ij(i,z)
#define TENSOR3_VEC3_ADD_SWIZZLE2()\
	TENSOR_VEC3_ADD_SWIZZLE2_i(x)\
	TENSOR_VEC3_ADD_SWIZZLE2_i(y)\
	TENSOR_VEC3_ADD_SWIZZLE2_i(z)
	TENSOR3_VEC3_ADD_SWIZZLE2()
	
	// 3-component swizzles
#define TENSOR_VEC3_ADD_SWIZZLE3_ijk(i, j, k)\
	auto i ## j ## k() { return vec<std::reference_wrapper<Inner>, 3>(i, j, k); }\
	auto i ## j ## k() const { return vec<std::reference_wrapper<Inner const>, 3>(i, j, k); }
#define TENSOR_VEC3_ADD_SWIZZLE3_ij(i,j)\
	TENSOR_VEC3_ADD_SWIZZLE3_ijk(i,j,x)\
	TENSOR_VEC3_ADD_SWIZZLE3_ijk(i,j,y)\
	TENSOR_VEC3_ADD_SWIZZLE3_ijk(i,j,z)
#define TENSOR_VEC3_ADD_SWIZZLE3_i(i)\
	TENSOR_VEC3_ADD_SWIZZLE3_ij(i,x)\
	TENSOR_VEC3_ADD_SWIZZLE3_ij(i,y)\
	TENSOR_VEC3_ADD_SWIZZLE3_ij(i,z)
#define TENSOR3_VEC3_ADD_SWIZZLE3()\
	TENSOR_VEC3_ADD_SWIZZLE3_i(x)\
	TENSOR_VEC3_ADD_SWIZZLE3_i(y)\
	TENSOR_VEC3_ADD_SWIZZLE3_i(z)
	TENSOR3_VEC3_ADD_SWIZZLE3()

	// 4-component swizzles
#define TENSOR_VEC3_ADD_SWIZZLE4_ijkl(i, j, k, l)\
	auto i ## j ## k ## l() { return vec<std::reference_wrapper<Inner>, 4>(i, j, k, l); }\
	auto i ## j ## k ## l() const { return vec<std::reference_wrapper<Inner const>, 4>(i, j, k, l); }
#define TENSOR_VEC3_ADD_SWIZZLE4_ijk(i,j,k)\
	TENSOR_VEC3_ADD_SWIZZLE4_ijkl(i,j,k,x)\
	TENSOR_VEC3_ADD_SWIZZLE4_ijkl(i,j,k,y)\
	TENSOR_VEC3_ADD_SWIZZLE4_ijkl(i,j,k,z)
#define TENSOR_VEC3_ADD_SWIZZLE4_ij(i,j)\
	TENSOR_VEC3_ADD_SWIZZLE4_ijk(i,j,x)\
	TENSOR_VEC3_ADD_SWIZZLE4_ijk(i,j,y)\
	TENSOR_VEC3_ADD_SWIZZLE4_ijk(i,j,z)
#define TENSOR_VEC3_ADD_SWIZZLE4_i(i)\
	TENSOR_VEC3_ADD_SWIZZLE4_ij(i,x)\
	TENSOR_VEC3_ADD_SWIZZLE4_ij(i,y)\
	TENSOR_VEC3_ADD_SWIZZLE4_ij(i,z)
#define TENSOR3_VEC3_ADD_SWIZZLE4()\
	TENSOR_VEC3_ADD_SWIZZLE4_i(x)\
	TENSOR_VEC3_ADD_SWIZZLE4_i(y)\
	TENSOR_VEC3_ADD_SWIZZLE4_i(z)
	TENSOR3_VEC3_ADD_SWIZZLE4()
#endif

} <?=app.real=="half" and "__attribute__ ((packed))" or ""?>;

template<typename Inner_>
union vec<Inner_,4> {
	TENSOR_HEADER_VECTOR(vec, Inner_, 4)

	Inner s[localCount] = {{}};
	struct { Inner s0, s1, s2; };
	struct { Inner x, y, z; };
	
	TENSOR_VECTOR_CLASS_OPS(vec)

#if 0
	// 2-component swizzles
#define TENSOR_VEC4_ADD_SWIZZLE2_ij(i, j)\
	auto i ## j () { return vec<std::reference_wrapper<Inner>, 2>(i, j); }\
	auto i ## j () const { return vec<std::reference_wrapper<Inner const>, 2>(i, j); }
#define TENSOR_VEC4_ADD_SWIZZLE2_i(i)\
	TENSOR_VEC4_ADD_SWIZZLE2_ij(i,x)\
	TENSOR_VEC4_ADD_SWIZZLE2_ij(i,y)\
	TENSOR_VEC4_ADD_SWIZZLE2_ij(i,z)\
	TENSOR_VEC4_ADD_SWIZZLE2_ij(i,w)
#define TENSOR3_VEC4_ADD_SWIZZLE2()\
	TENSOR_VEC4_ADD_SWIZZLE2_i(x)\
	TENSOR_VEC4_ADD_SWIZZLE2_i(y)\
	TENSOR_VEC4_ADD_SWIZZLE2_i(z)\
	TENSOR_VEC4_ADD_SWIZZLE2_i(w)
	TENSOR3_VEC4_ADD_SWIZZLE2()
	
	// 3-component swizzles
#define TENSOR_VEC4_ADD_SWIZZLE3_ijk(i, j, k)\
	auto i ## j ## k() { return vec<std::reference_wrapper<Inner>, 3>(i, j, k); }\
	auto i ## j ## k() const { return vec<std::reference_wrapper<Inner const>, 3>(i, j, k); }
#define TENSOR_VEC4_ADD_SWIZZLE3_ij(i,j)\
	TENSOR_VEC4_ADD_SWIZZLE3_ijk(i,j,x)\
	TENSOR_VEC4_ADD_SWIZZLE3_ijk(i,j,y)\
	TENSOR_VEC4_ADD_SWIZZLE3_ijk(i,j,z)\
	TENSOR_VEC4_ADD_SWIZZLE3_ijk(i,j,w)
#define TENSOR_VEC4_ADD_SWIZZLE3_i(i)\
	TENSOR_VEC4_ADD_SWIZZLE3_ij(i,x)\
	TENSOR_VEC4_ADD_SWIZZLE3_ij(i,y)\
	TENSOR_VEC4_ADD_SWIZZLE3_ij(i,z)\
	TENSOR_VEC4_ADD_SWIZZLE3_ij(i,w)
#define TENSOR3_VEC4_ADD_SWIZZLE3()\
	TENSOR_VEC4_ADD_SWIZZLE3_i(x)\
	TENSOR_VEC4_ADD_SWIZZLE3_i(y)\
	TENSOR_VEC4_ADD_SWIZZLE3_i(z)\
	TENSOR_VEC4_ADD_SWIZZLE3_i(w)
	TENSOR3_VEC4_ADD_SWIZZLE3()

	// 4-component swizzles
#define TENSOR_VEC4_ADD_SWIZZLE4_ijkl(i, j, k, l)\
	auto i ## j ## k ## l() { return vec<std::reference_wrapper<Inner>, 4>(i, j, k, l); }\
	auto i ## j ## k ## l() const { return vec<std::reference_wrapper<Inner const>, 4>(i, j, k, l); }
#define TENSOR_VEC4_ADD_SWIZZLE4_ijk(i,j,k)\
	TENSOR_VEC4_ADD_SWIZZLE4_ijkl(i,j,k,x)\
	TENSOR_VEC4_ADD_SWIZZLE4_ijkl(i,j,k,y)\
	TENSOR_VEC4_ADD_SWIZZLE4_ijkl(i,j,k,z)\
	TENSOR_VEC4_ADD_SWIZZLE4_ijkl(i,j,k,w)
#define TENSOR_VEC4_ADD_SWIZZLE4_ij(i,j)\
	TENSOR_VEC4_ADD_SWIZZLE4_ijk(i,j,x)\
	TENSOR_VEC4_ADD_SWIZZLE4_ijk(i,j,y)\
	TENSOR_VEC4_ADD_SWIZZLE4_ijk(i,j,z)\
	TENSOR_VEC4_ADD_SWIZZLE4_ijk(i,j,w)
#define TENSOR_VEC4_ADD_SWIZZLE4_i(i)\
	TENSOR_VEC4_ADD_SWIZZLE4_ij(i,x)\
	TENSOR_VEC4_ADD_SWIZZLE4_ij(i,y)\
	TENSOR_VEC4_ADD_SWIZZLE4_ij(i,z)\
	TENSOR_VEC4_ADD_SWIZZLE4_ij(i,w)
#define TENSOR3_VEC4_ADD_SWIZZLE4()\
	TENSOR_VEC4_ADD_SWIZZLE4_i(x)\
	TENSOR_VEC4_ADD_SWIZZLE4_i(y)\
	TENSOR_VEC4_ADD_SWIZZLE4_i(z)\
	TENSOR_VEC4_ADD_SWIZZLE4_i(w)
	TENSOR3_VEC4_ADD_SWIZZLE4()
#endif
} <?=app.real=="half" and "__attribute__ ((packed))" or ""?>;

inline constexpr int triangleSize(int n) {
	return (n * (n + 1)) / 2;
}

inline constexpr int symIndex(int i, int j) {
	if (i > j) return symIndex(j,i);
	return i + triangleSize(j);
}

#define TENSOR_HEADER_SYMMETRIC_MATRIX_SPECIFIC()\
	static constexpr int localCount = triangleSize(localDim);

#define TENSOR_HEADER_SYMMETRIC_MATRIX(classname, Inner_, localDim_)\
	TENSOR_THIS(classname)\
	TENSOR_SET_INNER_LOCALDIM_LOCALRANK(Inner_, localDim_, 2)\
	TENSOR_TEMPLATE_T/*_I*/(classname)\
	TENSOR_HEADER_SYMMETRIC_MATRIX_SPECIFIC()\
	TENSOR_HEADER()
	
#define TENSOR_SYMMETRIC_MATRIX_LOCAL_READ_FOR_WRITE_INDEX()\
	/*static constexpr intNLocal getLocalReadForWriteIndex(int writeIndex) {\
		intNLocal iread;\
		int w = writeIndex+1;\
		for (int i = 1; w > 0; ++i) {\
			++iread(1);\
			w -= i;\
		}\
		--iread(1);\
		iread(0) = writeIndex - triangleSize(iread(1));\
		return iread;\
	}*/\
\
	static constexpr int getLocalWriteForReadIndex(int i, int j) {\
		return symIndex(i,j);\
	}

#define TENSOR_ADD_SYMMETRIC_MATRIX_CALL_INDEX()\
	constexpr decltype(auto) operator()(int i, int j) {\
		return s[getLocalWriteForReadIndex(i,j)];\
	}\
	constexpr decltype(auto) operator()(int i, int j) const {\
		return s[getLocalWriteForReadIndex(i,j)];\
	}\
	constexpr decltype(auto) operator()(int i, int j) constant {\
		return s[getLocalWriteForReadIndex(i,j)];\
	}\
	constexpr decltype(auto) operator()(int i, int j) constant const {\
		return s[getLocalWriteForReadIndex(i,j)];\
	}

#define TENSOR_SYMMETRIC_MATRIX_CLASS_OPS(classname)\
	TENSOR_SYMMETRIC_MATRIX_LOCAL_READ_FOR_WRITE_INDEX()\
	TENSOR_ADD_OPS(classname)\
	TENSOR_ADD_SYMMETRIC_MATRIX_CALL_INDEX()


template<typename Inner_>
union sym3 {
	TENSOR_HEADER_SYMMETRIC_MATRIX(sym3, Inner_, 3)

	using vec3 = ::vec3<Inner>;

	// TODO rename to x_x x_y etc
	struct {
		Inner xx, xy, xz, yy, yz, zz;
	};
	struct {
		Inner s00, s01, s02, s11, s12, s22;
	};
	Inner s[6];

	TENSOR_SYMMETRIC_MATRIX_CLASS_OPS(sym3)

	// TODO as refs?
	vec3 x() const { return vec3(xx, xy, xz); }
	vec3 y() const { return vec3(xy, yy, yz); }
	vec3 z() const { return vec3(xz, yz, zz); }
};



// TODO if I do use const& then I will have to use all possible kinds of OpenCL address qualifiers
// and when doing so, the compiler chokes on scalars ...
// so I'm just going to pass-by-value
// ... but maybe this is a masked error from enable_if and I can re-introduce it once I fix that ...

#define TENSOR_SCALAR_OP(op)\
template<\
	typename A,\
	typename B,\
	std::enable_if_t<is_tensor_v<A> && !is_tensor_v<B>, int> = 0\
>\
decltype(auto) operator op(\
	A const a,\
	B const b\
) {\
	using AS = typename A::Scalar;\
	using RS = decltype(AS() op B());\
	using R = typename A::template ReplaceScalar<RS>;\
	return R(a.x op b, a.y op b, a.z op b);\
}\
\
template<\
	typename A,\
	typename B,\
	std::enable_if_t<!is_tensor_v<A> && is_tensor_v<B>, int> = 0\
>\
decltype(auto) operator op(\
	A const a,\
	B const b\
) {\
	using BS = typename B::Scalar;\
	using RS = decltype(A() op BS());\
	using R = typename B::template ReplaceScalar<RS>;\
	return R(a op b.x, a op b.y, a op b.z);\
}

TENSOR_SCALAR_OP(+)
TENSOR_SCALAR_OP(-)
TENSOR_SCALAR_OP(*)
TENSOR_SCALAR_OP(/)

#define TENSOR_TENSOR_OP(op)\
template<\
	typename A,\
	typename B,\
	std::enable_if_t<\
		IsBinaryTensorOp<A,B>\
		/* && A::dims() == B::dims() TODO haven't got this yet*/\
	, int> = 0\
>\
decltype(auto) operator op(A const a, B const b) {\
	using RS = decltype(typename A::Scalar() op typename B::Scalar());\
	using R = typename A/*::template TensorSumResult<B> TODO */::template ReplaceScalar<RS>;\
	return R(a.x op b.x, a.y op b.y, a.z op b.z);\
}

TENSOR_TENSOR_OP(+)
TENSOR_TENSOR_OP(-)
//TENSOR_TENSOR_OP(*) handled elsewhere as inner product
TENSOR_TENSOR_OP(/)

// per-class implementation of operator*
template<typename T>
inline constexpr vec3<T> operator*(vec3<T> a, mat3x3<T> b) {
	return vec3<T>(
		a.x * b.x.x + a.y * b.y.x + a.z * b.z.x,
		a.x * b.x.y + a.y * b.y.y + a.z * b.z.y,
		a.x * b.x.z + a.y * b.y.z + a.z * b.z.z);
}

template<typename T>
inline constexpr vec3<T> operator*(mat3x3<T> a, vec3<T> b) {
	return vec3<T>(
		a.x.x * b.x + a.x.y * b.y + a.x.z * b.z,
		a.y.x * b.x + a.y.y * b.y + a.y.z * b.z,
		a.z.x * b.x + a.z.y * b.y + a.z.z * b.z);
}

//// MODULE_DEPENDS: real
using real3 = vec3<real>;
using real3x3 = mat3x3<real>;
using real3s3 = sym3<real>;

//////////////////////////////// Tensor/Math.h ////////////////////////////////

// default conj(x) = x
template<typename T>
decltype(auto) conj(T const t) { return t; }

#if 0	// needs iterator
template<
	typename A,
	typename B
>
constexpr auto dot(
	A const & a,
	B const & b,
	std::enable_if_t<IsBinaryTensorOp<A,B>>*
) {
	static_assert(false);
}
#else
// vector-vector
template<typename A, typename B>
constexpr auto dot(
	A const & a,
	B const & b,
	std::enable_if_t<
		is_tensor_v<A> && A::rank == 1 &&
		is_tensor_v<B> && B::rank == 1 &&
		A::template dim<0> == B::template dim<0>
	>*
) {
	using RS = decltype(typename A::Scalar() * typename B::Scalar());
	RS sum = {};
	for (int i = 0; i < A::template dim<0>; ++i) {
		sum += a(i) * conj(b(i));
	}
	return sum;
}

// sym3-sym3
template<typename A, typename B>
constexpr auto dot(
	A const & a,
	B const & b,
	std::enable_if_t<
		is_tensor_v<A> && A::rank == 2 &&
		is_tensor_v<B> && B::rank == 2 &&
		A::template dim<0> == B::template dim<0> &&
		A::template dim<1> == B::template dim<1>
	>*
) {
	using RS = decltype(typename A::Scalar() * typename B::Scalar());
	RS sum = {};
	for (int i = 0; i < A::template dim<0>; ++i) {
		for (int j = 0; j < A::template dim<1>; ++j) {
			sum += a(i,j) * conj(b(i,j));
		}
	}
	return sum;
}

constexpr real dot(real3x3 a, real3x3 b) {
	return 0.
<? for i,xi in ipairs(xNames) do
?>		<?
	for j,xj in ipairs(xNames) do
?> + a.<?=xi?>.<?=xj?> * conj(b.<?=xi?>.<?=xj?>)<?
	end ?>
<? end ?>;
}

static inline real dot(real3x3 a, real3s3 b) {
	return 0.
<? for i,xi in ipairs(xNames) do
?>		<?
	for j,xj in ipairs(xNames) do
?> + a.<?=xi?>.<?=xj?> * b.<?=sym(i,j)?><?
	end ?>
<? end ?>;
}
#endif

template<
	typename T
>
constexpr auto lenSq(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>*
) {
	return dot(v, v);
}

template<
	typename T
>
constexpr auto length(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>*
) {
	return (typename T::Scalar)sqrt(lenSq(v));
}

template<
	typename A,
	typename B
>
constexpr auto distance(
	A const & a,
	B const & b,
	std::enable_if_t<IsBinaryTensorOp<A,B>>*
) {
	return length(b - a);
}

template<
	typename T
>
constexpr T normalize(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>*
) {
	return v / length(v);
}

#if 0 // needs lambda ctor
template<
	typename A,
	typename B
>
constexpr auto outer(
	A const & a,
	B const & b,
	std::enable_if_t<IsBinaryTensorOp<A,B>>*
) {
	using RS = decltype(typename A::Scalar() * typename B::Scalar());
	using AB = typename A::template ReplaceScalar<typename B::template ReplaceScalar<RS>>;
	return AB([&](typename AB::intN i) -> RS {
		static_assert(decltype(i)::template dim<0> == A::rank + B::rank);
		return a(i.template subset<A::rank, 0>()) * b(i.template subset<B::rank, A::rank>());
	});
}
#else
//until then ... specific overrides
template<typename real>
constexpr auto outer(
	vec3<real> const & a,
	vec3<real> const & b
) {
	return vec3<vec3<real>>{
		{a.x * b.x, a.x * b.y, a.x * b.z},
		{a.y * b.x, a.y * b.y, a.y * b.z},
		{a.z * b.x, a.z * b.y, a.z * b.z},
	};
}

//self-outer
template<typename real>
constexpr auto outer(
	vec3<real> const & a
) {
	return sym3<real>{
		a.x * a.x,	//xx
		a.x * a.y,	//xy
		a.x * a.z,	//xz
		a.y * a.y,	//yy
		a.y * a.z,	//yz
		a.z * a.z	//zz
	};
}
#endif

#if 0
template<
	int m = 0,
	int n = 1,
	typename T
>
constexpr auto trace(
	T const & v,
	std::enable_if_t<
		is_tensor_v<T> &&
		m < T::rank &&
		n < T::rank &&
		T::template dim<m> == T::template dim<n>
	>* = {}
);
#else
template<
	int m,
	int n,
	typename real
>
constexpr auto trace(
	sym3<real> const & v
) {
	return v.xx + v.yy + v.zz;
}

template<
	int m,
	int n,
	typename real
>
constexpr auto trace(
	vec3<vec3<real>> const & v
) {
	return v.x.x + v.y.y + v.z.z;
}
#endif
// the following are 3D specific:

template<
	typename A,
	typename B
>
constexpr auto cross(
	A const & a,
	B const & b,
	std::enable_if_t<IsBinaryTensorR3xR3Op<A,B>>*
) {
	using RS = decltype(typename A::Scalar() * typename B::Scalar());
	using R = typename A::template ReplaceScalar<RS>;
	return R(
		a[1] * b[2] - a[2] * b[1],
		a[2] * b[0] - a[0] * b[2],
		a[0] * b[1] - a[1] * b[0]);
}

// TODO this is the vec3 impl
// for mat3 etc it might be different ...

template<
	typename T
>
constexpr auto swap(
	T const & v,
	int side,
	std::enable_if_t<is_tensor_v<T>>*
) {
	auto tmp = v.s[side];
	v.s[side] = v.x;
	v.x = tmp;
	return v;
}

template<
	int side,
	typename T
>
struct RotateFromSideImpl {};

template<
	typename T
>
struct RotateFromSideImpl<0, T> {
	static constexpr auto value(
		T const & v,
		std::enable_if_t<is_tensor_v<T>>*
	) {
		return v;
	}
};

template<
	typename T
>
struct RotateFromSideImpl<1, T> {
	static constexpr auto value(
		T const & v,
		std::enable_if_t<is_tensor_v<T>>*
	) {
		return T{v.y, -v.x, v.z};
	}
};

template<
	typename T
>
struct RotateFromSideImpl<2, T> {
	static constexpr auto value(
		T const & v,
		std::enable_if_t<is_tensor_v<T>>*
	) {
		return T{v.z, v.y, -v.x};
	}
};

template<
	int side,
	typename T
>
constexpr auto rotateFromSide(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>*
) {
	// to get around "error: function template partial specialization is not allowed"
	return RotateFromSideImpl<side, T>::value(v);
}

template<
	int side,
	typename T
>
struct RotateToSideImpl {};

template<
	typename T
>
struct RotateToSideImpl<0, T> {
	static constexpr auto value(
		T const & v,
		std::enable_if_t<is_tensor_v<T>>*
	) {
		return v;
	}
};

template<
	typename T
>
struct RotateToSideImpl<1, T> {
	static constexpr auto value(
		T const & v,
		std::enable_if_t<is_tensor_v<T>>*
	) {
		return T{-v.y, v.x, v.z};
	}
};

template<
	typename T
>
struct RotateToSideImpl<2, T> {
	static constexpr auto value(
		T const & v,
		std::enable_if_t<is_tensor_v<T>>*
	) {
		return T{-v.z, v.y, v.x};
	}
};

template<
	int side,
	typename T
>
constexpr auto rotateToSide(
	T const & v,
	std::enable_if_t<is_tensor_v<T>>*
) {
	// to get around "error: function template partial specialization is not allowed"
	return RotateToSideImpl<side, T>::value(v);
}

template<
	int dim,
	typename T,
	typename N
>
struct RotateFromInDimImpl {};

template<
	typename T,
	typename N
>
struct RotateFromInDimImpl<1, T, N> {
	static constexpr auto value(
		T const & v,
		N const & n,
		std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}
	) {
		return v;
	}
};

template<
	typename T,
	typename N
>
struct RotateFromInDimImpl<2, T, N> {
	static constexpr auto value(
		T const & v,
		N const & n,
		std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}
	) {
		return T(
			v.x * n.x + v.y * n.y,
			-v.x * n.y + v.y * n.x,
			v.z);
	}
};

//// MODULE_DEPENDS: quat
template<
	typename T,
	typename N
>
struct RotateFromInDimImpl<3, T, N> {
	static constexpr auto value(
		T const & v,
		N const & n,
		std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}
	) {
		using Scalar = typename T::Scalar;
		/*
		axis is n cross x-axis
		[ 1  0  0] x [nx ny nz] = [0, -nz, ny] / (ny^2 + nz^2)
		angle = acos(n.x)
		cos angle = n.x
		sin angle = sqrt(1 - nx^2)
		cos (angle/2) =

		cos^2 theta + sin^2 theta = 1
		sin^2 theta = 1 - cos^2
		cos^2 theta - sin^2 theta = cos(2 theta) <->
		cos(theta/2) = sqrt((1 + cos(theta))/2) <->
		2 sin theta cos theta = sin(2 theta)
		*/
		Scalar cosTheta = n.x;
		Scalar cosHalfTheta = sqrt(.5 * (1. + cosTheta));
		Scalar sinHalfTheta = sqrt(1. - cosHalfTheta * cosHalfTheta);
		Scalar n2 = sqrt(n.y * n.y + n.z * n.z);
		Scalar ax = 0.;
		Scalar ay = -n.z / n2;
		Scalar az = n.y / n2;
		// TODO template quat
		real4 q = real4{ax * sinHalfTheta, ay * sinHalfTheta, az * sinHalfTheta, cosHalfTheta};
		real4 qInv = quatUnitConj(q);
		real4 _v = real4{v.x, v.y, v.z, 0};
		real4 vres = quatMul(quatMul(q, _v), qInv);
		return T{vres.x, vres.y, vres.z};
	}
};

template<
	int dim,
	typename T,
	typename N
>
constexpr auto rotateFromInDim(
	T const & v,
	N const & n,
	std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>*
) {
	return RotateFromInDimImpl<dim, T, N>::value(v, n);
}

template<
	int side,
	typename T,
	typename N
>
struct RotateToInDimImpl {};

template<
	typename T,
	typename N
>
struct RotateToInDimImpl<1, T, N> {
	static constexpr auto value(
		T const & v,
		N const & n,
		std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}
	) {
		return v;
	}
};

template<
	typename T,
	typename N
>
struct RotateToInDimImpl<2, T, N> {
	static constexpr auto value(
		T const & v,
		N const & n,
		std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}
	) {
		return T{
			v.x * n.x - v.y * n.y,
			v.x * n.y + v.y * n.x,
			v.z};
	}
};

//// MODULE_DEPENDS: quat
template<
	typename T,
	typename N
>
struct RotateToInDimImpl<3, T, N> {
	static constexpr auto value(
		T const & v,
		N const & n,
		std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>* = {}
	) {
		using Scalar = typename T::Scalar;
		//same as above but with negative axis
		Scalar cosTheta = n.x;
		Scalar cosHalfTheta = sqrt(.5 * (1. + cosTheta));
		Scalar sinHalfTheta = sqrt(1. - cosHalfTheta * cosHalfTheta);
		Scalar n2 = sqrt(n.y * n.y + n.z * n.z);
		Scalar ax = 0.;
		Scalar ay = n.z / n2;
		Scalar az = -n.y / n2;
		real4 q = real4{ax * sinHalfTheta, ay * sinHalfTheta, az * sinHalfTheta, cosHalfTheta};
		real4 qInv = quatUnitConj(q);
		real4 _v = real4{v.x, v.y, v.z, 0};
		real4 vres = quatMul(quatMul(q, _v), qInv);
		return T{vres.x, vres.y, vres.z};
	}
};

template<
	int side,
	typename T,
	typename N
>
constexpr auto rotateToInDim(
	T const & v,
	N const & n,
	std::enable_if_t<is_tensor_v<T> && is_tensor_v<N> && N::rank == 1 && N::template dim<0> == 3>*
) {
	return RotateToInDimImpl<side, T, N>::value(v, n);
}

template<typename real>
static inline mat3x3<real> transpose(mat3x3<real> m) {
	return mat3x3<real>{
<? for i,xi in ipairs(xNames) do
?>		{<?
	for j,xj in ipairs(xNames) do
?>m.<?=xj?>.<?=xi?>, <?
	end ?>},
<? end
?>	};
}

template<typename real>
constexpr auto determinant(sym3<real> const & m) {
	return m.xx * (m.yy * m.zz - m.yz * m.yz)
		- m.xy * (m.xy * m.zz - m.xz * m.yz)
		+ m.xz * (m.xy * m.yz - m.yy * m.xz);
}

template<typename real>
constexpr auto inverse(sym3<real> const & m, real det) {
	real invDet = 1. / det;
	return real3s3{
		(m.yy * m.zz - m.yz * m.yz) * invDet,
		(m.xz * m.yz - m.xy * m.zz) * invDet,
		(m.xy * m.yz - m.xz * m.yy) * invDet,
		(m.xx * m.zz - m.xz * m.xz) * invDet,
		(m.xz * m.xy - m.xx * m.yz) * invDet,
		(m.xx * m.yy - m.xy * m.xy) * invDet,
	};
}

//useful for when you want to store the det/inv for evaluation only once,
// so pass-as-arg instead of macro
template<typename real>
constexpr auto inverse(sym3<real> const & m) {
	return inverse(m, determinant(m));
}

template<typename real>
constexpr auto determinant(vec3<vec3<real>> const & m) {
	return m.x.x * (m.y.y * m.z.z - m.y.z * m.z.y)
		- m.x.y * (m.y.x * m.z.z - m.y.z * m.z.x)
		+ m.x.z * (m.y.x * m.z.y - m.y.y * m.z.x);
}

template<typename real>
constexpr auto inverse(vec3<vec3<real>> const & m, real det) {
	real invDet = 1. / det;
	return real3x3{
<?
--n.x.x = (m.y.y * m.z.z - m.z.y * m.y.z) / det;
--n.x.y = (m.z.y * m.x.z - m.x.y * m.z.z) / det;
--n.x.z = (m.x.y * m.y.z - m.y.y * m.x.z) / det;
--...
for i=0,2 do
	local i1 = (i+1)%3;
	local i2 = (i+2)%3;
?>		{
<? 	for j=0,2 do
		local j1 = (j+1)%3;
		local j2 = (j+2)%3;
?>			(m.s<?=j1?>.s<?=i1?> * m.s<?=j2?>.s<?=i2?> - m.s<?=j2?>.s<?=i1?> * m.s<?=j1?>.s<?=i2?>) * invDet,
<? end
?>		},
<? end
?>	};
}

template<typename real>
constexpr auto inverse(vec3<vec3<real>> const & m) {
	return inverse(m, determinant(m));
}

//// END EXCLUDE FOR FFI_CDEF

//// MODULE_NAME: mat3x3
//// MODULE_DEPENDS: vec3

//// MODULE_NAME: realparam
//// MODULE_TYPE:
// used for passing parameters into real, distinct from real in the case that real=half which can't be passed as kernel arguments

typedef <?=app.realparam?> realparam;
typedef <?=app.realparam?>2 realparam2;
typedef <?=app.realparam?>4 realparam4;
typedef <?=app.realparam?>8 realparam8;

//// MODULE_NAME: units
//// MODULE_HEADER:

/*
unit conversion variables.
my current convention is this:
- initial conditions should provide variables to eqn pre-converted to unitless if they so desire.
- (therefore) state variables should be considered unitless.
- solver variables are not yet converted to unitless.  every time they are referenced, factor out the units.
- right now I'm dividing by units to convert to unitless, and multiplying by units to convert out.  This might be the inverse of what I should be doing.  The plus side is when inputting units to the conversion, you don't have to invert so often. 'meter = 6.3716' gives you 1 distance unit = 6.3716 meters.
*/

#define unit_m					solver.meter
#define unit_s					solver.second
#define unit_kg					solver.kilogram
#define unit_C					solver.coulomb
#define unit_K					solver.kelvin

#define unit_m2					(unit_m * unit_m)
#define unit_m3					(unit_m * unit_m * unit_m)
#define unit_s2					(unit_s * unit_s)
#define unit_C2					(unit_C * unit_C)
#define unit_m_per_s			(unit_m / unit_s)
#define unit_m2_per_s2			(unit_m2 / unit_s2)
#define unit_m3_per_kg_s2		(unit_m3 / (unit_kg * unit_s2))
#define unit_kg_per_m			(unit_kg / unit_m)
#define unit_kg_per_m3			(unit_kg / unit_m3)
#define unit_kg_per_m2_s		(unit_kg / (unit_m2 * unit_s))
#define unit_kg_per_m_s2		(unit_kg / (unit_m * unit_s2))
#define unit_C_per_kg			(unit_C / unit_kg)
#define unit_C_per_m2			(unit_C / unit_m2)
#define unit_kg_per_C_s			(unit_kg / (unit_C * unit_s))
#define unit_kg_m_per_C2		(unit_kg * unit_m / unit_C2)
#define unit_C2_s_per_kg_m3		((unit_C2 * unit_s) / (unit_kg * unit_m3))
#define unit_C2_s2_per_kg_m3	((unit_C2 * unit_s2) / (unit_kg * unit_m3))

//// MODULE_NAME: real

constexpr inline real lenSq(real const x) { return x * x; }

//// MODULE_NAME: real3
//// MODULE_DEPENDS: vec3
// legacy, now merged into vec3

//// MODULE_NAME: sym3
//// MODULE_DEPENDS: vec3
// legacy, now merged into vec3

//// MODULE_NAME: real3s3
//// MODULE_DEPENDS: vec3
//// MODULE_TYPE:

// This is exclusively for the luajit ffi.cdef, which cannot handle c++:
// But I'll expose it to the clcpp so I can static_assert its size
// TODO pick a suffix like cdef_t and use it for all the other cdef<->clcpp interchange POD structs, like initCond_t, prim_t, cons_t, etc
union real3s3_cdef_t {
	struct {
		real xx, xy, xz, yy, yz, zz;
	};
	struct {
		real s00, s01, s02, s11, s12, s22;
	};
	real s[6];
};

//// BEGIN INCLUDE FOR FFI_CDEF
typedef union real3s3_cdef_t real3s3;
//// END INCLUDE FOR FFI_CDEF

// This is exclusively for the clcpp files:
//// BEGIN EXCLUDE FOR FFI_CDEF
static_assert(sizeof(real3s3) == sizeof(real3s3_cdef_t));
//// END EXCLUDE FOR FFI_CDEF

//// MODULE_HEADER:

#define real3s3_ident	real3s3(1,0,0,1,0,1)

#if 0
static inline real real3_weightedDot(real3 a, real3 b, real3s3 m);
static inline real real3_weightedLenSq(real3 a, real3s3 m);
static inline real real3_weightedLen(real3 a, real3s3 m);

static inline real3s3 real3s3_rotateFrom(real3s3 const m, real3 const n);
static inline real3s3 real3s3_rotateTo(real3s3 const m, real3 const n);
static inline real3s3 real3s3_swap(real3s3 m, int side);
static inline real3s3 real3s3_swap0(real3s3 m);
static inline real3s3 real3s3_swap1(real3s3 m);
static inline real3s3 real3s3_swap2(real3s3 m);
#endif

//// MODULE_CODE:

#if 0

//weighted inner product using 'm'
static inline real real3_weightedDot(real3 a, real3 b, real3s3 m) {
	return dot(a, real3s3_real3_mul(m, b));
}

static inline real real3_weightedLenSq(real3 a, real3s3 m) {
	return real3_weightedDot(a, a, m);
}

static inline real real3_weightedLen(real3 a, real3s3 m) {
	return sqrt(real3_weightedLenSq(a, m));
}

static inline real3s3 real3s3_rotateFrom(
	real3s3 const m,
	real3 const n
) {
	real3x3 t = m;
	t.x = real3_rotateFrom(t.x, n);
	t.y = real3_rotateFrom(t.y, n);
	t.z = real3_rotateFrom(t.z, n);
	t = transpose(t);
	t.x = real3_rotateFrom(t.x, n);
	t.y = real3_rotateFrom(t.y, n);
	t.z = real3_rotateFrom(t.z, n);
	return real3s3(t);
}

static inline real3s3 real3s3_rotateTo(
	real3s3 const m,
	real3 const n
) {
	real3x3 t = m;
	t.x = real3_rotateTo(t.x, n);
	t.y = real3_rotateTo(t.y, n);
	t.z = real3_rotateTo(t.z, n);
	t = transpose(t);
	t.x = real3_rotateTo(t.x, n);
	t.y = real3_rotateTo(t.y, n);
	t.z = real3_rotateTo(t.z, n);
	return real3s3(t);
}

//for swapping dimensions between x and 012
static inline real3s3 real3s3_swap(real3s3 m, int side) {
	if (side == 0) {
		return m;
	} else if (side == 1) {
		return real3s3(m.yy, m.xy, m.yz, m.xx, m.xz, m.zz);
	} else if (side == 2) {
		return real3s3(m.zz, m.yz, m.xz, m.yy, m.xy, m.xx);
	}
	return real3s3(0./0.);
}

static inline real3s3 real3s3_swap0(real3s3 m) { return m; }
static inline real3s3 real3s3_swap1(real3s3 m) { return real3s3(m.yy, m.xy, m.yz, m.xx, m.xz, m.zz); }
static inline real3s3 real3s3_swap2(real3s3 m) { return real3s3(m.zz, m.yz, m.xz, m.yy, m.xy, m.xx); }

#endif

//// MODULE_NAME: real3x3
//// MODULE_DEPENDS: vec3
//// MODULE_HEADER:

// multiplication isn't template parent class based yet (TODO)
#if 0
static inline real3x3 real3x3_from_real3x3(real3x3 x);
static inline real3x3 real3s3_real3s3_mul(real3s3 a, real3s3 b);
static inline real3x3 real3x3_real3s3_mul(real3x3 a, real3s3 b);
static inline real3x3 real3s3_real3x3_mul(real3s3 a, real3x3 b);
static inline real3s3 real3x3_real3s3_to_real3s3_mul(real3x3 a, real3s3 b);

//c_ik = a_ij b_jk when you know c_ik is going to be symmetric
static inline real3s3 real3s3_real3x3_to_real3s3_mul(real3s3 a, real3x3 b);

//a_ij = .5 (b_ij + b_ji)
static inline real3s3 real3s3_from_real3x3(real3x3 a);

static inline real3x3 real3x3_from_real3s3(real3s3 a);

//c_ij = a_ij + b_ji
static inline real3x3 real3x3_addT(real3x3 a, real3x3 b);

static inline real3x3 real3x3_real3x3_mul(real3x3 a, real3x3 b);
static inline real3x3 real3x3_from_real(real x);
#endif

//// MODULE_CODE:

#if 0
static inline real3x3 real3x3_from_real3x3(real3x3 x) { return x; }

static inline real3x3 real3s3_real3s3_mul(real3s3 a, real3s3 b) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for j,xj in ipairs(xNames) do
?>			0.<?
		for k,xk in ipairs(xNames) do
?> + a.<?=sym(i,k)?> * b.<?=sym(k,j)?><?
		end ?>,
<?	end
?>		},
<? end
?>	};
}

static inline real3x3 real3x3_real3s3_mul(real3x3 a, real3s3 b) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for j,xj in ipairs(xNames) do
?>			0.<?
		for k,xk in ipairs(xNames) do
?> + a.<?=xi?>.<?=xk?> * b.<?=sym(k,j)?><?
		end ?>,
<?	end
?>		},
<? end
?>	};
}

static inline real3x3 real3s3_real3x3_mul(real3s3 a, real3x3 b) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for j,xj in ipairs(xNames) do
?>			0.<?
		for k,xk in ipairs(xNames) do
?> + a.<?=sym(i,k)?> * b.<?=xk?>.<?=xj?><?
		end ?>,
<?	end
?>		},
<? end
?>	};
}

static inline real3s3 real3x3_real3s3_to_real3s3_mul(real3x3 a, real3s3 b) {
	return real3s3{
<? for ij,xij in ipairs(symNames) do
	local i,j = from6to3x3(ij)
	local xi,xj = xNames[i],xNames[j]
?>		0.<?
		for k,xk in ipairs(xNames) do
?> + a.<?=xi?>.<?=xk?> * b.<?=sym(k,j)?><?
		end ?>,
<?	end
?>	};
}

static inline real3s3 real3s3_real3x3_to_real3s3_mul(real3s3 a, real3x3 b) {
	return real3s3{
<? for ij,xij in ipairs(symNames) do
	local i,j = from6to3x3(ij)
	local xi,xj = xNames[i],xNames[j]
?>		0.<?
	for k,xk in ipairs(xNames) do
?> + a.<?=sym(i,k)?> * b.<?=xk?>.<?=xj?><?
	end
?>,
<? end
?>	};
}

static inline real3s3 real3s3_from_real3x3(real3x3 a) {
	return real3s3{
<? for ij,xij in ipairs(symNames) do
	local i,j = from6to3x3(ij)
	local xi,xj = xNames[i],xNames[j]
?>		.5 * (a.<?=xi?>.<?=xj?> + a.<?=xj?>.<?=xi?>),
<? end
?>	};
}

static inline real3x3 real3x3_from_real3s3(real3s3 a) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for j,xj in ipairs(xNames) do
		local ij,xij = from3x3to6(i,j)
?>			a.<?=xij?>,
<?	end
?>		},
<? end
?>	};
}

static inline real3x3 real3x3_addT(real3x3 a, real3x3 b) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for j,xj in ipairs(xNames) do
?>			a.<?=xi?>.<?=xj?> + b.<?=xj?>.<?=xi?>,
<?	end
?>		},
<? end
?>	};
}

static inline real3x3 real3x3_real3x3_mul(real3x3 a, real3x3 b) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for j,xj in ipairs(xNames) do
?>			0.<?
		for k,xk in ipairs(xNames) do
?> + a.<?=xi?>.<?=xk?> * b.<?=xk?>.<?=xj?><?
		end ?>,
<? 	end
?>		},
<? end
?>	};
}

static inline real3x3 real3x3_from_real(real x) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		real3(<?
	for j,xj in ipairs(xNames) do
		if i~=j then ?>0.<? else ?>x<? end ?><?= j < 3 and ", " or ""?><?
	end ?>),
<? end
?>	};
}
#endif

//// MODULE_NAME: real3x3_rotate
//// MODULE_DEPENDS: real3x3 rotate
//// MODULE_HEADER:

#if 0
static inline real3x3 real3x3_rotateFrom(real3x3 const m, real3 const n);
static inline real3x3 real3x3_rotateTo(real3x3 const m, real3 const n);
static inline real3x3 real3x3_swap(real3x3 m, int side);
static inline real3x3 real3x3_swap0(real3x3 m);
static inline real3x3 real3x3_swap1(real3x3 m);
static inline real3x3 real3x3_swap2(real3x3 m);
#endif

//// MODULE_CODE:

#if 0
static inline real3x3 real3x3_rotateFrom(
	real3x3 t,
	real3 const n
) {
	t.x = real3_rotateFrom(t.x, n);
	t.y = real3_rotateFrom(t.y, n);
	t.z = real3_rotateFrom(t.z, n);
	t = transpose(t);
	t.x = real3_rotateFrom(t.x, n);
	t.y = real3_rotateFrom(t.y, n);
	t.z = real3_rotateFrom(t.z, n);
	return t;
}

static inline real3x3 real3x3_rotateTo(
	real3x3 t,
	real3 const n
) {
	t.x = real3_rotateTo(t.x, n);
	t.y = real3_rotateTo(t.y, n);
	t.z = real3_rotateTo(t.z, n);
	t = transpose(t);
	t.x = real3_rotateTo(t.x, n);
	t.y = real3_rotateTo(t.y, n);
	t.z = real3_rotateTo(t.z, n);
	return t;
}

//for swapping dimensions between x and 012
static inline real3x3 real3x3_swap0(real3x3 m) {
	return m;
}
static inline real3x3 real3x3_swap1(real3x3 m) {
	return real3x3{
		{m.y.y, m.y.x, m.y.z},
		{m.x.y, m.x.x, m.x.z},
		{m.z.y, m.z.x, m.z.z}
	};
}
static inline real3x3 real3x3_swap2(real3x3 m) {
	return real3x3{
		{m.z.z, m.z.y, m.z.x},
		{m.y.z, m.y.y, m.y.x},
		{m.x.z, m.x.y, m.x.x}
	};
}
static inline real3x3 real3x3_swap(real3x3 m, int side) {
	if (side == 0) {
		return real3x3_swap0(m);
	} else if (side == 1) {
		return real3x3_swap1(m);
	} else if (side == 2) {
		return real3x3_swap2(m);
	}
	return real3x3(0./0.);
}
#endif

//// MODULE_NAME: real3x3s3
//// MODULE_DEPENDS: real3s3 real3x3
//// MODULE_TYPE:

union real3x3s3_cdef_t {
	real s[18];
	real3s3 v[3];
	struct {
		real3s3 v0,v1,v2;	//why not s0,s1,s2?
	};
	struct {
		real3s3 x,y,z;
	};
};

//// BEGIN INCLUDE FOR FFI_CDEF
typedef union real3x3s3_cdef_t;
//// END INCLUDE FOR FFI_CDEF

//// BEGIN EXCLUDE FOR FFI_CDEF
using real3x3s3 = vec3<real3s3>;
static_assert(sizeof(real3x3s3) == sizeof(real3x3s3_cdef_t));
//// END EXCLUDE FOR FFI_CDEF

//c^i_jk = a^il b_ljk
//static inline real3x3s3 real3s3_real3x3s3_mul(real3s3 a, real3x3s3 b);

//c^i = a^i_jk b^jk
//static inline real3 real3x3s3_real3s3_dot23(real3x3s3 a, real3s3 b);

//c_i = a^jk b_jki
//static inline real3 real3s3_real3x3s3_dot12(real3s3 a, real3x3s3 b);

//c_ij = a_k b^k_ij
//static inline real3s3 real3_real3x3s3_dot1(real3 a, real3x3s3 b);

//c_i = a^j_ji
//static inline real3 real3x3s3_tr12(real3x3s3 a);

//c_ij = a^k b_ikj
//static inline real3x3 real3_real3x3s3_dot2(real3 a, real3x3s3 b);


//// MODULE_NAME: real3x3s3_rotate
//// MODULE_HEADER:

#if 0
static inline real3x3s3 real3x3s3_rotateFrom(real3x3s3 const m, real3 const n);
static inline real3x3s3 real3x3s3_rotateTo(real3x3s3 const m, real3 const n);
static inline real3x3s3 real3x3s3_swap(real3x3s3 m, int side);
#endif

//// MODULE_CODE:

#if 0
static inline real3x3s3 real3x3s3_rotateFrom(
	real3x3s3 const m,
	real3 const n
) {
	real3x3x3 t = real3x3x3_from_real3x3s3(m);
	real3 tmp;
<?	local is = require "ext.table"()
	for e=1,3 do
		for i,xi in ipairs(xNames) do
			is[e] = xi
			for j,xj in ipairs(xNames) do
				is[e%3+1] = xj
				for k,xk in ipairs(xNames) do
					is[(e+1)%3+1] = xk
?>	tmp.<?=xk?> = t.<?=is:concat"."?>;
<?				end
?>	tmp = real3_rotateFrom(tmp, n);
<?				for k,xk in ipairs(xNames) do
					is[(e+1)%3+1] = xk
?>	t.<?=is:concat"."?> = tmp.<?=xk?>;
<?				end
			end
		end
	end
?>	return real3x3s3_from_real3x3x3(t);
}

static inline real3x3s3 real3x3s3_rotateTo(
	real3x3s3 const m,
	real3 const n
) {
	real3x3x3 t = real3x3x3_from_real3x3s3(m);
	real3 tmp;
<?	local is = require "ext.table"()
	for e=1,3 do
		for i,xi in ipairs(xNames) do
			is[e] = xi
			for j,xj in ipairs(xNames) do
				is[e%3+1] = xj
				for k,xk in ipairs(xNames) do
					is[(e+1)%3+1] = xk
?>	tmp.<?=xk?> = t.<?=is:concat"."?>;
<?				end
?>	tmp = real3_rotateTo(tmp, n);
<?				for k,xk in ipairs(xNames) do
					is[(e+1)%3+1] = xk
?>	t.<?=is:concat"."?> = tmp.<?=xk?>;
<?				end
			end
		end
	end
?>	return real3x3s3_from_real3x3x3(t);
}

static inline real3x3s3 real3x3s3_swap(real3x3s3 m, int side) {
	return real3x3s3{
		real3s3_swap(m.s[side], side),
		real3s3_swap(m.s[side==1 ? 0 : 1], side),
		real3s3_swap(m.s[side==2 ? 0 : 2], side),
	};
}

<? for side=0,2 do ?>
static inline real3x3s3 real3x3s3_swap<?=side?>(real3x3s3 m) {
	return real3x3s3{
		real3s3_swap<?=side?>(m.s[<?=side?>]),
		real3s3_swap<?=side?>(m.s[<?=side==1 and 0 or 1?>]),
		real3s3_swap<?=side?>(m.s[<?=side==2 and 0 or 2?>]),
	};
}
<? end ?>
#endif

//// MODULE_NAME: real3x3x3
//// MODULE_DEPENDS: real3 real3s3 real3x3 real3x3s3
//// MODULE_TYPE:

union real3x3x3_cdef_t {
	real s[27];
	real3x3 v[3];
	struct {
		real3x3 v0,v1,v2;
	};
	struct {
		real3x3 x,y,z;
	};
};

//// BEGIN INCLUDE FOR FFI_CDEF
typedef union real3x3x3_cdef_t;
//// END INCLUDE FOR FFI_CDEF

//// BEGIN EXCLUDE FOR FFI_CDEF
using real3x3x3 = vec3<real3x3>;
static_assert(sizeof(real3x3x3) == sizeof(real3x3x3_cdef_t));
//// END EXCLUDE FOR FFI_CDEF


//// MODULE_HEADER:

//c_i = a_ijk b^jk
//static inline real3 real3x3x3_real3s3_dot23(real3x3x3 a, real3s3 b);

//c_ij = a^k_li b_jk^l
//static inline real3x3 real3x3s3_real3x3x3_dot12_23(real3x3s3 a, real3x3x3 b);

//c_ij = a^k_il b_kj^l
//assuming the result is symmetric
//static inline real3s3 real3x3s3_real3x3x3_dot13_to_real3s3(real3x3s3 a, real3x3x3 b);

//c_ij^k = a_ijl b^lk
//static inline real3x3x3 real3x3s3_real3s3_mul(real3x3s3 a, real3s3 b);

//b_i = a_ij^j
//static inline real3 real3x3x3_tr23(real3x3x3 a);

//c_i^jk = a^jm b_im^k
// assumes the result is symmetric on the 2nd and 3rd indexes
//static inline real3x3s3 real3s3_real3x3x3_mul2_toreal3x3s3(real3s3 a, real3x3x3 b);

// Γ^i_jk = d_kj^i + d_jk^i - d^i_jk
// assumes the dg variable has the derivative index first
// for d_kij = 1/2 γ_ij,k
//static inline real3x3s3 conn_ull_from_d_llu_d_ull(real3x3x3 const d_llu, real3x3s3 const d_ull);

//// MODULE_CODE:

#if 0
static inline real3 real3x3x3_tr23(real3x3x3 a) {
	return real3{
<? for i,xi in ipairs(xNames) do
?>		0.<?
	for j,xj in ipairs(xNames) do
?> + a.<?=xi?>.<?=xj?>.<?=xj?><?
	end
?>,
<? end
?>	};
}

static inline real3x3x3 real3x3x3_from_real3x3s3(real3x3s3 m) {
	return real3x3x3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for j,xj in ipairs(xNames) do
?>			{
<?		for k,xk in ipairs(xNames) do
?>				m.<?=xi?>.<?=sym(j,k)?>,
<?		end
?>			},
<?	end
?>		},
<? end
?>	};
}

static inline real3x3s3 real3x3s3_from_real3x3x3(real3x3x3 m) {
	return real3x3s3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for jk,xjk in ipairs(symNames) do
		local j,k,xj,xk = from6to3x3(jk)
?>			.5 * (m.<?=xi?>.<?=xj?>.<?=xk?> + m.<?=xi?>.<?=xk?>.<?=xj?>),
<?	end
?>		},
<? end
?>	};
}

static inline real3x3s3 conn_ull_from_d_llu_d_ull(real3x3x3 const d_llu, real3x3s3 const d_ull) {
	return real3x3s3{
<? for i,xi in ipairs(xNames) do
?>		{
<?	for jk,xjk in ipairs(symNames) do
		local j,k,xj,xk = from6to3x3(jk)
?>			d_llu.<?=xk?>.<?=xj?>.<?=xi?> + d_llu.<?=xj?>.<?=xk?>.<?=xi?> - d_ull.<?=xi?>.<?=xjk?>,
<?	end
?>		},
<? end
?>	};
}
#endif

//// MODULE_NAME: real3s3x3s3
//// MODULE_DEPENDS: real3s3
//// MODULE_TYPE:

union real3s3x3s3_cdef_t {
	real s[36];
	real3s3 v[6];
	struct {
		real3s3 v0, v1, v2, v3, v4, v5;
	};
	struct {
		real3s3 xx, xy, xz, yy, yz, zz;
	};
};

//// BEGIN INCLUDE FOR FFI_CDEF
typedef union real3s3x3s3_cdef_t;
//// END INCLUDE FOR FFI_CDEF

//// BEGIN EXCLUDE FOR FFI_CDEF
using real3s3x3s3 = sym3<real3s3>;
static_assert(sizeof(real3s3x3s3) == sizeof(real3s3x3s3_cdef_t));
//// END EXCLUDE FOR FFI_CDEF

//// MODULE_NAME: quat

//// MODULE_TYPE:
// has to be TYPE and not HEADER because vec3's TYPE depends on this:

static inline real4 quatUnitConj(real4 q);
static inline real4 quatMul(real4 q, real4 r);

//// MODULE_CODE:

//assumes q is unit
//returns the conjugate
static inline real4 quatUnitConj(real4 q) {
	return real4{-q.x, -q.y, -q.z, q.x};
}

static inline real4 quatMul(real4 q, real4 r) {
	real a = (q.w + q.x) * (r.w + r.x);
	real b = (q.z - q.y) * (r.y - r.z);
	real c = (q.x - q.w) * (r.y + r.z);
	real d = (q.y + q.z) * (r.x - r.w);
	real e = (q.x + q.z) * (r.x + r.y);
	real f = (q.x - q.z) * (r.x - r.y);
	real g = (q.w + q.y) * (r.w - r.z);
	real h = (q.w - q.y) * (r.w + r.z);

	return real4{
		 a - .5 * ( e + f + g + h), //x
		-c + .5 * ( e - f + g - h), //y
		-d + .5 * ( e - f - g + h), //z
		 b + .5 * (-e - f + g + h)}; //w
}


//// MODULE_NAME: cplx
//// MODULE_TYPE:

union cplx_cdef_t {
	real s[2];
	struct { real s0, s1; };
	struct { real re, im; };
};

//// BEGIN INCLUDE FOR FFI_CDEF
typedef union cplx cplx_cdef_t;
//// END INCLUDE FOR FFI_CDEF

//// BEGIN EXCLUDE FOR FFI_CDEF
using cplx = __complex__ real;
static_assert(sizeof(cplx) == sizeof(cplx_cdef_t));
//// END EXCLUDE FOR FFI_CDEF


//// MODULE_HEADER:

#if 0
#define real_from_cplx(x)	((x).re)

#define cplx_from_real(x)	cplx(x,0)
#define cplx_from_cplx(x)	(x)
#define cplx_1				cplx(1,0)
#define cplx_i	 			cplx(0,1)

static inline cplx cplx_conj(cplx a);
static inline cplx cplx_neg(cplx a);
static inline real lenSq(cplx a);
static inline real cplx_abs(cplx a);
static inline real cplx_arg(cplx a);
static inline cplx cplx_add(cplx a, cplx b);
static inline cplx cplx_sub(cplx a, cplx b);
static inline cplx cplx_mul(cplx a, cplx b);
static inline cplx cplx_real_mul(cplx a, real b);
#define real_cplx_mul(a,b)	cplx_real_mul(b,a)
static inline cplx cplx_inv(cplx a);
static inline cplx cplx_div(cplx a, cplx b);
static inline cplx cplx_exp(cplx a);
static inline cplx cplx_log(cplx a);
static inline cplx cplx_pow(cplx a, cplx b);
static inline cplx cplx_sqrt(cplx a);
#endif

//// MODULE_CODE:

#if 0
static inline cplx cplx_conj(cplx a) { return cplx(a.re, -a.im); }
static inline cplx cplx_neg(cplx a) { return cplx(-a.re, -a.im); }
static inline real lenSq(cplx a) { return a.re * a.re + a.im * a.im; }
static inline real cplx_abs(cplx a) { return sqrt(lenSq(a)); }
static inline real cplx_arg(cplx a) { return atan2(a.im, a.re); }

static inline cplx cplx_add(cplx a, cplx b) {
	return cplx(
		a.re + b.re,
		a.im + b.im
	);
}

static inline cplx cplx_sub(cplx a, cplx b) {
	return cplx(
		a.re - b.re,
		a.im - b.im
	);
}

static inline cplx cplx_mul(cplx a, cplx b) {
	return cplx(
		a.re * b.re - a.im * b.im,
		a.re * b.im + a.im * b.re);
}

static inline cplx cplx_real_add(cplx a, real b) {
	return cplx(a.re + b, a.im);
}

static inline cplx real_cplx_add(real a, cplx b) {
	return cplx(b.re + a, b.im);
}

static inline cplx cplx_real_mul(cplx a, real b) {
	return cplx(a.re * b, a.im * b);
}

static inline cplx cplx_inv(cplx a) {
	return cplx_conj(a) * (1. / lenSq(a));
}

static inline cplx cplx_div(cplx a, cplx b) {
	return a * cplx_inv(b);
}

static inline cplx cplx_exp(cplx a) {
	real expre = exp(a.re);
	return cplx(
		expre * cos(a.im),
		expre * sin(a.im)
	);
}

static inline cplx cplx_log(cplx a) {
	return cplx(
		log(cplx_abs(a)),
		cplx_arg(a)
	);
}

static inline cplx cplx_pow(cplx const a, cplx const b) {
	return cplx_exp(b * cplx_log(a));
}

static inline cplx cplx_sqrt(cplx const a) {
	return cplx_pow(a, cplx_from_real(.5));
}
#endif

//// MODULE_NAME: cplx3
//// MODULE_DEPENDS: cplx real3s3
//// MODULE_TYPE:

//// BEGIN EXCLUDE FOR FFI_CDEF
//// MODULE_DEPENDS: vec3
using cplx3 = vec3<cplx>;
//// END EXCLUDE FOR FFI_CDEF

//// MODULE_HEADER:

#if 0
#define real3_from_cplx3		cplx3_re

static inline cplx3 cplx3_from_real3(real3 const re);
static inline cplx3 cplx3_from_real3_real3(real3 const re, real3 const im);
static inline real3 cplx3_re(cplx3 const v);
static inline real3 cplx3_im(cplx3 const v);
static inline real lenSq(cplx3 const v);
static inline real length(cplx3 const v);
#if 0
static inline cplx3 real3_cplx_mul(real3 const a, cplx const b);
#endif

//TODO instead of real3s3 as a depends, put this into a cplx+real3s3 module?
static inline real cplx3_re_weightedDot(cplx3 const a, cplx3 const b, real3s3 const m);
static inline real cplx3_weightedLenSq(cplx3 const a, real3s3 const m);
#endif

//// MODULE_CODE:

#if 0
static inline cplx3 cplx3_from_real3(real3 const re) {
	return (cplx3){
<? for i,xi in ipairs(xNames) do
?>		.<?=xi?> = cplx_from_real(re.<?=xi?>),
<? end
?>	};
}

static inline cplx3 cplx3_from_real3_real3(real3 const re, real3 const im) {
	return (cplx3){
<? for i,xi in ipairs(xNames) do
?>		.<?=xi?> = cplx(re.<?=xi?>, im.<?=xi?>),
<? end
?>	};
}

static inline real3 cplx3_re(cplx3 const v) {
	return real3(v.x.re, v.y.re, v.z.re);
}

static inline real3 cplx3_im(cplx3 const v) {
	return real3(v.x.im, v.y.im, v.z.im);
}

static inline real lenSq(cplx3 const v) {
	return lenSq(v.x) + lenSq(v.y) + lenSq(v.z);
}

static inline real length(cplx3 const v) {
	return sqrt(lenSq(v));
}

#if 0
static inline cplx3 real3_cplx_mul(real3 const a, cplx const b) {
	return _cplx3(
		a.x * b,
		a.y * b,
		a.z * b);
}
#endif

/*
assumes the weights are real and only returns the real component ...
what to properly name this
a^i b^j* g_ij
= (re(a^i) re(b^j) + im(a^i) im(a^j)) g_ij
= re(a^i) re(b^j) g_ij + im(a^i) im(a^j) g_ij
*/
static inline real cplx3_re_weightedDot(cplx3 const a, cplx3 const b, real3s3 const m) {
	return real3_weightedDot(cplx3_re(a), cplx3_re(b), m)
		+ real3_weightedDot(cplx3_im(a), cplx3_im(b), m);
}

static inline real cplx3_weightedLenSq(cplx3 const a, real3s3 const m) {
	return real3_weightedLenSq(cplx3_re(a), m)
		+ real3_weightedLenSq(cplx3_im(a), m);
}
#endif

//// MODULE_NAME: cplx3x3
//// MODULE_DEPENDS: real3s3 real3x3 cplx3

//// MODULE_TYPE:

using cplx3x3 = mat3x3<cplx>;

//// MODULE_HEADER:

#if 0
static inline cplx3x3 cplx3x3_from_real3x3_real3x3(real3x3 const re, real3x3 const im);
static inline cplx3 cplx3x3_real3_mul(cplx3x3 const a, real3 const b);
static inline cplx3 cplx3_real3x3_mul(cplx3 const a, real3x3 const b);
static inline real3x3 cplx3x3_re(cplx3x3 const v);
static inline real3x3 cplx3x3_im(cplx3x3 const v);
#endif

//// MODULE_CODE:

#if 0
static inline cplx3x3 cplx3x3_from_real3x3_real3x3(
	real3x3 const re,
	real3x3 const im
) {
	return (cplx3x3) {
<? for i,xi in ipairs(xNames) do
?>		.<?=xi?> = cplx3_from_real3_real3(re.<?=xi?>, im.<?=xi?>),
<? end
?>	};
}

static inline real3x3 cplx3x3_re(cplx3x3 const v) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		cplx3_re(v.<?=xi?>),
<? end
?>	};
}

static inline real3x3 cplx3x3_im(cplx3x3 const v) {
	return real3x3{
<? for i,xi in ipairs(xNames) do
?>		cplx3_im(v.<?=xi?>),
<? end
?>	};
}
#endif

//// MODULE_NAME: Bessel

// Reference: From Numath Library By Tuan Dang Trong in Fortran 77.
// C++ Release 1.0 By J-P Moreau, Paris.
// (www.jpmoreau.fr)
static inline real BESSJ0(real const X) {
	/***********************************************************************
	This subroutine calculates the First Kind Bessel Function of
	order 0, for any real number X. The polynomial approximation by
	series of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1.
	REFERENCES:
	M.ABRAMOWITZ,I.A.STEGUN, HANDBOOK OF MATHEMATICAL FUNCTIONS, 1965.
	C.W.CLENSHAW, NATIONAL PHYSICAL LABORATORY MATHEMATICAL TABLES,
	VOL.5, 1962.
	************************************************************************/
	if (X==0.0) return 1.0;
	real const AX = fabs(X);
	if (AX < 8.0) {
		real const
			R1= 57568490574.0, R2=-13362590354.0, R3=651619640.7,
			R4=-11214424.18, R5= 77392.33017, R6=-184.9052456,
			S1= 57568490411.0, S2=1029532985.0, S3=9494680.718,
			S4= 59272.64853, S5=267.8532712, S6=1.0;
		real const Y = X*X;
		real const FR = R1+Y*(R2+Y*(R3+Y*(R4+Y*(R5+Y*R6))));
		real const FS = S1+Y*(S2+Y*(S3+Y*(S4+Y*(S5+Y*S6))));
		return FR/FS;
	} else {
		real const
			P1=1.0, P2=-0.1098628627E-2, P3=0.2734510407E-4,
			P4=-0.2073370639E-5, P5= 0.2093887211E-6,
			Q1=-0.1562499995E-1, Q2= 0.1430488765E-3, Q3=-0.6911147651E-5,
			Q4= 0.7621095161E-6, Q5=-0.9349451520E-7;
		real const Z = 8./AX;
		real const Y = Z*Z;
		real const XX = AX-0.785398164;
		real const FP = P1+Y*(P2+Y*(P3+Y*(P4+Y*P5)));
		real const FQ = Q1+Y*(Q2+Y*(Q3+Y*(Q4+Y*Q5)));
		return sqrt(0.636619772/AX)*(FP*cos(XX)-Z*FQ*sin(XX));
	}
}

static inline real Sign(real const X, real const Y) {
	if (Y<0.0) return (-fabs(X));
	else return (fabs(X));
}

// Reference: From Numath Library By Tuan Dang Trong in Fortran 77.
// C++ Release 1.0 By J-P Moreau, Paris.
// (www.jpmoreau.fr)
static inline real BESSJ1(real const X) {
	/**********************************************************************
	This subroutine calculates the First Kind Bessel Function of
	order 1, for any real number X. The polynomial approximation by
	series of Chebyshev polynomials is used for 0<X<8 and 0<8/X<1.
	REFERENCES:
	M.ABRAMOWITZ,I.A.STEGUN, HANDBOOK OF MATHEMATICAL FUNCTIONS, 1965.
	C.W.CLENSHAW, NATIONAL PHYSICAL LABORATORY MATHEMATICAL TABLES,
	VOL.5, 1962.
	***********************************************************************/
	real const
		P1=1.0, P2=0.183105E-2, P3=-0.3516396496E-4, P4=0.2457520174E-5,
		P5=-0.240337019E-6,  P6=0.636619772,
		Q1= 0.04687499995, Q2=-0.2002690873E-3, Q3=0.8449199096E-5,
		Q4=-0.88228987E-6, Q5= 0.105787412E-6,
		R1= 72362614232.0, R2=-7895059235.0, R3=242396853.1,
		R4=-2972611.439,   R5=15704.48260,  R6=-30.16036606,
		S1=144725228442.0, S2=2300535178.0, S3=18583304.74,
		S4=99447.43394,    S5=376.9991397,  S6=1.0;

	real const AX = fabs(X);
	if (AX < 8.0) {
		real const Y = X*X;
		real const FR = R1+Y*(R2+Y*(R3+Y*(R4+Y*(R5+Y*R6))));
		real const FS = S1+Y*(S2+Y*(S3+Y*(S4+Y*(S5+Y*S6))));
		return X*(FR/FS);
	} else {
		real const Z = 8.0/AX;
		real const Y = Z*Z;
		real const XX = AX-2.35619491;
		real const FP = P1+Y*(P2+Y*(P3+Y*(P4+Y*P5)));
		real const FQ = Q1+Y*(Q2+Y*(Q3+Y*(Q4+Y*Q5)));
		return sqrt(P6/AX)*(cos(XX)*FP-Z*sin(XX)*FQ)*Sign(S6,X);
	}
}

//// MODULE_NAME: getPerpendicularBasis

//TODO include metric weight
//TODO I'm using this for n^u and n_u
static inline void getPerpendicularBasis(
	real3 const n,
	real3 * const n2,
	real3 * const n3
) {
	real3 n_x_x = n.cross(real3(1,0,0));
	real3 n_x_y = n.cross(real3(0,1,0));
	real3 n_x_z = n.cross(real3(0,0,1));
	real n_x_xSq = lenSq(n_x_x);
	real n_x_ySq = lenSq(n_x_y);
	real n_x_zSq = lenSq(n_x_z);
	if (n_x_xSq > n_x_ySq) {
		if (n_x_xSq > n_x_zSq) {
			*n2 = n_x_x;	//use x
		} else {
			*n2 = n_x_z;	//use z
		}
	} else {
		if (n_x_ySq > n_x_zSq) {
			*n2 = n_x_y;	//use y
		} else {
			*n2 = n_x_z;	//use z
		}
	}
	*n2 = n2->normalize();
	*n3 = n.cross(*n2);
}

//// MODULE_NAME: getPerpendicularBasis3x3
//// MODULE_DEPENDS: getPerpendicularBasis real3x3

//based on n->x, calculate n->y and n->z
//same as above, but for the row vectors of a 3x3 matrix
//not used anymore I think
static inline void getPerpendicularBasis3x3(
	real3x3 const * const n
) {
	getPerpendicularBasis(n->x, &n->y, &n->z);
}

//// MODULE_NAME: normalBasisForSide
//// MODULE_DEPENDS: real3x3

static constexpr real3x3 normalBasisForSide0 = real3x3{{1,0,0}, {0,1,0}, {0,0,1}};
static constexpr real3x3 normalBasisForSide1 = real3x3{{0,1,0}, {0,0,1}, {1,0,0}};
static constexpr real3x3 normalBasisForSide2 = real3x3{{0,0,1}, {1,0,0}, {0,1,0}};

//// MODULE_NAME: normalForSide
//// MODULE_DEPENDS: real3

static constexpr real3 normalForSide0 = real3(1,0,0);
static constexpr real3 normalForSide1 = real3(0,1,0);
static constexpr real3 normalForSide2 = real3(0,0,1);

//// MODULE_NAME: sech

static inline real sech(real const x) {
	return 2. / (exp(x) + exp(-x));
}

//// MODULE_NAME: min3

static inline real min3(real const x, real const y, real const z) {
	real const tmp = min(x, y);	//in case min is a macro, store in a temp var
	return min(tmp, z);
}

//// MODULE_NAME: minmod

static inline real minmod(real const a, real const b) {
	if (a * b < 0) return 0;
	return fabs(a) < fabs(b) ? a : b;
}

//// MODULE_NAME: sqr

static inline real sqr(real const x) {
	return x * x;
}

//// MODULE_NAME: math
//// MODULE_DEPENDS: realparam units
/*
This is defined

TODO don't just use 'math',
put a global depends list somewhere, build on it as we add eqn and solver
but app has its own modules which it needs typecode for first (which other solvers use ffi instances of)
and solvers modules depend on those app modules...

and here don't put structs
cuz I don't want to ffi.cdef them twice
*/
