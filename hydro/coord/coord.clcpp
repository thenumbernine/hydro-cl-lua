namespace <?=Solver?> {

/*
mesh vertexes are provided in Cartesian coordinates
so their normals are as well
 so face->normal will be in Cartesian components

however their use with the cell vector components requires them to be converted to whatever coord.vectorComponents specifies
maybe I will just do that up front?  save a frame basis & dual (that is orthonormal to the basis)
though for now I'll just support Cartesian / identity metric
*/
struct MeshNormal {
	real3x3 n;

	MeshNormal(real3x3 n_) : n(n_) {}

<? if require "hydro.solver.meshsolver":isa(solver) then ?>
	// only MeshSolver uses Face ...
	static MeshNormal forFace(global Face const & face) {
		return MeshNormal(real3x3{
			face->normal,
			face->normal2,
			face->normal3,
		});
	}
<? end ?>

	constexpr real length() const {
		return 1.;
	}
	constexpr real lenSq() const {
		return 1.;
	}
<?
for j,xj in ipairs(xNames) do
	for i,xi in ipairs(xNames) do
?>
	constexpr real l<?=j?><?=xi?>() const {
		return n.<?=xj?>.<?=xi?>;
	}
	constexpr real u<?=j?><?=xi?>() const {
		return l<?=j?><?=xi?>();
	}
	constexpr real l<?=j?><?=xi?>_over_length() const {
		return l<?=j?><?=xi?>();
	}
	constexpr real u<?=j?><?=xi?>_over_length() const {
		return u<?=j?><?=xi?>();
	}
<?
	end
end
?>

	//v^i (nj)_i
	constexpr real3 vecDotNs(real3 v) const {
		return n * v;
	}

	//v^i (n1)_i
	constexpr real vecDotN1(real3 v) const {
		return dot(n.x, v);
	}

	// w_j <=> (n_j)^i w_i = v_j
	constexpr real3 vecFromNs(real3 v) const {
		return n * v;
	}

// BEGIN CODE FOR ALL NORMALS (inherit? crtp insert?)

<? for i=1,3 do ?>
	constexpr real3 l<?=i?>() const {
		return real3(
			l<?=i?>x(),
			l<?=i?>y(),
			l<?=i?>z());
	}

	constexpr real3 u<?=i?>() const {
		return real3(
			u<?=i?>x(),
			u<?=i?>y(),
			u<?=i?>z());
	}
<? end ?>

// END CODE FOR ALL NORMALS
};

struct AnholonomicNormal {
	int side;
	constexpr AnholonomicNormal(int side_) : side(side_) {}

	template<int side>
	static AnholonomicNormal forSide(real3 const x) {
		return AnholonomicNormal(side);
	}

	//|n|
	constexpr real length() const { return 1.; }
	constexpr real lenSq() const { return 1.; }

//(nj)_i, (nj)^i, (nj)_i/|nj|, (nj)^i/|nj|
<?
for j=1,3 do
	for i,xi in ipairs(xNames) do
?>
	constexpr real l<?=j?><?=xi?>() const {
		return side == <?=(i-j)%3?> ? 1. : 0.;
	}
	constexpr real u<?=j?><?=xi?>() const {
		return l<?=j?><?=xi?>();
	}
	constexpr real l<?=j?><?=xi?>_over_length() const {
		return l<?=j?><?=xi?>();
	}
	constexpr real u<?=j?><?=xi?>_over_length() const {
		return u<?=j?><?=xi?>();
	}
<?
	end
end
?>

	// this is the same as converting 'v' in global cartesian to 'v' in the basis of nj
	// v^i (nj)_i for side j
	constexpr real3 vecDotNs(real3 v) const {
		return real3(
			v[side],
			v[(side+1)%3],
			v[(side+2)%3]);
	}

	//v^i (n1)_i
	constexpr real vecDotN1(real3 v) const {
		return v[side];
	}

	// ...and this is the same as converting v in the basis of nj to v in global cartesian
	// v.x * e[side] + v.y * e[side+1] + v.z * e[side+2]
	constexpr real3 vecFromNs(real3 v) const {
		return real3(
			v[(3-side)%3],
			v[(3-side+1)%3],
			v[(3-side+2)%3]);
	}

// BEGIN CODE FOR ALL NORMALS (inherit? crtp insert?)

<? for i=1,3 do ?>
	constexpr real3 l<?=i?>() const {
		return real3(
			l<?=i?>x(),
			l<?=i?>y(),
			l<?=i?>z());
	}

	constexpr real3 u<?=i?>() const {
		return real3(
			u<?=i?>x(),
			u<?=i?>y(),
			u<?=i?>z());
	}
<? end ?>

// END CODE FOR ALL NORMALS
};

struct CartesianNormal {
	real3x3 n;
	real l;
	constexpr CartesianNormal(real3x3 n_, real lenval_) : n(n_), l(lenval_) {}

	template<int side>
	static CartesianNormal forSide(real3 const pt) {
		return CartesianNormal(
			real3x3{
				coord_basisHolUnits<side>(pt),
				coord_basisHolUnits<(side+1)%3>(pt),
				coord_basisHolUnits<(side+2)%3>(pt),
			},
			1.
		);
	};

	//|n1|
	constexpr real length() const {
		return l;
	}

	constexpr real lenSq() {
		return l * l;
	}

//(nj)_i, (nj)^i, (nj)_i / |nj|, (nj)^i / |nj|
<?
for j,xj in ipairs(xNames) do
	for i,xi in ipairs(xNames) do
?>
	constexpr real l<?=j?><?=xi?>() const {
		return n.<?=xj?>.<?=xi?>;
	}

	constexpr real u<?=j?><?=xi?>() const {
		return l<?=j?><?=xi?>();
	}

	constexpr real l<?=j?><?=xi?>_over_length() const {
		return l<?=j?><?=xi?>() / l;
	}

	constexpr real u<?=j?><?=xi?>_over_length() const {
		return l<?=j?><?=xi?>_over_length();
	}
<?
	end
end
?>

	//v^i (nj)_i for side j
	constexpr real3 vecDotNs(real3 v) const {
		return n * v;
	}

	//v^i (n1)_i
	constexpr real vecDotN1(real3 v) const {
		return dot(n.x, v);
	}


	// ...and this is the same as converting v in the basis of nj to v in global cartesian
	// v.x * e[side] + v.y * e[side+1] + v.z * e[side+2]
	constexpr real3 vecFromNs(real3 v) const {
		return v * n;
	}

// BEGIN CODE FOR ALL NORMALS (inherit? crtp insert?)

<? for i=1,3 do ?>
	constexpr real3 l<?=i?>() const {
		return real3(
			l<?=i?>x(),
			l<?=i?>y(),
			l<?=i?>z());
	}

	constexpr real3 u<?=i?>() const {
		return real3(
			u<?=i?>x(),
			u<?=i?>y(),
			u<?=i?>z());
	}
<? end ?>

// END CODE FOR ALL NORMALS
};

struct HolonomicNormal {
	int side;
	real3x3 U;
	real l;

	HolonomicNormal(int side_, real3x3 U_, real l_) : side(side_), U(U_), l(l_) {}

	template<int side>
	constexpr static HolonomicNormal forSide(real3 pt);

	//|n1|
	constexpr real length() const {
		return l;
	}

	constexpr real lenSq() const {
		return l * l;
	}

	//(nj)_i, (nj_i / |nj|
<?
for j=1,3 do
	for i,xi in ipairs(xNames) do
?>
	constexpr real l<?=j?><?=xi?>() const {
		return side == <?=(i-j)%3?> ? 1. : 0.;
	}

	constexpr real l<?=j?><?=xi?>_over_length() {
		return side == <?=(i-j)%3?> ? (1./l) : 0.;
	}
<?
	end
end
?>

	//(nj)^i, (nj)^i / |nj|
<?
for j,xj in ipairs(xNames) do
	for i,xi in ipairs(xNames) do
?>
	constexpr real u<?=j?><?=xi?>() const {
		return U.<?=xj?>.<?=xi?>;
	}

	constexpr real u<?=j?><?=xi?>_over_length() const {
		return u<?=j?><?=xi?>() / l;
	}

<?
	end
end
?>

	//v^i (nj)_i for side j
	constexpr real3 vecDotNs(real3 v) const {
		return real3(
			v[side],
			v[(side+1)%3],
			v[(side+2)%3]);
	}

	//v^i (n1)_i
	constexpr real vecDotN1(real3 v) const {
		return v[side];
	}

	// ...and this is the same as converting v in the basis of nj to v in global cartesian
	// v.x * e[side] + v.y * e[side+1] + v.z * e[side+2]
	constexpr real3 vecFromNs(real3 v) const {
		return real3(
			v[(3-side)%3],
			v[(3-side+1)%3],
			v[(3-side+2)%3]);
	}

// BEGIN CODE FOR ALL NORMALS (inherit? crtp insert?)

<? for i=1,3 do ?>
	constexpr real3 l<?=i?>() const {
		return real3(
			l<?=i?>x(),
			l<?=i?>y(),
			l<?=i?>z());
	}

	constexpr real3 u<?=i?>() const {
		return real3(
			u<?=i?>x(),
			u<?=i?>y(),
			u<?=i?>z());
	}
<? end ?>

// END CODE FOR ALL NORMALS
};

<? for side=0,2 do ?>
template<>
HolonomicNormal HolonomicNormal::forSide<<?=side?>>(real3 pt) {
	return HolonomicNormal(
		<?=side?>,
		real3x3{
<?
for j=0,2 do
?>			{
<?	for i=0,2 do
		local k = (side + j) % 3
		local m, n = k, i
		if m > n then m, n = n, m end
?>				coord_g_uu<?=m..n?>(pt)<?=i+3*j < 8 and ',' or ''?>
<?
	end
?>			},
<?
end
?>		},
		coord_sqrt_g_uu<?=side..side?>(pt)
	);
}
<? end ?>

}	//namespace <?=Solver?>
