//// MODULE_NAME: <?=calcLR?>
//// MODULE_DEPENDS: <?=consLR_t?> <?=cell_dxs?> <?=Solver?>

// TODO incorporate parallel propagators

namespace <?=Solver?> {

using ConsLR = <?=consLR_t?>;

<? if not solver.usePLM then return end ?>

// piecewise-constant
struct CalcCellLR_PiecewiseConstant {
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		// hmm, using named param initialization is failing in clang here, so gotta use function ctor
		return ConsLR(*pU, *pU);
	}
};

/*
piecewise-linear

#1: slope based on conservative variables
----------------------------------------

phi(x) = minmod(x) = clamp(r, 0, 1)

dUL = U_i - U_i-1
dUR = U_i+1 - U_i
sigma = phi( dUL / dUR ) * dUR

dF = F(U_i+1/2) - F(U_i-1/2)

dx = (x_i+1/2 - x_i-1/2)
U_i-1/2,R = U_i - 1/2 (sigma - dt/dx dF)
U_i+1/2,L = U_i + 1/2 (sigma + dt/dx dF)

Hydrodynamics II slope-limiters (4.4.2) and MUSCL-Hancock (6.6)
and https://en.wikipedia.org/wiki/MUSCL_scheme
works for euler Sod 1D with oscillations 
works for euler Sod 2D
works for mhd Brio-Wu 1D with oscillations 
works for maxwell with oscillations 
works for adm1d_v1 freeflow with oscillations (fails for mirror)
*/
struct CalcCellLR_PLMCons {
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		auto const & UL = pU[-solver.stepsize[side]];
		auto const & UR = pU[ solver.stepsize[side]];
		
		auto const & cellL = pcell[-solver.stepsize[side]];
		auto const & cellR = pcell[ solver.stepsize[side]];

		real3 xIntL = pcell->pos; xIntL[side] -= .5 * solver.grid_dx[side];
		real3 xIntR = pcell->pos; xIntR[side] += .5 * solver.grid_dx[side];
		
		Cons UHalfL, UHalfR;
		for (int j = 0; j < numIntStates; ++j) {
			real dUL = pU->s[j] - UL.s[j];
			real dUR = UR.s[j] - pU->s[j];
			
			//Hydrodynamics II slope-limiters (4.4.2) and MUSCL-Hancock (6.6)	
			//https://en.wikipedia.org/wiki/MUSCL_scheme
				
			/*
			minmod(r) = max(0, min(r, 1))
			superbee(r) = max(0, max(
								min(1, 2*r),
								min(2, r)
							))

			minmod2(a,b) = a * b < 0  
					? 0
					: (|a| < |b| ? a : b)

			a = u[i+1] - u[i]
			b = u[i] - u[i-1]
			r = a / b = (u[i+1] - u[i]) / (u[i] - u[i-1])

			minmod2(a,b) = minmod2(rb, b) = |b| minmod2(r sgn b, sgn b)
			TODO oops I forgot r can be negative, and so this sgn b < 0 case is bad ...
			for sgn b < 0: 
				minmod2(a,b) = |b| minmod2(-r, -1) = 0
			for sgn b >= 0:
				minmod2(a,b) = |b| minmod2(r, 1) = 
					|b| * (r * 1 < 0 ? 0
									: (|r| < 1 ? r : 1))
				minmod2(a,b) = |b| sgn r * max(0, min(|r|, 1))
				minmod2(a,b) = |b| sgn r * minmod(|r|)
			*/
#if 1
			real r = dUR == 0 ? 0 : (dUL / dUR);
//// MODULE_DEPENDS: <?=slopeLimiter?>
			real phi = <?=slopeLimiter?>(r);	//works good with minmod, bad with superbee
			real sigma = phi * dUR;
#else	//isn't as accurate anyways
			real sigma = minmod(minmod(fabs(dUL), 
				fabs(dUR.s[j])),
				fabs(.5 * (dUL - dUR))
			) * sign(dUL - dUR);
#endif
			//q^n_i-1/2,R = q^n_i - 1/2 dx sigma	(Hydrodynamics II 6.58)
			UHalfL.s[j] = pU->s[j] - .5 * sigma;
			
			//q^n_i+1/2,L = q^n_i + 1/2 dx sigma	(Hydrodynamics II 6.59)
			UHalfR.s[j] = pU->s[j] + .5 * sigma;
		}
		for (int j = numIntStates; j < numStates; ++j) {
			UHalfL.s[j] = UHalfR.s[j] = pU->s[j];
		}

		real dx = cell_dxs<side>(solver, pcell->pos);
		real dt_dx = dt / dx;

<? print("TODO cell_t averaging here?") ?>
		Cons FHalfL = Eqn::fluxFromCons(solver, UHalfL, cellL, Normal::template forSide<side>(xIntL));
		Cons FHalfR = Eqn::fluxFromCons(solver, UHalfR, cellR, Normal::template forSide<side>(xIntR));

		auto result = ConsLR(*pU, *pU);
		for (int j = 0; j < numIntStates; ++j) {
			real dF = FHalfR.s[j] - FHalfL.s[j];

			//pU-cell-L = q^n+1/2_i-1/2,R (Hydrodynamics II 6.62)
			// = q^n_i-1/2,R + 1/2 dt/dx (f_k(q^n_i+1/2,L) - f_k(q_i-1/2,R))
			result.L.s[j] = UHalfL.s[j] + .5 * dt_dx * dF;

			//pU-cell R = q^n+1/2_i+1/2,L (Hydrodynamics II 6.63)
			// = q^n_i+1/2,L + 1/2 dt/dx (f_k(q^n_i+1/2,L) - f_k(q_i-1/2,R))
			result.R.s[j] = UHalfR.s[j] + .5 * dt_dx * dF;
		}
		return result;
	}
};

// technically i should call the one above "plm-cons-with-flux" 
// and this one "plm-cons"
struct CalcCellLR_PLMConsAlone {
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		// extrapolate slopes in consered variable space
		real dx = solver.grid_dx[side];

		real3 xL = pcell->pos; xL[side] -= dx;
		real3 xR = pcell->pos; xR[side] += dx;

		auto const & UL = pU[-solver.stepsize[side]];
		auto const & UR = pU[ solver.stepsize[side]];

		auto result = ConsLR(*pU, *pU);
		// minmod
		for (int j = 0; j < numIntStates; ++j) {
#if 1	// taken from above / from Dullemond "Hydrodynamics II"
			real dUR = UR.s[j] - pU->s[j];
			real dUL = pU->s[j] - UL.s[j];
			real r = dUR == 0 ? 0 : (dUL / dUR);
//// MODULE_DEPENDS: <?=slopeLimiter?>
			real phi = <?=slopeLimiter?>(r);	//works good with minmod, bad with superbee
			real sigma = phi * dUR;
			result.L.s[j] -= .5 * sigma;
			result.R.s[j] += .5 * sigma;
#endif
#if 0 	// Based on Mara's PLM.  Looks to be asymmetric, favoring the x+ and y+ directions. Maybe I copied it wrong.
			real dUL = pU->s[j] - UL.s[j];
			real dUC = .5 * (UR.s[j] - UL.s[j]);
			real dUR = UR.s[j] - pU->s[j];
			real adwl = fabs(dUL);
			real adwr = fabs(dUR);
			real adwc = fabs(dUC);
			real mindw = min3(adwl, adwr, adwc);
			real dUM = .25 * fabs(sign(dUL) + sign(dUC)) * fabs(sign(dUL) + sign(dUR)) * mindw;
			result.L.s[j] -= .5 * dUM; 
			result.R.s[j] += .5 * dUM; 
#endif
		}
		return result;
	}
};

struct CalcCellLR_PLMPrimAlone {
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		// extrapolate slopes in primitive space
		real dx = solver.grid_dx[side];

		real3 xL = pcell->pos; xL[side] -= dx;
		real3 xR = pcell->pos; xR[side] += dx;

		auto const & UL = pU[-solver.stepsize[side]];
		auto const & UR = pU[ solver.stepsize[side]];

		Prim W = Eqn::primFromCons(solver, *pU, pcell->pos);
		Prim WL = Eqn::primFromCons(solver, UL, xL);
		Prim WR = Eqn::primFromCons(solver, UR, xR);
		
		// minmod
		Prim nWL = W;
		Prim nWR = W;
		for (int j = 0; j < numIntStates; ++j) {
#if 1	// taken from above / from Dullemond "Hydrodynamics II"
			real dWR = WR.s[j] - W.s[j];
			real dWL = W.s[j] - WL.s[j];
			real r = dWR == 0 ? 0 : (dWL / dWR);
//// MODULE_DEPENDS: <?=slopeLimiter?>
			real phi = <?=slopeLimiter?>(r);
			real sigma = phi * dWR;
			nWL.s[j] -= .5 * sigma;
			nWR.s[j] += .5 * sigma;
#endif
#if 0	// Based on Mara's PLM.  Looks to be asymmetric, favoring the x+ and y+ directions. Maybe I copied it wrong.
			real dWL = W.s[j] - WL.s[j];	//TODO SOR or whatever ... scalar here x2?
			real dWC = .5 * (WR.s[j] - WL.s[j]);
			real dWR = WR.s[j] - W.s[j];
			real adwl = fabs(dWL);
			real adwr = fabs(dWR);
			real adwc = fabs(dWC);
			real mindw = min(min(adwl, adwr), adwc);
			real dWM = .25 * fabs(sign(dWL) + sign(dWC)) * fabs(sign(dWL) + sign(dWR)) * mindw;
			nWL.s[j] -= .5 * dWM; 
			nWR.s[j] += .5 * dWM; 
#endif	
		}
		
		real3 xIntL = pcell->pos; xIntL[side] -= .5 * dx;
		real3 xIntR = pcell->pos; xIntR[side] += .5 * dx;

		//converting from cons->prim and then prim->cons might lose us accuracy? 
		return ConsLR(
			Eqn::consFromPrim(solver, nWL, xIntL),
			Eqn::consFromPrim(solver, nWR, xIntR));
	}
};

//// MODULE_DEPENDS: min3

/*
#2: next step, project into eigenspace
----------------------------------------

evL, evR, wave = eigensystem(dF/dU at i)

dULe = evL( U_i - U_i-1 )
dURe = evL( U_i+1 - U_i )
dUCe = evL( (U_i+1 - U_i-1)/2 )
dUMe_j = step(dULe_j * dURe_j) * sign(dUCe_j) * 2 * min(|dULe_j|, |dURe_j|, |dUCe_j|) 

aL = step(wave_j) dUMe_j (1 - wave_j dt/dx)
aR = step(-wave_j) dUMe_j (1 + wave_j dt/dx)

U_i-1/2,R = U_i - evR 1/2 aR
U_i+1/2,L = U_i + evR 1/2 aL

based on https://arxiv.org/pdf/0804.0402v1.pdf 
and Trangenstein "Numeric Simulation of Hyperbolic Conservation Laws" section 6.2.5
except I'm projecting the differences in conservative values instead of primitive values.
This also needs modular slope limiter support.
works for Euler 1D Sod
euler 2D Sod this gets strange behavior and slowly diverges.
works for MHD Brio-Wu
works for maxwell 
works for adm1d_v1 
*/
struct CalcCellLR_PLMEig {
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		//1) calc delta q's ... l r c (eqn 36)
		auto const & UL = pU[-solver.stepsize[side]];
		auto const & UR = pU[ solver.stepsize[side]];
		Cons dUL, dUR, dUC;
		for (int j = 0; j < numIntStates; ++j) {
			dUL.s[j] = pU->s[j] - UL.s[j];
			dUR.s[j] = UR.s[j] - pU->s[j];
			dUC.s[j] = .5 * (UR.s[j] - UL.s[j]);
		}
		for (int j = numIntStates; j < numStates; ++j) {
			dUL.s[j] = dUR.s[j] = dUC.s[j] = 0;
		}

		real3 xIntL = pcell->pos; xIntL[side] -= .5 * solver.grid_dx[side];
		real3 xIntR = pcell->pos; xIntR[side] += .5 * solver.grid_dx[side];

		//calc eigen values and vectors at cell center
		Eigen eig = Eqn::eigen_forCell(solver, *pU, *pcell, n);
			
		Waves dULEig = Eqn::eigen_leftTransform(solver, eig, dUL, xIntL, Normal::template forSide<side>(xIntL));
		Waves dUREig = Eqn::eigen_leftTransform(solver, eig, dUR, xIntR, Normal::template forSide<side>(xIntR));
		Waves dUCEig = Eqn::eigen_leftTransform(solver, eig, dUC, pcell->pos, n);

		//MUSCL slope of characteristic variables
		//TODO make this based on the choice of slope limiter
		Waves dUMEig;
		for (int j = 0; j < numWaves; ++j) {

// This is adapted from above to use the modular slopeLimiter
#if 0
			real r = dUREig.s[j] == 0 ? 0 : (dULEig.s[j] / dUREig.s[j]);
//// MODULE_DEPENDS: <?=slopeLimiter?>
			real phi = <?=slopeLimiter?>(r);
			real sigma = phi * dUREig.s[j];
			dUMEig.s[j] = sigma;

#endif

//This one is symmetric, unlike the above center-slope-based methods.
// It also takes into account the center slope, unlike the <?=slopeLimiter?>() options.
// However it is fixed to minmod and does not use the modular <?=slopeLimiter?>() option.
#if 1	
			//dUMEig.s[j] = minmod(minmod(2. * dULEig.s[j], 2. * dUREig.s[j]), dUCEig.s[j]);
			dUMEig.s[j] = dULEig.s[j] * dUREig.s[j] < 0 ? 0 : (
				(dUCEig.s[j] >= 0. ? 1. : -1.)
				* 2. * min3(
					fabs(dULEig.s[j]),
					fabs(dUREig.s[j]),
					fabs(dUCEig.s[j]))
			);
#endif	
		}

		real dx = cell_dxs<side>(solver, pcell->pos);
		real dt_dx = dt / dx;

		auto calcWaves = Eqn::EigenWaveCode(solver, eig, n, pcell->pos);

		// slopes in characteristic space
		Waves aL;
		Waves aR;
		for (int j = 0; j < numWaves; ++j) {
			real const wave_j = calcWaves(solver, eig, n, pcell->pos, j);
			aL.s[j] = wave_j < 0 ? 0 : dUMEig.s[j] * .5 * (1. - wave_j * dt_dx);
			aR.s[j] = wave_j > 0 ? 0 : dUMEig.s[j] * .5 * (1. + wave_j * dt_dx);
		}
		
		//convert back to conservation variable space
		Cons sL = Eqn::eigen_rightTransform(solver, eig, aL, pcell->pos, n);
		Cons sR = Eqn::eigen_rightTransform(solver, eig, aR, pcell->pos, n);

		auto result = ConsLR(*pU, *pU);
		for (int j = 0; j < numIntStates; ++j) {
			result.L.s[j] += sL.s[j];
			result.R.s[j] -= sR.s[j];
		}
		return result;
	}
};


//// MODULE_DEPENDS: min3

/*
#3a: next step, convert to primitives
----------------------------------------

evL, evR, wave = eigensystem(dF/dU at i)

W_i = W(U_i)

dWLe = evL dU/dW ( W_i - W_i-1 )
dWRe = evL dU/dW ( W_i+1 - W_i )
dWCe = evL dU/dW ( (W_i+1 - W_i-1)/2 )
dWMe_j = step(dWL_j * dWRe_j) * sign(dWCe_j) * 2 * min(|dWLe_j|, |dWRe_j|, |dWCe_j|)

aL = step(wave_j) dWMe_j (1 - wave_j dt/dx)
aR = step(-wave_j) dWMe_j (1 + wave_j dt/dx)

U_i-1/2,R = U(W_i - 1/2 dW/dU evR aR)
U_i+1/2,L = U(W_i + 1/2 dW/dU evR aL)


#3b: next step, subtract out reference state
----------------------------------------

evL, evR, wave = eigensystem(dF/dU at i)

W_i = W(U_i)

dWLe = evL dU/dW ( W_i - W_i-1 )
dWRe = evL dU/dW ( W_i+1 - W_i )
dWCe = evL dU/dW ( (W_i+1 - W_i-1)/2 )
dWMe_j = step(dWL_j * dWRe_j) * sign(dWCe_j) * 2 * min(|dWLe_j|, |dWRe_j|, |dWCe_j|)

aL = step(wave_j) dWMe_j dt/dx (max(wave) - wave_j)
aR = step(-wave_j) dWMe_j dt/dx (wave_j - min(wave))

U_i-1/2,R = U( W_i - 1/2 dW/dU evR (aR + (1 + dt/dx min(wave)) dWMe) )
U_i+1/2,L = U( W_i + 1/2 dW/dU evR (aL + (1 - dt/dx max(wave)) dWMe) )
		

based on Trangenstein, Athena, etc, except working on primitives like it says to
*/
struct CalcCellLR_PLMEigPrimBase {
	struct Result {
		real3 xIntL;
		real3 xIntR;
		Prim W;
		Eigen eig;
		Waves dWMEig;
		real dt_dx;
		Eqn::EigenWaveCode calcWaves;
	};

	template<int side>
	static Result init(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		real3 xL = pcell->pos; xL[side] -= solver.grid_dx[side];
		real3 xR = pcell->pos; xR[side] += solver.grid_dx[side];
		
		real3 xIntL = pcell->pos; xIntL[side] -= .5 * solver.grid_dx[side];
		real3 xIntR = pcell->pos; xIntR[side] += .5 * solver.grid_dx[side];
		
		auto const & UL = pU[-solver.stepsize[side]];
		auto const & UR = pU[ solver.stepsize[side]];
		
		//1) calc delta q's ... l r c (eqn 36)
		Prim W = Eqn::primFromCons(solver, *pU, pcell->pos);
		Prim WL = Eqn::primFromCons(solver, UL, xL);
		Prim WR = Eqn::primFromCons(solver, UR, xR);
		Prim dWL, dWR, dWC;
		for (int j = 0; j < numIntStates; ++j) {
			dWL.s[j] = W.s[j] - WL.s[j];
			dWR.s[j] = WR.s[j] - W.s[j];
			dWC.s[j] = .5 * (WR.s[j] - WL.s[j]);
		}
		for (int j = numIntStates; j < numStates; ++j) {
			dWL.s[j] = dWR.s[j] = dWC.s[j] = 0.;
		}

		//calc eigen values and vectors at cell center
		//TODO calculate the eigenstate wrt W instead of U - to save some computations
		Eigen eig = Eqn::eigen_forCell(solver, *pU, *pcell, n);
			
		//apply dU/dW before applying left/right eigenvectors so the eigenvectors are of the flux wrt primitives 
		//RW = dW/dU RU, LW = LU dU/dW
		Waves dWLEig = Eqn::eigen_leftTransform(
			solver,
			eig,
			Eqn::apply_dU_dW(solver, W, dWL, xIntL),
			xIntL,
			Normal::template forSide<side>(xIntL)
		);
		
		Waves dWREig = Eqn::eigen_leftTransform(
			solver,
			eig,
			Eqn::apply_dU_dW(solver, W, dWR, xIntR),
			xIntR,
			Normal::template forSide<side>(xIntR));
		
		Waves dWCEig = Eqn::eigen_leftTransform(
			solver,
			eig,
			Eqn::apply_dU_dW(solver, W, dWC, pcell->pos),
			pcell->pos,
			n);

		//MUSCL slope of characteristic variables
		Waves dWMEig;
		for (int j = 0; j < numWaves; ++j) {
			dWMEig.s[j] = dWLEig.s[j] * dWREig.s[j] < 0. ? 0. : (
				(dWCEig.s[j] >= 0. ? 1. : -1.)
				* 2. * min3(
					fabs(dWLEig.s[j]),
					fabs(dWREig.s[j]),
					fabs(dWCEig.s[j])
				)
			);
		}

		real dx = cell_dxs<side>(solver, pcell->pos);
		real dt_dx = dt / dx;

		Eqn::EigenWaveCode calcWaves(solver, eig, n, pcell->pos);
	
		return Result{
			xIntL,
			xIntR,
			W,
			eig,
			dWMEig,
			dt_dx,
			calcWaves
		};
	}
};

struct CalcCellLR_PLMEigPrim : public CalcCellLR_PLMEigPrimBase {
	using Super = CalcCellLR_PLMEigPrimBase;
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		auto [xIntL, xIntR, W, eig, dWMEig, dt_dx, calcWaves] 
		= Super::init<side>(solver, pU, pcell, dt, i, n);

		//without reference state

		// calculate left and right slopes in characteristic space
		Waves aL, aR;
		for (int j = 0; j < numWaves; ++j) {
			real const wave_j = calcWaves(solver, eig, n, pcell->pos, j);
			aL.s[j] = wave_j < 0 ? 0 : dWMEig.s[j] * .5 * (1. - wave_j * dt_dx);
			aR.s[j] = wave_j > 0 ? 0 : dWMEig.s[j] * .5 * (1. + wave_j * dt_dx);
		}

		// transform slopes back to conserved variable space
		Prim sL = Eqn::apply_dW_dU(
			solver,
			W,
			Eqn::eigen_rightTransform(solver, eig, aL, xIntL, Normal::template forSide<side>(xIntL)), 
			xIntL);
		
		Prim sR = Eqn::apply_dW_dU(solver,
			W,
			Eqn::eigen_rightTransform(solver, eig, aR, xIntR, Normal::template forSide<side>(xIntR)),
			xIntR);

		// linearly extrapolate the slopes forward and backward from the cell center
		Prim W2L, W2R;
		for (int j = 0; j < numIntStates; ++j) {
			W2L.s[j] = W.s[j] + sL.s[j];
			W2R.s[j] = W.s[j] - sR.s[j];
		}
		for (int j = numIntStates; j < numStates; ++j) {
			W2L.s[j] = W2R.s[j] = W.s[j];
		}
		return ConsLR(
			Eqn::consFromPrim(solver, W2L, xIntL),
			Eqn::consFromPrim(solver, W2R, xIntR));
	}
};

struct CalcCellLR_PLMEigPrimRef : public CalcCellLR_PLMEigPrimBase {
	using Super = CalcCellLR_PLMEigPrimBase;
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		auto [xIntL, xIntR, W, eig, dWMEig, dt_dx, calcWaves] 
		= Super::init<side>(solver, pU, pcell, dt, i, n);

		//with reference state

		//min and max waves
		//TODO use eigenWaveCodeMinMax ... 
		// but the same vars have been declared in eigenWaveCodePrefix above ...
		// so which is worse? 5 min() calcs or 1 sqrt() ?
		real waveMin, waveMax;
		Eqn::eigenWaveCodeMinMax(solver, eig, n, pcell->pos, &waveMin, &waveMax);
		waveMin = min(0., waveMin);
		waveMax = max(0., waveMax);

		//limited slope in primitive variable space
		Prim dWM = Eqn::apply_dW_dU(
			solver,
			W,
			Eqn::eigen_rightTransform(solver, eig, dWMEig, pcell->pos, n),
			pcell->pos);

		//left and right reference states
		Prim WLRef, WRRef;
		for (int j = 0; j < numIntStates; ++j) {
			WLRef.s[j] = W.s[j] + .5 * (1. - dt_dx * waveMax) * dWM.s[j];
			WRRef.s[j] = W.s[j] - .5 * (1. + dt_dx * waveMin) * dWM.s[j];
		}
		for (int j = numIntStates; j < numStates; ++j) {
			WLRef.s[j] = WRRef.s[j] = 0;
		}

		// calculate left and right slopes in characteristic space
		Waves aL, aR;
		for (int j = 0; j < numWaves; ++j) {
			real const wave_j = calcWaves(solver, eig, n, pcell->pos, j);
			aL.s[j] = wave_j < 0 ? 0 : (dWMEig.s[j] * dt_dx * (waveMax - wave_j));
			aR.s[j] = wave_j > 0 ? 0 : (dWMEig.s[j] * dt_dx * (waveMin - wave_j));
		}

		// transform slopes back to conserved variable space
		Prim sL = Eqn::apply_dW_dU(
			solver,
			W,
			Eqn::eigen_rightTransform(solver, eig, aL, xIntL, Normal::template forSide<side>(xIntL)),
			xIntL);
		Prim sR = Eqn::apply_dW_dU(
			solver,
			W,
			Eqn::eigen_rightTransform(solver, eig, aR, xIntR, Normal::template forSide<side>(xIntR)),
			xIntR);

		// linearly extrapolate the slopes forward and backward from the cell center
		Prim W2L, W2R;
		for (int j = 0; j < numIntStates; ++j) {
			W2R.s[j] = WRRef.s[j] + .5 * sR.s[j];
			W2L.s[j] = WLRef.s[j] + .5 * sL.s[j];
		}
		for (int j = numIntStates; j < numStates; ++j) {
			W2R.s[j] = W2L.s[j] = W.s[j];
		}
		//TODO fix the x's
		return ConsLR(
			Eqn::consFromPrim(solver, W2L, xIntL),
			Eqn::consFromPrim(solver, W2R, xIntR));
	}
};

//based on Athena
struct CalcCellLR_Athena {
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		real3 xIntL = pcell->pos; xIntL[side] -= .5 * solver.grid_dx[side];
		real3 xIntR = pcell->pos; xIntR[side] += .5 * solver.grid_dx[side];
		
		real3 xL = pcell->pos; xL[side] -= solver.grid_dx[side];
		real3 xR = pcell->pos; xR[side] += solver.grid_dx[side];

		//calc eigen values and vectors at cell center
		Eigen eig = Eqn::eigen_forCell(solver, *pU, *pcell, n);

		real const dx = cell_dxs<side>(solver, pcell->pos);
		real const dt_dx = dt / dx;

		//1) calc delta q's ... l r c (eqn 36)
		auto const & UL = pU[-solver.stepsize[side]];
		auto const & UR = pU[ solver.stepsize[side]];

		Prim W = Eqn::primFromCons(solver, *pU, pcell->pos);
		Prim WL = Eqn::primFromCons(solver, UL, xL);
		Prim WR = Eqn::primFromCons(solver, UR, xR);
		
		Prim dWL, dWR, dWC, dWG;
		for (int j = 0; j < numIntStates; ++j) {
			dWL.s[j] = W.s[j] - WL.s[j];
			dWR.s[j] = WR.s[j] - W.s[j];
			dWC.s[j] = .5 * (WR.s[j] - WL.s[j]);
			dWG.s[j] = (dWL.s[j] * dWR.s[j]) <= 0. ? 0. : (
				2. * dWL.s[j] * dWR.s[j] / (dWL.s[j] + dWR.s[j])
			);
		}
		for (int j = numIntStates; j < numStates; ++j) {
			dWL.s[j] = dWR.s[j] = dWC.s[j] = dWG.s[j] = 0.;
		}

		//TODO shouldn't this be the dA/dW eigen transformation?
		Waves dal = Eqn::eigen_leftTransform(solver, eig, *(Cons*)&dWL, xIntL, Normal::template forSide<side>(xIntL));
		Waves dar = Eqn::eigen_leftTransform(solver, eig, *(Cons*)&dWR, xIntR, Normal::template forSide<side>(xIntR));
		Waves dac = Eqn::eigen_leftTransform(solver, eig, *(Cons*)&dWC, pcell->pos, n);
		Waves dag = Eqn::eigen_leftTransform(solver, eig, *(Cons*)&dWG, pcell->pos, n);

		Waves da;
		for (int j = 0; j < numWaves; ++j) {
			da.s[j] = 0;
			if (dal.s[j] * dar.s[j] > 0) {
				real lim_slope1 = min(fabs(dal.s[j]), fabs(dar.s[j]));
				real lim_slope2 = min(fabs(dac.s[j]), fabs(dag.s[j]));
				da.s[j] = sign(dac.s[j]) * min((real)2. * lim_slope1, lim_slope2);
			}
		}

		Cons dWm_tmp = Eqn::eigen_rightTransform(solver, eig, da, pcell->pos, n);
		Prim dWm = *(Prim*)&dWm_tmp;

		Prim Wlv, Wrv;
		for (int j = 0; j < numIntStates; ++j) {
			Wlv.s[j] = W.s[j] - .5 * dWm.s[j];
			Wrv.s[j] = W.s[j] + .5 * dWm.s[j];
			real C = Wrv.s[j] + Wlv.s[j];
			
			Wlv.s[j] = max(min(W.s[j], WL.s[j]), Wlv.s[j]);
			Wlv.s[j] = min(max(W.s[j], WL.s[j]), Wlv.s[j]);
			Wrv.s[j] = C - Wlv.s[j];

			Wrv.s[j] = max(min(W.s[j],WR.s[j]),Wrv.s[j]);
			Wrv.s[j] = min(max(W.s[j],WR.s[j]),Wrv.s[j]);
			Wlv.s[j] = C - Wrv.s[j];
		}
		for (int j = numIntStates; j < numStates; ++j) {
			Wlv.s[j] = W.s[j];
			Wrv.s[j] = W.s[j];
		}

		return ConsLR(
			Eqn::consFromPrim(solver, Wrv, xIntL),
			Eqn::consFromPrim(solver, Wlv, xIntR));
	}
};

//// MODULE_DEPENDS: min3 sqr
// based on http://zingale.github.io/hydro1d/  ppm code
struct CalcCellLR_PPM_WIP {
	template<int side>
	static ConsLR go(
		constant Solver const & solver,
		global Cons const * const pU,
		global Cell const * const pcell,
		real const dt,
		int4 const i,
		Normal const n
	) {
		real3 xL = pcell->pos; xL[side] -= solver.grid_dx[side];
		real3 xR = pcell->pos; xR[side] += solver.grid_dx[side];

		real const z0 = .75;
		real const z1 = .85;
		real const delta = .33;
		real const minP = 1e-10;
		
		Prim W_im3 = Eqn::primFromCons(solver, pU[- 3 * solver.stepsize[side]], pcell->pos);
		Prim W_im2 = Eqn::primFromCons(solver, pU[- 2 * solver.stepsize[side]], pcell->pos);
		Prim W_im1 = Eqn::primFromCons(solver, pU[- 1 * solver.stepsize[side]], pcell->pos);
		Prim W_i = Eqn::primFromCons(solver, *pU, pcell->pos);
		Prim W_ip1 = Eqn::primFromCons(solver, pU[+ 1 * solver.stepsize[side]], pcell->pos);
		Prim W_ip2 = Eqn::primFromCons(solver, pU[+ 2 * solver.stepsize[side]], pcell->pos);
		Prim W_ip3 = Eqn::primFromCons(solver, pU[+ 3 * solver.stepsize[side]], pcell->pos);

		// this is based on pressure ... how to generalize for all PDEs?
		real const dP_i = fabs(W_ip1.P - W_im1.P);
		real const dP2_i = fabs(W_ip2.P - W_im2.P);
		real const z_i = dP_i / max(dP2_i, minP);
		
		real xi_t_i;
		if ((W_im1.v[side] - W_ip1.v[side] > 0) && (dP_i / min(W_ip1.P, W_im1.P) > delta)) {
			xi_t_i = clamp(1. - (z_i - z0) / (z1 - z0), 0., 1.);
		} else {
			xi_t_i = 0;
		}


		real const dP_ip1 = fabs(W_ip2.P - W_i.P);
		real const dP2_ip1 = fabs(W_ip3.P - W_im1.P);
		real const z_ip1 = dP_ip1 / max(dP2_ip1, minP);
		
		real xi_t_ip1;
		if ((W_i.v[side] - W_ip2.v[side] > 0) && (dP_ip1 / min(W_ip2.P, W_i.P) > delta)) {
			xi_t_ip1 = clamp(1. - (z_ip1 - z0) / (z1 - z0), 0., 1.);
		} else {
			xi_t_ip1 = 0;
		}


		real const dP_im1 = fabs(W_i.P - W_im2.P);
		real const dP2_im1 = fabs(W_ip1.P - W_im3.P);
		real const z_im1 = dP_im1 / max(dP2_im1, minP);
		
		real xi_t_im1;
		if ((W_im2.v[side] - W_i.v[side] > 0) && (dP_im1 / min(W_i.P, W_im2.P) > delta)) {
			xi_t_im1 = clamp(1. - (z_im1 - z0) / (z1 - z0), 0., 1.);
		} else {
			xi_t_im1 = 0;
		}


		real xi_i;
		if (W_ip1.P - W_im1.P > 0) {
			xi_i = min(xi_t_i, xi_t_im1);
		} else if (W_ip1.P - W_im1.P < 0) {
			xi_i = min(xi_t_i, xi_t_ip1);
		} else {
			xi_i = xi_t_i;
		}

		Cons Wplus_i;
		Cons Wminus_i;
		for (int j = 0; j < numStates; ++j) {
			// 1984 collela & woodward eqn 1.7
			real dq0_i = .5 * (W_ip1.s[j] - W_im1.s[j]);
			
			// 1984 collela & woodward eqn 1.8
			if ((W_ip1.s[j] - W_i.s[j]) * (W_i.s[j] - W_im1.s[j]) > 0) {
				dq0_i = sign(dq0_i) * min3( 
					fabs(dq0_i),
					2. * fabs(W_i.s[j] - W_im1.s[j]),
					2. * fabs(W_ip1.s[j] - W_i.s[j]));
			} else {
				dq0_i = 0;
			}
		
			// 1984 collela & woodward eqn 1.7
			real dqp_i = .5 * (W_ip2.s[j] - W_i.s[j]);
			
			// 1984 collela & woodward eqn 1.8
			if ((W_ip2.s[j] - W_ip1.s[j]) * (W_ip1.s[j] - W_i.s[j]) > 0) {
				dqp_i = sign(dqp_i) * min3(
					fabs(dqp_i),
					2. * fabs(W_ip1.s[j] - W_i.s[j]),
					2. * fabs(W_ip2.s[j] - W_ip1.s[j]));
			} else {
				dqp_i = 0;
			}


			// 1984 collela & woodward eqn 1.7
			real dq0_im1 = .5 * (W_i.s[j] - W_im2.s[j]);
			
			// 1984 collela & woodward eqn 1.8
			if ((W_i.s[j] - W_im1.s[j]) * (W_im1.s[j] - W_im2.s[j]) > 0) {
				dq0_im1 = sign(dq0_im1) * min3( 
					fabs(dq0_im1),
					2. * fabs(W_im1.s[j] - W_im2.s[j]),
					2. * fabs(W_i.s[j] - W_im1.s[j]));
			} else {
				dq0_im1 = 0;
			}
		
			// 1984 collela & woodward eqn 1.7
			real dqp_im1 = .5 * (W_ip1.s[j] - W_im1.s[j]);
			
			// 1984 collela & woodward eqn 1.8
			if ((W_ip1.s[j] - W_i.s[j]) * (W_i.s[j] - W_im1.s[j]) > 0) {
				dqp_im1 = sign(dqp_im1) * min3(
					fabs(dqp_im1),
					2. * fabs(W_i.s[j] - W_im1.s[j]),
					2. * fabs(W_ip1.s[j] - W_i.s[j]));
			} else {
				dqp_im1 = 0;
			}


			// 1984 collela & woodward, eqn 1.6
			Wplus_i.s[j] = .5 * (W_i.s[j] + W_ip1.s[j]) - (1./6.) * (dqp_i - dq0_i);
			Wminus_i.s[j] = .5 * (W_im1.s[j] + W_i.s[j]) - (1./6.) * (dqp_im1 - dq0_im1);
		
			// 2008 Colella & Sekora
			Wplus_i.s[j] = max(Wplus_i.s[j], min(W_i.s[j], W_ip1.s[j]));
			Wplus_i.s[j] = min(Wplus_i.s[j], max(W_i.s[j], W_ip1.s[j]));
			
			Wminus_i.s[j] = max(Wminus_i.s[j], min(W_im1.s[j], W_i.s[j]));
			Wminus_i.s[j] = min(Wminus_i.s[j], max(W_im1.s[j], W_i.s[j]));
		}

		// 1984 Collela & Woodward eqn 1.10 is somewhere in here:
		for (int j = 0; j < numStates; ++j) {
			if ((Wplus_i.s[j] - W_i.s[j]) * (W_i.s[j] - Wminus_i.s[j]) <= 0) {
				Wminus_i.s[j] = W_i.s[j];
				Wplus_i.s[j] = W_i.s[j];
			} else if ((Wplus_i.s[j] - Wminus_i.s[j]) * (W_i.s[j] - .5 * (Wminus_i.s[j] + Wplus_i.s[j])) > sqr(Wplus_i.s[j] - Wminus_i.s[j]) / 6.) {
				Wminus_i.s[j] = 3. * W_i.s[j] - 2. * Wplus_i.s[j];
			} else if (-sqr(Wplus_i.s[j] - Wminus_i.s[j]) / 6. > (Wplus_i.s[j] - Wminus_i.s[j]) * (W_i.s[j] - .5 * (Wminus_i.s[j] + Wplus_i.s[j]))) {
				Wplus_i.s[j] = 3. * W_i.s[j] - 2. * Wminus_i.s[j];
			}
		}

		// flatten
		for (int j = 0; j < numStates; ++j) {
			Wminus_i.s[j] = (1. - xi_i) * W_i.s[j] + xi_i * Wminus_i.s[j];
			Wplus_i.s[j] = (1. - xi_i) * W_i.s[j] + xi_i * Wplus_i.s[j];
		}
		
		// W6
		Cons W6_i;
		for (int j = 0; j < numStates; ++j) {
			W6_i.s[j] = 6. * W_i.s[j] - 3. * (Wminus_i.s[j] + Wplus_i.s[j]);
		}

		Eigen eig = Eqn::eigen_forCell(solver, *pU, *pcell, n);

		Waves lambda;
		real lambdaMin = INFINITY;
		real lambdaMax = -INFINITY;
		{
			auto calcWaves = Eqn::EigenWaveCode(solver, eig, n, pcell->pos);
			for (int j = 0; j < numWaves; ++j) {
				// TODO once again this was set to U when the prefix was based on eig ...
				real const lambda_j = calcWaves(solver, eig, n, pcell->pos, j);
				lambdaMin = min(lambdaMin, lambda_j);
				lambdaMax = min(lambdaMax, lambda_j);
				lambda.s[j] = lambda_j;
			}
		}

		real dx = cell_dxs<side>(solver, pcell->pos);
		real dt_dx = dt / dx;
		
		Prim Iplus[numWaves];
		Prim Iminus[numWaves];
		for (int j = 0; j < numWaves; ++j) {
			real sigma = fabs(lambda.s[j]) * dt_dx;
			for (int k = 0; k < numStates; ++k) {
				if (lambda.s[j] >= 0) {
					Iplus[j].s[k] = Wplus_i.s[k] - .5 * sigma * (Wplus_i.s[k] - Wminus_i.s[k] - (1 - (2./3.)*sigma) * W6_i.s[k]);
				} else {
					Iplus[j].s[k] = W_i.s[k];
				}
				if (lambda.s[j] <= 0) {
					Iminus[j].s[k] = Wminus_i.s[k] + .5 * sigma * (Wplus_i.s[k] - Wminus_i.s[k] + (1 - (2./3.)*sigma) * W6_i.s[k]);
				} else {
					Iminus[j].s[k] = W_i.s[k];
				}
			}
		}

		Prim Wref_xp;
		if (lambdaMax >= 0) {
			Wref_xp = Iplus[numWaves-1];	//this assumes max == numWaves-1
		} else {
			Wref_xp = W_i;
		}

		Prim Wref_xm;
		if (lambdaMin <= 0) {
			Wref_xm = Iminus[0];			//this assumes min == 0
		} else {
			Wref_xm = W_i;
		}

		// beta± = L*(Wref± - I±)

		// dF = dF/dU dU = R_F Lambda_F L_F dU
		// 

		//TODO ... convert prim to cons, then cons eig transform
		Cons Uref_xp = Eqn::apply_dU_dW(solver, W_i, Wref_xp, pcell->pos);
		Waves beta_xp = Eqn::eigen_leftTransform(solver, eig, Uref_xp, pcell->pos, n);
		
		Cons Uref_xm = Eqn::apply_dU_dW(solver, W_i, Wref_xm, pcell->pos);
		Waves beta_xm = Eqn::eigen_leftTransform(solver, eig, Uref_xm, pcell->pos, n);
		
		for (int m = 0; m < numWaves; ++m) {
			{
				Cons Uminus = Eqn::apply_dU_dW(solver, W_i, Iminus[m], pcell->pos);
				Waves waves = Eqn::eigen_leftTransform(solver, eig, Uminus, pcell->pos, n);
				beta_xm.s[m] -= waves.s[m];
			}

			{
				Cons Uplus = Eqn::apply_dU_dW(solver, W_i, Iplus[m], pcell->pos);
				Waves waves = Eqn::eigen_leftTransform(solver, eig, Uplus, pcell->pos, n);
				beta_xp.s[m] -= waves.s[m];
			}
		}

		for (int j = 0; j < numWaves; ++j) {
			if (lambda.s[j] < 0) beta_xp.s[j] = 0;
			if (lambda.s[j] > 0) beta_xm.s[j] = 0;
		}
		
		Cons U_l_ip1 = Eqn::eigen_rightTransform(solver, eig, beta_xp, pcell->pos, n);
		Cons U_r_i = Eqn::eigen_rightTransform(solver, eig, beta_xm, pcell->pos, n);

		Prim W_l_ip1 = Eqn::apply_dW_dU(solver, W_i, U_l_ip1, pcell->pos);
		Prim W_r_i = Eqn::apply_dW_dU(solver, W_i, U_r_i, pcell->pos);

		for (int j = 0; j < numStates; ++j) {
			W_l_ip1.s[j] = Wref_xp.s[j] - W_l_ip1.s[j];
			W_r_i.s[j] = Wref_xm.s[j] - W_r_i.s[j];
		}

		return ConsLR(
			Eqn::consFromPrim(solver, W_r_i, pcell->pos),
			Eqn::consFromPrim(solver, W_l_ip1, pcell->pos));
	}
};


<? if solver.usePLM == "piecewise-constant" then ?>
using CalcCellLR = CalcCellLR_PiecewiseConstant;
<? elseif solver.usePLM == "plm-cons" then  ?>
using CalcCellLR = CalcCellLR_PLMCons;
<? elseif solver.usePLM == "plm-cons-alone" then ?>
using CalcCellLR = CalcCellLR_PLMConsAlone;
<? elseif solver.usePLM == "plm-prim-alone" then ?>
using CalcCellLR = CalcCellLR_PLMPrimAlone;
<? elseif solver.usePLM == "plm-eig" then ?>
using CalcCellLR = CalcCellLR_PLMEig;
<? elseif solver.usePLM == "plm-eig-prim" then ?>
using CalcCellLR = CalcCellLR_PLMEigPrim;
<?	elseif solver.usePLM == "plm-eig-prim-ref" then ?>
using CalcCellLR = CalcCellLR_PLMEigPrimRef;
<? elseif solver.usePLM == "plm-athena" then ?>
using CalcCellLR = CalcCellLR_Athena;
<? elseif solver.usePLM == "ppm-wip" then ?>
using CalcCellLR = CalcCellLR_PPM_WIP;
<? end ?>

}	// namespace <?=Solver?>

kernel void <?=calcLR?>(
	constant <?=solver_t?> const * const psolver,
	global <?=cell_t?> const * const cellBuf,
	global <?=consLR_t?> * const ULRBuf,
	global <?=cons_t?> const * const UBuf,
	real const dt
) {
	using namespace <?=Solver?>;
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(1,1);
	global <?=cons_t?> const * const pU = UBuf + index;
	global <?=cell_t?> const * const pcell = cellBuf + index;

	//TODO skip this lr stuff if we're doing piecewise-constant
	//...and just use the original buffers
	<? for side=0,solver.dim-1 do ?>{
		Normal const n = Normal::template forSide<<?=side?>>(pcell->pos);
		
		//cell-centered index for a particular side...
		int const indexForSide = <?=side?> + dim * index;
		ULRBuf[indexForSide] = CalcCellLR::go<<?=side?>>(solver, pU, pcell, dt, i, n);
	}<? end ?>
}

