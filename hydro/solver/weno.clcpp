//// MODULE_NAME: weno_l/r
//// MODULE_DEPENDS: sqr <?=Equation?>

namespace <?=Equation?> {

<?
local clnumber = require "cl.obj.number"

local stencilSize = solver.stencilSize
local coeffs = solver.coeffs

local coeff = coeffs[stencilSize]
local a = coeff.a
local d = coeff.d
local betaCoeffs = coeff.betaCoeffs

for side=0,solver.dim-1 do
	for _,l_or_r in ipairs{"l", "r"} do
		local ak0 = l_or_r == "l" and stencilSize or 1
		local akd = l_or_r == "l" and -1 or 1
		local al0 = l_or_r == "l" and stencilSize or 1
		local ald = l_or_r == "l" and -1 or 1
		local d0 = l_or_r == "l" and stencilSize or 1
		local dd = l_or_r == "l" and -1 or 1

-- how should I generalize this?
-- base pointer
-- number of cells (stencilSize)
-- number of coefficients at each cell ... or what C type it is, and how many variables to cycle across in the ptr field
-- ... or we can just always perform this interpolation in cons/char space
?>
Waves weno_<?=l_or_r?>_<?=side?>(
	Waves const * const v
) {
	Waves result;
	for (int k = 0; k < numWaves; ++k) {
<? 		for j=0,stencilSize-1 do
?>		real beta<?=j?> = 0.<?
			for m=0,stencilSize-1 do
				for n=0,m do ?>
			+ <?=clnumber(betaCoeffs[j+1][m+1][n+1])?> * v[<?=j+m?>].ptr[k] * v[<?=j+n?>].ptr[k]<?
				end
			end?>;
<?		end

		if solver.wenoMethod == "1996 Jiang Shu" then 		-- WENO-JS
			--local epsilon = clnumber(1e-14)
			local epsilon = clnumber(1e-6)
?>
<? 			for i=0,stencilSize-1 do
?>		real alpha<?=i?> = <?=clnumber(d[d0 + i * dd])?> / sqr(<?=epsilon?> + beta<?=i?>);
<? 			end

		elseif solver.wenoMethod == "2008 Borges" then 	-- WENO-Z
			local epsilon = clnumber(1e-6)

			-- TODO different coeffs of betas?
			if false then 	--if stencilSize == 4 then -- for 2016 Rathan, it suggests these:
?>		real tau = fabs(beta0 + 3. * beta1 - 3. * beta2 - beta3);
<?			else	-- for weno7, 2018 Zeytinoglu suggests this:
?>		real tau = fabs(beta0 - beta<?=stencilSize-1?>);
<?			end
 			for i=0,stencilSize-1 do
?>		real alpha<?=i?> = <?=clnumber(d[d0 + i * dd])?> * (1. + (tau / (beta<?=i?> + <?=epsilon?>)));
<? 			end

		elseif solver.wenoMethod == "2010 Shen Zha" then -- WENO-BS?
			local epsilon = clnumber(1e-10)

			-- TODO find these for other order WENO's
			local shen_zha_A = clnumber(50)	-- 0-100
?>
		real minB = beta0;
<?			for j=1,stencilSize-1 do
?>		minB = min(minB, beta<?=j?>);
<?			end
?>
		real maxB = beta0;
<?			for j=1,stencilSize-1 do
?>		maxB = max(maxB, beta<?=j?>);
<?			end
?>
		real R0 = minB / (maxB + <?=epsilon?>);

<? 			for i=0,stencilSize-1 do
?>		real alpha<?=i?> = <?=clnumber(d[d0 + i * dd])?> / sqr(<?=epsilon?> + beta<?=i?> + R0 * <?=shen_zha_A?> * minB);
<?	 		end
		else
			error("unknown wenoMethod "..tostring(solver.wenoMethod))
		end
?>
<?		for i=0,stencilSize-1 do
?>		real vs<?=i?> = 0.<?
			for j=0,stencilSize-1 do ?>
			+ <?=clnumber(a[ak0+akd*i][al0+ald*j])?> * v[<?=i+j?>].ptr[k]<?
			end ?>;
<? 		end
?>
		real alphasum = 0.<? for i=0,stencilSize-1 do ?> + alpha<?=i?><? end ?>;

		result.ptr[k] = (0.<?
		for i=0,stencilSize-1 do ?>
			+ alpha<?=i?> * vs<?=i?><?
		end ?>
		) / alphasum;
	}
	return result;
}
<? 	end
end
?>

}	// namespace <?=Equation?>

//// MODULE_NAME: calcCellFlux
//// MODULE_DEPENDS: <?=Equation?>

kernel void calcCellFlux(
	constant <?=solver_t?> const * const psolver,
	global <?=cell_t?> const * const cellBuf,
	global <?=cons_t?> * const fluxCellBuf,
	global <?=cons_t?> const * const UBuf
) {
	using namespace <?=Equation?>;
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(0,0);
	auto const & U = UBuf[index];
	auto const & cell = cellBuf[index];
	<? for side=0,solver.dim-1 do ?>{
		real3 xInt = cell.pos; xInt[<?=side?>] -= .5 * solver.grid_dx[<?=side?>];
		fluxCellBuf[<?=side?> + dim * index] = Eqn::fluxFromCons(
			solver,
			U,
			cell,
			Normal::forSide<?=side?>(xInt);
		);	// xInt or cell->pos?  U is based on cell->pos, but the dest flux is xInt
	}<? end ?>
}

//// MODULE_NAME: <?=calcFlux?>
//// MODULE_DEPENDS: <?=Equation?> weno_l/r

kernel void <?=calcFlux?>(
	constant <?=solver_t?> const * const psolver,
	global <?=cons_t?> * const fluxBuf,
	global <?=cons_t?> const * const UBuf/*<?=solver.getULRArg?> ... but why use getULR when we're using WENO? */,
	global <?=cell_t?> const * const cellBuf
) {
	using namespace <?=Equation?>;
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(solver.numGhost, solver.numGhost-1);

	real3 const xR = cellBuf[index].pos;
	auto const * const U = UBuf + index;
	auto const * const cell = cellBuf + index;
	<?
for side=0,solver.dim-1 do ?>{
		int const side = <?=side?>;

		int const indexL = index - solver.stepsize[<?=side?>];
		int const indexR = index;

#if 0
		<?=solver:getULRCode():gsub("\n", "\n\t\t")?>
#else
		auto const & UL = UBuf[indexL];
		auto const & UR = UBuf[indexR];
#endif

		auto const & cellL = cellBuf[indexL];
		auto const & cellR = cellBuf[indexR];

		real3 xInt = xR; xInt[<?=side?>] -= .5 * solver.grid_dx[<?=side?>];

		auto const n = Normal::forSide<<?=side?>>(xInt);

		int const fluxIndexInt = side + dim * index;
		auto & flux = fluxBuf[fluxIndexInt];

<?

	if solver.fluxMethod == "Lax-Friedrichs" then

?>
		auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);
		real maxAbsLambda = 0.;
		for (int j = 0; j < <?=2*stencilSize?>; ++j) {
			real lambdaMin, lambdaMax;
			Eqn::consWaveCodeMinMax(
				solver, 
				U[(j - <?=stencilSize?>) * solver.stepsize[<?=side?>]],
				n,
				xInt,
				&lambdaMin,
				&lambdaMax);
			maxAbsLambda = max(maxAbsLambda, fabs(lambdaMin));
			maxAbsLambda = max(maxAbsLambda, fabs(lambdaMax));
		}

<?
		for j=0,2*stencilSize-1 do
?>
		int const offset<?=j?> = <?=j - stencilSize?> * solver.stepsize[<?=side?>];
		auto const & U<?=j?> = U[offset<?=j?>];
		auto const & cell<?=j?> = cell[offset<?=j?>];
		//auto> F<?=j?> = fluxCellBuf[<?=side?> + dim * (index + <?=j - stencilSize?> * solver.stepsize[<?=side?>])];
		auto F<?=j?> = Eqn::fluxFromCons(solver, U<?=j?>, cell<?=j?>, n);
<?
			if j < 2*stencilSize-1 then
?>		Cons fp<?=j?>;
		for (int k = 0; k < numStates; ++k) {
			fp<?=j?>.ptr[k] = (F<?=j?>.ptr[k] + maxAbsLambda * U<?=j?>.ptr[k]) * .5;
		}
<?			end

			if j > 0 then
?>		Cons fm<?=j-1?>;
		for (int k = 0; k < numStates; ++k) {
			fm<?=j-1?>.ptr[k] = (F<?=j?>.ptr[k] - maxAbsLambda * U<?=j?>.ptr[k]) * .5;
		}
<?			end
		end
?>
		Waves afp[<?=2*stencilSize-1?>] = {
<? 		for j=0,2*stencilSize-2 do
?>			Eqn::eigen_leftTransform(solver, eig, fp<?=j?>, xInt, n),
<?		end
?>		};
		Waves afm[<?=2*stencilSize-1?>] = {
<?		for j=0,2*stencilSize-2 do
?>			Eqn::eigen_leftTransform(solver, eig, fm<?=j?>, xInt, n),
<? 		end
?>		};

		Waves wafp = weno_r_<?=side?>(afp);
		Waves wafm = weno_l_<?=side?>(afm);

		Waves waf;
		for (int j = 0; j < numWaves; ++j) {
			waf.ptr[j] = wafp.ptr[j] + wafm.ptr[j];
		}

		flux = Eqn::eigen_rightTransform(solver, eig, waf, xInt, n);
<?

	elseif solver.fluxMethod == "Marquina" then

?>
		auto eigL = Eqn::eigen_forCell(solver, UL, cellL, n);
		auto eigR = Eqn::eigen_forCell(solver, UR, cellR, n);

		real lambdaL[numWaves];
		real lambdaR[numWaves];
		<? for _,lr in ipairs{"L", "R"} do ?>{
			auto calcWaves = Eqn::EigenWaveCode(solver, eig<?=lr?>, n, xInt);
			for (int k = 0; k < numWaves; ++k) {
				// TODO this was 'U', but the CodePrefix was &eig ... so ... which is it?
				lambda<?=lr?>[k] = calcWaves(solver, eig<?=lr?>, n, xInt, k);
			}
		}<? end ?>

<? 		for j=0,2*stencilSize-2 do
?>		int const offset<?=j?> = (<?=j - stencilSize?>) * solver.stepsize[<?=side?>];
		auto const & U<?=j?> = U[offset<?=j?>];
		auto const & cell<?=j?> = cell[offset<?=j?>];
		auto F<?=j?> = Eqn::fluxFromCons(solver, U<?=j?>, cell<?=j?>, n);
		Waves al<?=j?> = Eqn::eigen_leftTransform(solver, eigL, U<?=j?>, xInt, n);
		Waves ar<?=j?> = Eqn::eigen_leftTransform(solver, eigR, U<?=j?>, xInt, n);
		Waves afl<?=j?> = Eqn::eigen_leftTransform(solver, eigL, F<?=j?>, xInt, n);
		Waves afr<?=j?> = Eqn::eigen_leftTransform(solver, eigR, F<?=j?>, xInt, n);

<?		end
?>

		Waves afp[<?=2*stencilSize-1?>], afm[<?=2*stencilSize-1?>];
		for (int k = 0; k < numWaves; ++k) {
			if (lambdaL[k] > 0.0 && lambdaR[k] > 0.0) {
<?				for j=0,2*stencilSize-2 do
?>				afp[<?=j?>].ptr[k] = afl<?=j?>.ptr[k];
				afm[<?=j?>].ptr[k] = 0;
<?				end
?>			} else if (lambdaL[k] < 0.0 && lambdaR[k] < 0.0) {
<?				for j=0,2*stencilSize-2 do
?>				afp[<?=j?>].ptr[k] = 0;
				afm[<?=j?>].ptr[k] = afr<?=j?>.ptr[k];
<?				end
?>			} else {
				real absLambdaL = fabs(lambdaL[k]);
				real absLambdaR = fabs(lambdaR[k]);
				real a, absa;
				if (absLambdaL > absLambdaR) {
					a = lambdaL[k];
					absa = absLambdaL;
				} else {
					a = lambdaR[k];
					absa = absLambdaR;
				}
<?				for j=0,2*stencilSize-2 do
?>				afp[<?=j?>].ptr[k] = .5 * (afl<?=j?>.ptr[k] + absa * al<?=j?>.ptr[k]);
				afm[<?=j?>].ptr[k] = .5 * (afr<?=j?>.ptr[k] - absa * ar<?=j?>.ptr[k]);
<?				end
?>			}
		}

		Waves wafp = weno_r_<?=side?>(afp);
		auto fluxP = Eqn::eigen_rightTransform(solver, eigL, wafp, xInt, n);

		Waves wafm = weno_l_<?=side?>(afm);
		auto fluxM = Eqn::eigen_rightTransform(solver, eigR, wafm, xInt, n);

		for (int j = 0; j < numIntStates; ++j) {
			flux.ptr[j] = fluxP.ptr[j] + fluxM.ptr[j];
		}
<?

	elseif solver.fluxMethod == "Roe" then

		-- TODO make the following its own function, maybe in solver/roe.cl or solver/roe.lua
		-- so we can call a function instead of copy/paste
		-- but this means making it a function of the lua parameters, like flux limiter.
		-- and a flux limiter means +1 to the numGhost
?>

		auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);

		Waves afp[<?=2*stencilSize-1?>], afm[<?=2*stencilSize-1?>];
<?		for j=0,2*stencilSize-2 do
?>
		{
			int const offsetL<?=j?> = <?=j - stencilSize?> * solver.stepsize[<?=side?>];
			int const offsetR<?=j?> = <?=j+1 - stencilSize?> * solver.stepsize[<?=side?>];

			auto const & UL<?=j?> = U[offsetL<?=j?>];
			auto const & UR<?=j?> = U[offsetR<?=j?>];

			auto const & cellL<?=j?> = cell[offsetL<?=j?>];
			auto const & cellR<?=j?> = cell[offsetR<?=j?>];

			//should we only use a single 'eig'?  seems errors pop up when I use the 'eig' at each interface along the stencil
			//auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);

			auto calcWaves = Eqn::EigenWaveCode(solver, eig, n, xInt);

			Cons UAvg;
			for (int k = 0; k < numIntStates; ++k) {
				UAvg.ptr[k] = .5 * (UL<?=j?>.ptr[k] + UR<?=j?>.ptr[k]);
			}
			afp[<?=j?>] = afm[<?=j?>] = Eqn::eigen_leftTransform(solver, eig, UAvg, xInt, n);

			Cons deltaU;
			for (int k = 0; k < numStates; ++k) {
				deltaU.ptr[k] = UR<?=j?>.ptr[k] - UL<?=j?>.ptr[k];
			}

			Waves deltaUEig = Eqn::eigen_leftTransform(solver, eig, deltaU, xInt, n);

			for (int k = 0; k < numWaves; ++k) {
				real const lambda = calcWaves(solver, eig, n, xInt, k);
				real lambdaPlus = max(lambda, 0.);
				real lambdaMinus = min(lambda, 0.);

				afp[<?=j?>].ptr[k] *= lambdaPlus;
				afm[<?=j?>].ptr[k] *= lambdaMinus;
				real sgnLambda = lambda >= 0 ? 1 : -1;
				afp[<?=j?>].ptr[k] -= .5 * lambdaPlus * deltaUEig.ptr[k] * sgnLambda;
				afm[<?=j?>].ptr[k] -= .5 * lambdaMinus * deltaUEig.ptr[k] * sgnLambda;
			}
		}
<?
		end
?>
		Waves wafp = weno_r_<?=side?>(afp);
		Waves wafm = weno_l_<?=side?>(afm);
		Waves waf;
		for (int j = 0; j < numWaves; ++j) {
			waf.ptr[j] = wafp.ptr[j] + wafm.ptr[j];
		}

		flux = Eqn::eigen_rightTransform(solver, eig, waf, xInt, n);
<?

	else
		error("unknown fluxMethod "..tostring(solver.fluxMethod))
	end
?>	}<?
end ?>
}
