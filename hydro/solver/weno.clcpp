//// MODULE_NAME: weno_l/r
//// MODULE_DEPENDS: sqr <?=Equation?>

namespace <?=Equation?> {

<?
local clnumber = require "cl.obj.number"

local stencilSize = solver.stencilSize
local coeffs = solver.coeffs

local coeff = coeffs[stencilSize]
local a = coeff.a
local d = coeff.d
local betaCoeffs = coeff.betaCoeffs
?>

constexpr int stencilSize = <?=stencilSize?>;

<?
for side=0,solver.dim-1 do
	for _,l_or_r in ipairs{"l", "r"} do
		local ak0 = l_or_r == "l" and stencilSize or 1
		local akd = l_or_r == "l" and -1 or 1
		local al0 = l_or_r == "l" and stencilSize or 1
		local ald = l_or_r == "l" and -1 or 1
		local d0 = l_or_r == "l" and stencilSize or 1
		local dd = l_or_r == "l" and -1 or 1

-- how should I generalize this?
-- base pointer
-- number of cells (stencilSize)
-- number of coefficients at each cell ... or what C type it is, and how many variables to cycle across in the ptr field
-- ... or we can just always perform this interpolation in cons/char space
?>
Waves weno_<?=l_or_r?>_<?=side?>(
	Waves const * const v
) {
	Waves result;
	for (int k = 0; k < numWaves; ++k) {
		real beta[stencilSize];
<? 		for j=0,stencilSize-1 do
?>		beta[<?=j?>] = 0.;
<?			for m=0,stencilSize-1 do
				for n=0,m do ?>
		beta[<?=j?>] += <?=clnumber(betaCoeffs[j+1][m+1][n+1])?> * v[<?=j+m?>][k] * v[<?=j+n?>][k];
<?				end
			end
		end

		if solver.wenoMethod == "1996 Jiang Shu" then 		-- WENO-JS
?>		//constexpr real epsilon = 1e-14;
		constexpr real epsilon = 1e-6;

		real alpha[stencilSize];
<? 			for i=0,stencilSize-1 do
?>		alpha[<?=i?>] = <?=clnumber(d[d0 + i * dd])?> / sqr(epsilon + beta[<?=i?>]);
<? 			end

		elseif solver.wenoMethod == "2008 Borges" then 	-- WENO-Z
?>		constexpr real epsilon = 1e-6;
<?
			-- TODO different coeffs of betas?
			if false then 	--if stencilSize == 4 then -- for 2016 Rathan, it suggests these:
?>		real tau = fabs(beta[0] + 3. * beta[1] - 3. * beta[2] - beta[3]);
<?			else	-- for weno7, 2018 Zeytinoglu suggests this:
?>		real tau = fabs(beta[0] - beta[<?=stencilSize-1?>]);
<?			end
?>
		real alpha[stencilSize];
<?			for i=0,stencilSize-1 do
?>		alpha[<?=i?>] = <?=clnumber(d[d0 + i * dd])?> * (1. + (tau / (beta[<?=i?>] + epsilon)));
<? 			end

		elseif solver.wenoMethod == "2010 Shen Zha" then -- WENO-BS?
?>		constexpr real epsilon = 1e-10;

		// TODO find these for other order WENO's
		constexpr real shen_zha_A = 50;	// 0-100

		real minB = beta[0];
		real maxB = beta[0];
		for (int j = 1; j < stencilSize; ++j) {
			minB = min(minB, beta[j]);
			maxB = max(maxB, beta[j]);
		}
		
		real R0 = minB / (maxB + epsilon);

		real alpha[stencilSize];
<? 			for i=0,stencilSize-1 do
?>		alpha[<?=i?>] = <?=clnumber(d[d0 + i * dd])?> / sqr(epsilon + beta[<?=i?>] + R0 * shen_zha_A * minB);
<?	 		end
		else
			error("unknown wenoMethod "..tostring(solver.wenoMethod))
		end
?>
		real vs[stencilSize];
<?		for i=0,stencilSize-1 do
?>		vs[<?=i?>] = 0.<?
			for j=0,stencilSize-1 do ?>
			+ <?=clnumber(a[ak0+akd*i][al0+ald*j])?> * v[<?=i+j?>][k]<?
			end ?>;
<? 		end
?>
		
		real alphasum = 0;
		for (int i = 0; i < stencilSize; ++i) {
			alphasum += alpha[i];
		}

		result[k] = 0;
		for (int i = 0; i < stencilSize; ++i) {
			result[k] += alpha[i] * vs[i];
		}
		result[k] /= alphasum;
	}
	return result;
}
<? 	end
end
?>

// is supposed to be a subclass of FVSolver
// but right now the Solver C++ code and the solver_t code are uncoupled anyways
// and I don't have vtables anywhere (can I even?)
// so ...
struct WENOSolver {
	static inline void calcFlux(
		constant Solver const & solver,
		global Cons * const fluxBuf,
		global Cons const * const UBuf/*<?=solver.getULRArg?> ... but why use getULR when we're using WENO? */,
		global Cell const * const cellBuf

	) {
		<?=SETBOUNDS?>(solver.numGhost, solver.numGhost-1);

		real3 const xR = cellBuf[index].pos;
		auto const * const U = UBuf + index;
		auto const * const cell = cellBuf + index;
		<? for side=0,solver.dim-1 do ?>{
			int const side = <?=side?>;

			int const indexL = index - solver.stepsize[<?=side?>];
			int const indexR = index;

#if 0
			<?=solver:getULRCode():gsub("\n", "\n\t\t")?>
#else
			auto const & UL = UBuf[indexL];
			auto const & UR = UBuf[indexR];
#endif

			auto const & cellL = cellBuf[indexL];
			auto const & cellR = cellBuf[indexR];

			real3 xInt = xR; xInt[<?=side?>] -= .5 * solver.grid_dx[<?=side?>];

			auto const n = Normal::forSide<<?=side?>>(xInt);

			int const fluxIndexInt = side + dim * index;
			auto & flux = fluxBuf[fluxIndexInt];

<?

	if solver.fluxMethod == "Lax-Friedrichs" then

?>
			auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);
			real maxAbsLambda = 0.;
			for (int j = 0; j < <?=2*stencilSize?>; ++j) {
				real lambdaMin, lambdaMax;
				Eqn::consWaveCodeMinMax(
					solver, 
					U[(j - <?=stencilSize?>) * solver.stepsize[<?=side?>]],
					n,
					xInt,
					&lambdaMin,
					&lambdaMax);
				maxAbsLambda = max(maxAbsLambda, fabs(lambdaMin));
				maxAbsLambda = max(maxAbsLambda, fabs(lambdaMax));
			}

<?
		for j=0,2*stencilSize-1 do
?>
			int const offset<?=j?> = <?=j - stencilSize?> * solver.stepsize[<?=side?>];
			auto const & U<?=j?> = U[offset<?=j?>];
			auto const & cell<?=j?> = cell[offset<?=j?>];
			//auto> F<?=j?> = fluxCellBuf[<?=side?> + dim * (index + <?=j - stencilSize?> * solver.stepsize[<?=side?>])];
			auto F<?=j?> = Eqn::fluxFromCons(solver, U<?=j?>, cell<?=j?>, n);
<?			if j < 2*stencilSize-1 then ?>
			Cons fp<?=j?>;
			for (int k = 0; k < numStates; ++k) {
				fp<?=j?>[k] = (F<?=j?>[k] + maxAbsLambda * U<?=j?>[k]) * .5;
			}
<?			end
			if j > 0 then
?>
			Cons fm<?=j-1?>;
			for (int k = 0; k < numStates; ++k) {
				fm<?=j-1?>[k] = (F<?=j?>[k] - maxAbsLambda * U<?=j?>[k]) * .5;
			}
<?			end
		end
?>
			Waves afp[<?=2*stencilSize-1?>] = {
<? 		for j=0,2*stencilSize-2 do
?>				Eqn::eigen_leftTransform(solver, eig, fp<?=j?>, xInt, n),
<?		end
?>			};
			Waves afm[<?=2*stencilSize-1?>] = {
<?		for j=0,2*stencilSize-2 do
?>				Eqn::eigen_leftTransform(solver, eig, fm<?=j?>, xInt, n),
<? 		end
?>			};

			Waves wafp = weno_r_<?=side?>(afp);
			Waves wafm = weno_l_<?=side?>(afm);

			Waves waf;
			for (int j = 0; j < numWaves; ++j) {
				waf[j] = wafp[j] + wafm[j];
			}

			flux = Eqn::eigen_rightTransform(solver, eig, waf, xInt, n);
<?

	elseif solver.fluxMethod == "Marquina" then

?>
			auto eigL = Eqn::eigen_forCell(solver, UL, cellL, n);
			auto eigR = Eqn::eigen_forCell(solver, UR, cellR, n);

			real lambdaL[numWaves];
			real lambdaR[numWaves];
			<? for _,lr in ipairs{"L", "R"} do ?>{
				auto calcWaves = Eqn::EigenWaveCode(solver, eig<?=lr?>, n, xInt);
				for (int k = 0; k < numWaves; ++k) {
					// TODO this was 'U', but the CodePrefix was &eig ... so ... which is it?
					lambda<?=lr?>[k] = calcWaves(solver, eig<?=lr?>, n, xInt, k);
				}
			}<? end ?>

<? 		for j=0,2*stencilSize-2 do
?>		
			int const offset<?=j?> = (<?=j - stencilSize?>) * solver.stepsize[<?=side?>];
			auto const & U<?=j?> = U[offset<?=j?>];
			auto const & cell<?=j?> = cell[offset<?=j?>];
			auto F<?=j?> = Eqn::fluxFromCons(solver, U<?=j?>, cell<?=j?>, n);
			Waves al<?=j?> = Eqn::eigen_leftTransform(solver, eigL, U<?=j?>, xInt, n);
			Waves ar<?=j?> = Eqn::eigen_leftTransform(solver, eigR, U<?=j?>, xInt, n);
			Waves afl<?=j?> = Eqn::eigen_leftTransform(solver, eigL, F<?=j?>, xInt, n);
			Waves afr<?=j?> = Eqn::eigen_leftTransform(solver, eigR, F<?=j?>, xInt, n);

<?		end
?>

			Waves afp[<?=2*stencilSize-1?>], afm[<?=2*stencilSize-1?>];
			for (int k = 0; k < numWaves; ++k) {
				if (lambdaL[k] > 0.0 && lambdaR[k] > 0.0) {
<?				for j=0,2*stencilSize-2 do ?>
					afp[<?=j?>][k] = afl<?=j?>[k];
					afm[<?=j?>][k] = 0;
<?				end
?>				} else if (lambdaL[k] < 0.0 && lambdaR[k] < 0.0) {
<?				for j=0,2*stencilSize-2 do ?>
					afp[<?=j?>][k] = 0;
					afm[<?=j?>][k] = afr<?=j?>[k];
<?				end ?>
				} else {
					real absLambdaL = fabs(lambdaL[k]);
					real absLambdaR = fabs(lambdaR[k]);
					real a, absa;
					if (absLambdaL > absLambdaR) {
						a = lambdaL[k];
						absa = absLambdaL;
					} else {
						a = lambdaR[k];
						absa = absLambdaR;
					}
<?				for j=0,2*stencilSize-2 do
?>					afp[<?=j?>][k] = .5 * (afl<?=j?>[k] + absa * al<?=j?>[k]);
					afm[<?=j?>][k] = .5 * (afr<?=j?>[k] - absa * ar<?=j?>[k]);
<?				end
?>				}
			}

			Waves wafp = weno_r_<?=side?>(afp);
			auto fluxP = Eqn::eigen_rightTransform(solver, eigL, wafp, xInt, n);

			Waves wafm = weno_l_<?=side?>(afm);
			auto fluxM = Eqn::eigen_rightTransform(solver, eigR, wafm, xInt, n);

			for (int j = 0; j < numIntStates; ++j) {
				flux[j] = fluxP[j] + fluxM[j];
			}
<?

	elseif solver.fluxMethod == "Roe" then

		-- TODO make the following its own function, maybe in solver/roe.cl or solver/roe.lua
		-- so we can call a function instead of copy/paste
		-- but this means making it a function of the lua parameters, like flux limiter.
		-- and a flux limiter means +1 to the numGhost
?>

			auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);

			Waves afp[<?=2*stencilSize-1?>], afm[<?=2*stencilSize-1?>];
<?		for j=0,2*stencilSize-2 do
?>
			{
				int const offsetL<?=j?> = <?=j - stencilSize?> * solver.stepsize[<?=side?>];
				int const offsetR<?=j?> = <?=j+1 - stencilSize?> * solver.stepsize[<?=side?>];

				auto const & UL<?=j?> = U[offsetL<?=j?>];
				auto const & UR<?=j?> = U[offsetR<?=j?>];

				auto const & cellL<?=j?> = cell[offsetL<?=j?>];
				auto const & cellR<?=j?> = cell[offsetR<?=j?>];

				//should we only use a single 'eig'?  seems errors pop up when I use the 'eig' at each interface along the stencil
				//auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);

				auto calcWaves = Eqn::EigenWaveCode(solver, eig, n, xInt);

				Cons UAvg;
				for (int k = 0; k < numIntStates; ++k) {
					UAvg[k] = .5 * (UL<?=j?>[k] + UR<?=j?>[k]);
				}
				afp[<?=j?>] = afm[<?=j?>] = Eqn::eigen_leftTransform(solver, eig, UAvg, xInt, n);

				Cons deltaU;
				for (int k = 0; k < numStates; ++k) {
					deltaU[k] = UR<?=j?>[k] - UL<?=j?>[k];
				}

				Waves deltaUEig = Eqn::eigen_leftTransform(solver, eig, deltaU, xInt, n);

				for (int k = 0; k < numWaves; ++k) {
					real const lambda = calcWaves(solver, eig, n, xInt, k);
					real lambdaPlus = max(lambda, 0.);
					real lambdaMinus = min(lambda, 0.);

					afp[<?=j?>][k] *= lambdaPlus;
					afm[<?=j?>][k] *= lambdaMinus;
					real sgnLambda = lambda >= 0 ? 1 : -1;
					afp[<?=j?>][k] -= .5 * lambdaPlus * deltaUEig[k] * sgnLambda;
					afm[<?=j?>][k] -= .5 * lambdaMinus * deltaUEig[k] * sgnLambda;
				}
			}
<?
		end
?>
			Waves wafp = weno_r_<?=side?>(afp);
			Waves wafm = weno_l_<?=side?>(afm);
			Waves waf;
			for (int j = 0; j < numWaves; ++j) {
				waf[j] = wafp[j] + wafm[j];
			}

			flux = Eqn::eigen_rightTransform(solver, eig, waf, xInt, n);
<?

	else
		error("unknown fluxMethod "..tostring(solver.fluxMethod))
	end
?>		}<?
end ?>

	}
};

}	// namespace <?=Equation?>

//// MODULE_NAME: calcCellFlux
//// MODULE_DEPENDS: <?=Equation?>

kernel void calcCellFlux(
	constant <?=solver_t?> const * const psolver,
	global <?=cell_t?> const * const cellBuf,
	global <?=cons_t?> * const fluxCellBuf,
	global <?=cons_t?> const * const UBuf
) {
	using namespace <?=Equation?>;
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(0,0);
	auto const & U = UBuf[index];
	auto const & cell = cellBuf[index];
	<? for side=0,solver.dim-1 do ?>{
		real3 xInt = cell.pos; xInt[<?=side?>] -= .5 * solver.grid_dx[<?=side?>];
		fluxCellBuf[<?=side?> + dim * index] = Eqn::fluxFromCons(
			solver,
			U,
			cell,
			Normal::forSide<?=side?>(xInt);
		);	// xInt or cell->pos?  U is based on cell->pos, but the dest flux is xInt
	}<? end ?>
}

//// MODULE_NAME: <?=calcFlux?>
//// MODULE_DEPENDS: <?=Equation?> weno_l/r

kernel void <?=calcFlux?>(
	constant <?=solver_t?> const * const psolver,
	global <?=cons_t?> * const fluxBuf,
	global <?=cons_t?> const * const UBuf/*<?=solver.getULRArg?> ... but why use getULR when we're using WENO? */,
	global <?=cell_t?> const * const cellBuf
) {
	using namespace <?=Equation?>;
	auto const & solver = *psolver;
	WENOSolver::calcFlux(solver, fluxBuf, UBuf, cellBuf);
}
