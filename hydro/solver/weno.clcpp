//// MODULE_NAME: weno_l/r
//// MODULE_DEPENDS: sqr <?=Solver?>

<?
local clnumber = require "cl.obj.number"
local stencilSize = solver.stencilSize
?>

namespace <?=Solver?> {

template<int stencilSize>
struct WENOCoeffs {};

// [r] of table 1 of 1996 Jiang, Shu
template<>
struct WENOCoeffs<2> {
	static constexpr real d[2] = {1/3, 2/3};
	// coeffs[r].a[k][l] == a^r_k,l of table 1 of 1996 Jiang, Shu
	static constexpr real a[2][2] = {
		{-1/2,	3/2,	},
		{1/2,	1/2,	},
	};
	static constexpr real beta[2][2][2] = {
		{
			{1,		0},
			{-2,	1},
		}, {
			{1,		0},
			{-2,	1},
		},
	};
};

template<>
struct WENOCoeffs<3> {
#if 1	
	constant static constexpr real d[3] = {1/10, 6/10, 3/10};
	constant static constexpr real a[3][3] = {
		{ 2/6,	-7/6, 11/6, },
		{-1/6,	 5/6,  2/6, },
		{ 2/6,	 5/6, -1/6, },
	};
#endif
#if 0	// which paper is this from?
	constant static constexpr real d[3] = {1/16,	10/16,	5/16};
	constant static constexpr real a[3][3] = {
		{3/8,	-10/8,	15/8},
		{-1/8,	6/8,	3/8},
		{3/8,	6/8,	-1/8},
	};
#endif
	constant static constexpr real beta[3][3][3] = {
		{
			{4/3, 0, 0},
			{-19/3,	25/3, 0},
			{11/3,	-31/3,	10/3},
		}, {
			{4/3, 0, 0},
			{-13/3,	13/3, 0},
			{5/3,	-13/3,	4/3},
		}, {
			{10/3, 0, 0},
			{-31/3,	25/3, 0},
			{11/3,	-19/3,	4/3},
		},
	};
};

template<>
struct WENOCoeffs<4> {
	static constexpr real d[4] = {1/35, 12/35, 18/35, 4/35};
	static constexpr real a[4][4] = {
		{-3/12, 13/12, -23/12, 25/12, },
		{ 1/12, -5/12,  13/12,  3/12, },
		{-1/12,  7/12,   7/12, -1/12, },
		{ 3/12, 13/12,  -5/12,  1/12, },
	};
	static constexpr real beta[4][4][4] = {
#if 0
		{
			{ 2107/240},
			{-9402/240,  11003/240},
			{ 7042/240, -17246/240,   7043/240},
			{-1854/240,   4642/240,  -3882/240,    547/240},
		},
		{
			{  547/240},
			{-2522/240,   3443/240},
			{ 1922/240,  -5966/240,   2843/240},
			{ -494/240,   1602/240,  -1642/240,    267/240},
		},
		{
			{  267/240},
			{-1642/240,   2843/240},
			{ 1602/240,  -5966/240,   3443/240},
			{ -494/240,   1922/240,  -2522/240,    547/240},
		},
		{
			{  547/240},
			{-3882/240,   7043/240},
			{ 4642/240, -17246/240,  11003/240},
			{-1854/240,   7042/240,  -9402/240,   2107/240},
		},
#endif
#if 1 //2016 Rathan, Raju after eqn 12 ...
// https://github.com/wme7/WENO7-Z/blob/master/WENO7ZresAdv1d.m
		{
			{  6649, 0, 0, 0},
			{-47214,	  85641, 0, 0},
			{ 56694,	-210282,	134241, 0},
			{-22778,	  86214,	-114894,	25729},
		},
		{
			{  3169, 0, 0, 0},
			{-19374,	 33441, 0, 0},
			{ 19014,	-70602,	 41001, 0},
			{ -5978,	 23094,	-30414,	6649},
		},
		{
			{  6649, 0, 0, 0},
			{-30414,	 41001, 0, 0},
			{ 23094,	-70602,	 33441, 0},
			{ -5978,	 19014,	-19374,	3169},
		},
		{
			{  25729, 0, 0, 0},
			{-114894,	134241, 0, 0},
			{  86214,	-210282,	85641, 0},
			{ -22778,	  56694,	-47214,	6649},
		},
#endif
	};
};

template<>
struct WENOCoeffs<5> {
	static constexpr real d[5] = {  1/126,  20/126,  60/126,  40/126,   5/126 };
	static constexpr real a[5][5] = {
		{12/60, -63/60, 137/60, -163/60, 137/60, },
		{-3/60,  17/60, -43/60,   77/60,  12/60, },
		{ 2/60, -13/60,  47/60,   27/60,  -3/60, },
		{-3/60,  27/60,  47/60,  -13/60,   2/60, },
		{12/60,  77/60, -43/60,   17/60,  -3/60, },
	};
	static constexpr real beta[5][5][5] = {
		{
			{  107918/5040, 0,0,0,0},
			{ -649501/5040,  1020563/5040, 0,0,0},
			{  758823/5040, -2462076/5040,  1521393/5040, 0,0},
			{ -411487/5040,  1358458/5040, -1704396/5040,   482963/5040, 0},
			{   86329/5040,  -288007/5040,   364863/5040,  -208501/5040,    22658/5040},
		},
		{
			{   22658/5040, 0,0,0,0},
			{ -140251/5040,   242723/5040, 0,0,0},
			{  165153/5040,  -611976/5040,   406293/5040, 0,0},
			{  -88297/5040,   337018/5040,  -464976/5040,   138563/5040, 0},
			{   18079/5040,   -70237/5040,    99213/5040,   -60871/5040,     6908/5040},
		},
		{
			{    6908/5040, 0,0,0,0},
			{  -51001/5040,   104963/5040, 0,0,0},
			{   67923/5040,  -299076/5040,   231153/5040, 0,0},
			{  -38947/5040,   179098/5040,  -299076/5040,   104963/5040, 0},
			{    8209/5040,   -38947/5040,    67923/5040,   -51001/5040,     6908/5040},
		},
		{
			{    6908/5040, 0,0,0,0},
			{  -60871/5040,   138563/5040, 0,0,0},
			{   99213/5040,  -464976/5040,   406293/5040, 0,0},
			{  -70237/5040,   337018/5040,  -611976/5040,   242723/5040, 0},
			{   18079/5040,   -88297/5040,   165153/5040,  -140251/5040,    22658/5040},
		},
		{
			{   22658/5040, 0,0,0,0},
			{ -208501/5040,   482963/5040, 0,0,0},
			{  364863/5040, -1704396/5040,  1521393/5040, 0,0},
			{ -288007/5040,  1358458/5040, -2462076/5040,  1020563/5040, 0},
			{   86329/5040,  -411487/5040,   758823/5040,  -649501/5040,   107918/5040},
		},
	};
};

template<>
struct WENOCoeffs<6> {
	static constexpr real d[6] = { 1/462,   30/462,  150/462,  200/462,   75/462,    6/462 };
	static constexpr real a[6][6] = {
		{-10/60,  62/60, -163/60, 237/60, -213/60, 147/60, },
		{  2/60, -13/60,   37/60, -63/60,   87/60,  10/60, },
		{ -1/60,   7/60,  -23/60,  57/60,   22/60,  -2/60, },
		{  1/60,  -8/60,   37/60,  37/60,   -8/60,   1/60, },
		{ -2/60,  22/60,   57/60, -23/60,    7/60,  -1/60, },
		{ 10/60,  87/60,  -63/60,  37/60,  -13/60,   2/60, },
	};
	static constexpr real beta[6][6][6] = {
		{
			{   6150211/120960, 0,0,0,0,0},
			{ -47460464/120960,   94851237/120960, 0,0,0,0},
			{  76206736/120960, -311771244/120960,  260445372/120960, 0,0,0},
			{ -63394124/120960,  262901672/120960, -444003904/120960,  190757572/120960, 0,0},
			{  27060170/120960, -113206788/120960,  192596472/120960, -166461044/120960,   36480687/120960, 0},
			{  -4712740/120960,   19834350/120960,  -33918804/120960,   29442256/120960,  -12950184/120960,    1152561/120960,},
		}, {
			{   1152561/120960, 0,0,0,0,0},
			{  -9117992/120960,   19365967/120960, 0,0,0,0},
			{  14742480/120960,  -65224244/120960,   56662212/120960, 0,0,0},
			{ -12183636/120960,   55053752/120960,  -97838784/120960,   43093692/120960, 0,0},
			{   5134574/120960,  -23510468/120960,   42405032/120960,  -37913324/120960,    8449957/120960, 0},
			{   -880548/120960,    4067018/120960,   -7408908/120960,    6694608/120960,   -3015728/120960,     271779/120960,},
		}, {
			{    271779/120960, 0,0,0,0,0},
			{  -2380800/120960,    5653317/120960, 0,0,0,0},
			{   4086352/120960,  -20427884/120960,   19510972/120960, 0,0,0},
			{  -3462252/120960,   17905032/120960,  -35817664/120960,   17195652/120960, 0,0},
			{   1458762/120960,   -7727988/120960,   15929912/120960,  -15880404/120960,    3824847/120960, 0},
			{   -245620/120960,    1325006/120960,   -2792660/120960,    2863984/120960,   -1429976/120960,     139633/120960,},
		}, {
			{    139633/120960, 0,0,0,0,0},
			{  -1429976/120960,    3824847/120960, 0,0,0,0},
			{   2863984/120960,  -15880404/120960,   17195652/120960, 0,0,0},
			{  -2792660/120960,   15929912/120960,  -35817664/120960,   19510972/120960, 0,0},
			{   1325006/120960,   -7727988/120960,   17905032/120960,  -20427884/120960,    5653317/120960, 0},
			{   -245620/120960,    1458762/120960,   -3462252/120960,    4086352/120960,   -2380800/120960,     271779/120960,},
		}, {
			{    271779/120960, 0,0,0,0,0},
			{  -3015728/120960,    8449957/120960, 0,0,0,0},
			{   6694608/120960,  -37913324/120960,   43093692/120960, 0,0,0},
			{  -7408908/120960,   42405032/120960,  -97838784/120960,   56662212/120960, 0,0},
			{   4067018/120960,  -23510468/120960,   55053752/120960,  -65224244/120960,   19365967/120960, 0},
			{   -880548/120960,    5134574/120960,  -12183636/120960,   14742480/120960,   -9117992/120960,    1152561/120960,},
		}, {
			{   1152561/120960, 0,0,0,0,0},
			{ -12950184/120960,   36480687/120960, 0,0,0,0},
			{  29442256/120960, -166461044/120960,  190757572/120960, 0,0,0},
			{ -33918804/120960,  192596472/120960, -444003904/120960,  260445372/120960, 0,0},
			{  19834350/120960, -113206788/120960,  262901672/120960, -311771244/120960,   94851237/120960, 0},
			{  -4712740/120960,   27060170/120960,  -63394124/120960,   76206736/120960,  -47460464/120960,    6150211/120960,},
		},
	};
};

template<>
struct WENOCoeffs<7> {
	static constexpr real d[7] = {  1/1716,   42/1716,  315/1716,  700/1716,  525/1716,  126/1716,    7/1716 };
	static constexpr real a[7][7] = {
		{  60/420, -430/420, 1334/420, -2341/420, 2559/420, -1851/420, 1089/420, },
		{ -10/420,   74/420, -241/420,   459/420, -591/420,   669/420,   60/420, },
		{   4/420,  -31/420,  109/420,  -241/420,  459/420,   130/420,  -10/420, },
		{  -3/420,   25/420, -101/420,   319/420,  214/420,   -38/420,    4/420, },
		{   4/420,  -38/420,  214/420,   319/420, -101/420,    25/420,   -3/420, },
		{ -10/420,  130/420,  459/420,  -241/420,  109/420,   -31/420,    4/420, },
		{  60/420,  669/420, -591/420,   459/420, -241/420,    74/420,  -10/420, },
	};
	static constexpr real beta[7][7][7] = {
		{
			{    7177657304/59875200, 0,0,0,0,0,0},
			{  -68289277071/59875200,   166930543737/59875200, 0,0,0,0,0},
			{  140425750893/59875200,  -698497961463/59875200,   739478564460/59875200, 0,0,0,0},
			{ -158581758572/59875200,   797280592452/59875200, -1701893556420/59875200,   985137198380/59875200, 0,0,0},
			{  102951716988/59875200,  -521329653333/59875200,  1119254208255/59875200, -1301580166020/59875200,   431418789360/59875200, 0,0},
			{  -36253275645/59875200,   184521097818/59875200,  -397822832973/59875200,   464200620612/59875200,  -308564463663/59875200,    55294430841/59875200, 0},
			{    5391528799/59875200,   -27545885877/59875200,    59577262788/59875200,   -69700128812/59875200,    46430779053/59875200,   -16670007831/59875200,     1258225940/59875200},
		}, {
			{    1258225940/59875200, 0,0,0,0,0,0},
			{  -12223634361/59875200,    31090026771/59875200, 0,0,0,0,0},
			{   25299603603/59875200,  -132164397513/59875200,   143344579860/59875200, 0,0,0,0},
			{  -28498553012/59875200,   151212114012/59875200,  -332861569020/59875200,   195601143380/59875200, 0,0,0},
			{   18375686988/59875200,   -98508059523/59875200,   219064013505/59875200,  -259838403420/59875200,    86959466460/59875200, 0,0},
			{   -6414710427/59875200,    34632585198/59875200,   -77574968883/59875200,    92646554652/59875200,   -62392325913/59875200,    11250068787/59875200, 0},
			{     945155329/59875200,    -5128661355/59875200,    11548158588/59875200,   -13862429972/59875200,     9380155443/59875200,    -3397272201/59875200,      257447084/59875200},
		}, {
			{     257447084/59875200, 0,0,0,0,0,0},
			{   -2659103847/59875200,     7257045753/59875200, 0,0,0,0,0},
			{    5684116173/59875200,   -32164185663/59875200,    36922302360/59875200, 0,0,0,0},
			{   -6473137292/59875200,    37531128132/59875200,   -88597133220/59875200,    54531707180/59875200, 0,0,0},
			{    4158865908/59875200,   -24530177853/59875200,    59045150655/59875200,   -74236325220/59875200,    25788772260/59875200, 0,0},
			{   -1432622085/59875200,     8555779674/59875200,   -20891234853/59875200,    26694456132/59875200,   -18869146983/59875200,     3510366201/59875200, 0},
			{     206986975/59875200,    -1247531949/59875200,     3078682188/59875200,    -3982402892/59875200,     2854088973/59875200,    -1077964287/59875200,       84070496/59875200},
		}, {
			{      84070496/59875200, 0,0,0,0,0,0},
			{    -969999969/59875200,     2927992563/59875200, 0,0,0,0,0},
			{    2283428883/59875200,   -14296379553/59875200,    18133963560/59875200, 0,0,0,0},
			{   -2806252532/59875200,    18083339772/59875200,   -47431870620/59875200,    32154783380/59875200, 0,0,0},
			{    1902531828/59875200,   -12546315963/59875200,    33820678305/59875200,   -47431870620/59875200,    18133963560/59875200, 0,0},
			{    -676871859/59875200,     4550242446/59875200,   -12546315963/59875200,    18083339772/59875200,   -14296379553/59875200,     2927992563/59875200, 0},
			{      99022657/59875200,     -676871859/59875200,     1902531828/59875200,    -2806252532/59875200,     2283428883/59875200,     -969999969/59875200,       84070496/59875200},
		}, {
			{      84070496/59875200, 0,0,0,0,0,0},
			{   -1077964287/59875200,     3510366201/59875200, 0,0,0,0,0},
			{    2854088973/59875200,   -18869146983/59875200,    25788772260/59875200, 0,0,0,0},
			{   -3982402892/59875200,    26694456132/59875200,   -74236325220/59875200,    54531707180/59875200, 0,0,0},
			{    3078682188/59875200,   -20891234853/59875200,    59045150655/59875200,   -88597133220/59875200,    36922302360/59875200, 0,0},
			{   -1247531949/59875200,     8555779674/59875200,   -24530177853/59875200,    37531128132/59875200,   -32164185663/59875200,     7257045753/59875200, 0},
			{     206986975/59875200,    -1432622085/59875200,     4158865908/59875200,    -6473137292/59875200,     5684116173/59875200,    -2659103847/59875200,      257447084/59875200},
		}, {
			{     257447084/59875200, 0,0,0,0,0,0},
			{   -3397272201/59875200,    11250068787/59875200, 0,0,0,0,0},
			{    9380155443/59875200,   -62392325913/59875200,    86959466460/59875200, 0,0,0,0},
			{  -13862429972/59875200,    92646554652/59875200,  -259838403420/59875200,   195601143380/59875200, 0,0,0},
			{   11548158588/59875200,   -77574968883/59875200,   219064013505/59875200,  -332861569020/59875200,   143344579860/59875200, 0,0},
			{   -5128661355/59875200,    34632585198/59875200,   -98508059523/59875200,   151212114012/59875200,  -132164397513/59875200,    31090026771/59875200, 0},
			{     945155329/59875200,    -6414710427/59875200,    18375686988/59875200,   -28498553012/59875200,    25299603603/59875200,   -12223634361/59875200,     1258225940/59875200},
		}, {
			{    1258225940/59875200, 0,0,0,0,0,0},
			{  -16670007831/59875200,    55294430841/59875200, 0,0,0,0,0},
			{   46430779053/59875200,  -308564463663/59875200,   431418789360/59875200, 0,0,0,0},
			{  -69700128812/59875200,   464200620612/59875200, -1301580166020/59875200,   985137198380/59875200, 0,0,0},
			{   59577262788/59875200,  -397822832973/59875200,  1119254208255/59875200, -1701893556420/59875200,   739478564460/59875200, 0,0,},
			{  -27545885877/59875200,   184521097818/59875200,  -521329653333/59875200,   797280592452/59875200,  -698497961463/59875200,   166930543737/59875200, 0},
			{    5391528799/59875200,   -36253275645/59875200,   102951716988/59875200,  -158581758572/59875200,   140425750893/59875200,   -68289277071/59875200,     7177657304/59875200},
		},
	};
};

constexpr int stencilSize = <?=solver.stencilSize?>;

struct WenoL {
	static constexpr int ak0 = stencilSize-1;
	static constexpr int akd = -1;
	static constexpr int al0 = stencilSize-1;
	static constexpr int ald = -1;
	static constexpr int d0 = stencilSize-1;
	static constexpr int dd = -1;
};

struct WenoR {
	static constexpr int ak0 = 0;
	static constexpr int akd = 1;
	static constexpr int al0 = 0;
	static constexpr int ald = 1;
	static constexpr int d0 = 0;
	static constexpr int dd = 1;
};


<?
local coeffs = solver.coeffs
local coeff = coeffs[stencilSize]
local a = coeff.a
local d = coeff.d
local betaCoeffs = coeff.betaCoeffs

for _,l_or_r in ipairs{"l", "r"} do
	local ak0 = l_or_r == "l" and stencilSize or 1
	local akd = l_or_r == "l" and -1 or 1
	local al0 = l_or_r == "l" and stencilSize or 1
	local ald = l_or_r == "l" and -1 or 1
	local d0 = l_or_r == "l" and stencilSize or 1
	local dd = l_or_r == "l" and -1 or 1
?>

// how should I generalize this?
// base pointer
// number of cells (stencilSize)
// number of coefficients at each cell ... or what C type it is, and how many variables to cycle across in the ptr field
// ... or we can just always perform this interpolation in cons/char space
Waves weno_<?=l_or_r?>(
	Waves const * const v
) {
	using Coeffs = WENOCoeffs<stencilSize>;
	using LR = Weno<?=l_or_r:upper()?>;
	Waves result;
	for (int k = 0; k < numWaves; ++k) {
		real beta[stencilSize];
<? 	for j=0,stencilSize-1 do
?>		beta[<?=j?>] = 0.;
<?		for m=0,stencilSize-1 do
			for n=0,m do ?>
		// works with inline'd coeffs
		beta[<?=j?>] += <?=clnumber(betaCoeffs[j+1][m+1][n+1])?> * v[<?=j+m?>][k] * v[<?=j+n?>][k];
		// doens't work with static constexpr arrays ...
		//beta[<?=j?>] += Coeffs::beta[<?=j?>][<?=m?>][<?=n?>] * v[<?=j+m?>][k] * v[<?=j+n?>][k];
<?			end
		end
	end

	if solver.wenoMethod == "1996 Jiang Shu" then 		-- WENO-JS
?>		//constexpr real epsilon = 1e-14;
		constexpr real epsilon = 1e-6;

		real alpha[stencilSize];
<? 		for i=0,stencilSize-1 do
?>		alpha[<?=i?>] = <?=clnumber(d[d0 + i * dd])?> / sqr(epsilon + beta[<?=i?>]);
<? 		end

	elseif solver.wenoMethod == "2008 Borges" then 	-- WENO-Z
?>		constexpr real epsilon = 1e-6;
<?
		-- TODO different coeffs of betas?
		if false then 	--if stencilSize == 4 then -- for 2016 Rathan, it suggests these:
?>		real tau = fabs(beta[0] + 3. * beta[1] - 3. * beta[2] - beta[3]);
<?		else	-- for weno7, 2018 Zeytinoglu suggests this:
?>		real tau = fabs(beta[0] - beta[<?=stencilSize-1?>]);
<?		end
?>
		real alpha[stencilSize];
<?		for i=0,stencilSize-1 do
?>		alpha[<?=i?>] = <?=clnumber(d[d0 + i * dd])?> * (1. + (tau / (beta[<?=i?>] + epsilon)));
<? 		end

	elseif solver.wenoMethod == "2010 Shen Zha" then -- WENO-BS?
?>		constexpr real epsilon = 1e-10;

		// TODO find these for other order WENO's
		constexpr real shen_zha_A = 50;	// 0-100

		real minB = beta[0];
		real maxB = beta[0];
		for (int j = 1; j < stencilSize; ++j) {
			minB = min(minB, beta[j]);
			maxB = max(maxB, beta[j]);
		}
		
		real R0 = minB / (maxB + epsilon);

		real alpha[stencilSize];
<? 		for i=0,stencilSize-1 do
?>		alpha[<?=i?>] = <?=clnumber(d[d0 + i * dd])?> / sqr(epsilon + beta[<?=i?>] + R0 * shen_zha_A * minB);
<? 		end
	else
		error("unknown wenoMethod "..tostring(solver.wenoMethod))
	end
?>
		real vs[stencilSize];
<?	for i=0,stencilSize-1 do
?>		vs[<?=i?>] = 0.<?
			for j=0,stencilSize-1 do ?>
			+ <?=clnumber(a[ak0+akd*i][al0+ald*j])?> * v[<?=i+j?>][k]<?
			end ?>;
<? 	end
?>
		
		real alphasum = 0;
		for (int i = 0; i < stencilSize; ++i) {
			alphasum += alpha[i];
		}

		result[k] = 0;
		for (int i = 0; i < stencilSize; ++i) {
			result[k] += alpha[i] * vs[i];
		}
		result[k] /= alphasum;
	}
	return result;
}
<? end
?>

// is supposed to be a subclass of FVSolver
// but right now the Solver C++ code and the solver_t code are uncoupled anyways
// and I don't have vtables anywhere (can I even?)
// so ...
struct WENOSolver {
	static inline void calcFlux(
		constant Solver const & solver,
		global Cons * const fluxBuf,
		global Cons const * const UBuf/*<?=solver.getULRArg?> ... but why use getULR when we're using WENO? */,
		global Cell const * const cellBuf

	) {
		<?=SETBOUNDS?>(solver.numGhost, solver.numGhost-1);

		real3 const xR = cellBuf[index].pos;
		auto const * const U = UBuf + index;
		auto const * const cell = cellBuf + index;
		<? for side=0,solver.dim-1 do ?>{
			int const side = <?=side?>;

			int const indexL = index - solver.stepsize[<?=side?>];
			int const indexR = index;

#if 0
			<?=solver:getULRCode():gsub("\n", "\n\t\t")?>
#else
			auto const & UL = UBuf[indexL];
			auto const & UR = UBuf[indexR];
#endif

			auto const & cellL = cellBuf[indexL];
			auto const & cellR = cellBuf[indexR];

			real3 xInt = xR; xInt[<?=side?>] -= .5 * solver.grid_dx[<?=side?>];

			auto const n = Normal::forSide<<?=side?>>(xInt);

			int const fluxIndexInt = side + dim * index;
			auto & flux = fluxBuf[fluxIndexInt];

<?

	if solver.fluxMethod == "Lax-Friedrichs" then

?>
			auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);
			real maxAbsLambda = 0.;
			for (int j = 0; j < <?=2*stencilSize?>; ++j) {
				real lambdaMin, lambdaMax;
				Eqn::consWaveCodeMinMax(
					solver, 
					U[(j - <?=stencilSize?>) * solver.stepsize[<?=side?>]],
					n,
					xInt,
					&lambdaMin,
					&lambdaMax);
				maxAbsLambda = max(maxAbsLambda, fabs(lambdaMin));
				maxAbsLambda = max(maxAbsLambda, fabs(lambdaMax));
			}

<?
		for j=0,2*stencilSize-1 do
?>
			int const offset<?=j?> = <?=j - stencilSize?> * solver.stepsize[<?=side?>];
			auto const & U<?=j?> = U[offset<?=j?>];
			auto const & cell<?=j?> = cell[offset<?=j?>];
			//auto> F<?=j?> = fluxCellBuf[<?=side?> + dim * (index + <?=j - stencilSize?> * solver.stepsize[<?=side?>])];
			auto F<?=j?> = Eqn::fluxFromCons(solver, U<?=j?>, cell<?=j?>, n);
<?			if j < 2*stencilSize-1 then ?>
			Cons fp<?=j?>;
			for (int k = 0; k < numStates; ++k) {
				fp<?=j?>[k] = (F<?=j?>[k] + maxAbsLambda * U<?=j?>[k]) * .5;
			}
<?			end
			if j > 0 then
?>
			Cons fm<?=j-1?>;
			for (int k = 0; k < numStates; ++k) {
				fm<?=j-1?>[k] = (F<?=j?>[k] - maxAbsLambda * U<?=j?>[k]) * .5;
			}
<?			end
		end
?>
			Waves afp[<?=2*stencilSize-1?>] = {
<? 		for j=0,2*stencilSize-2 do
?>				Eqn::eigen_leftTransform(solver, eig, fp<?=j?>, xInt, n),
<?		end
?>			};
			Waves afm[<?=2*stencilSize-1?>] = {
<?		for j=0,2*stencilSize-2 do
?>				Eqn::eigen_leftTransform(solver, eig, fm<?=j?>, xInt, n),
<? 		end
?>			};

			Waves wafp = weno_r(afp);
			Waves wafm = weno_l(afm);

			Waves waf;
			for (int j = 0; j < numWaves; ++j) {
				waf[j] = wafp[j] + wafm[j];
			}

			flux = Eqn::eigen_rightTransform(solver, eig, waf, xInt, n);
<?

	elseif solver.fluxMethod == "Marquina" then

?>
			auto eigL = Eqn::eigen_forCell(solver, UL, cellL, n);
			auto eigR = Eqn::eigen_forCell(solver, UR, cellR, n);

			real lambdaL[numWaves];
			real lambdaR[numWaves];
			<? for _,lr in ipairs{"L", "R"} do ?>{
				auto calcWaves = Eqn::EigenWaveCode(solver, eig<?=lr?>, n, xInt);
				for (int k = 0; k < numWaves; ++k) {
					// TODO this was 'U', but the CodePrefix was &eig ... so ... which is it?
					lambda<?=lr?>[k] = calcWaves(solver, eig<?=lr?>, n, xInt, k);
				}
			}<? end ?>

<? 		for j=0,2*stencilSize-2 do
?>		
			int const offset<?=j?> = (<?=j - stencilSize?>) * solver.stepsize[<?=side?>];
			auto const & U<?=j?> = U[offset<?=j?>];
			auto const & cell<?=j?> = cell[offset<?=j?>];
			auto F<?=j?> = Eqn::fluxFromCons(solver, U<?=j?>, cell<?=j?>, n);
			Waves al<?=j?> = Eqn::eigen_leftTransform(solver, eigL, U<?=j?>, xInt, n);
			Waves ar<?=j?> = Eqn::eigen_leftTransform(solver, eigR, U<?=j?>, xInt, n);
			Waves afl<?=j?> = Eqn::eigen_leftTransform(solver, eigL, F<?=j?>, xInt, n);
			Waves afr<?=j?> = Eqn::eigen_leftTransform(solver, eigR, F<?=j?>, xInt, n);

<?		end
?>

			Waves afp[<?=2*stencilSize-1?>], afm[<?=2*stencilSize-1?>];
			for (int k = 0; k < numWaves; ++k) {
				if (lambdaL[k] > 0.0 && lambdaR[k] > 0.0) {
<?				for j=0,2*stencilSize-2 do ?>
					afp[<?=j?>][k] = afl<?=j?>[k];
					afm[<?=j?>][k] = 0;
<?				end
?>				} else if (lambdaL[k] < 0.0 && lambdaR[k] < 0.0) {
<?				for j=0,2*stencilSize-2 do ?>
					afp[<?=j?>][k] = 0;
					afm[<?=j?>][k] = afr<?=j?>[k];
<?				end ?>
				} else {
					real absLambdaL = fabs(lambdaL[k]);
					real absLambdaR = fabs(lambdaR[k]);
					real a, absa;
					if (absLambdaL > absLambdaR) {
						a = lambdaL[k];
						absa = absLambdaL;
					} else {
						a = lambdaR[k];
						absa = absLambdaR;
					}
<?				for j=0,2*stencilSize-2 do
?>					afp[<?=j?>][k] = .5 * (afl<?=j?>[k] + absa * al<?=j?>[k]);
					afm[<?=j?>][k] = .5 * (afr<?=j?>[k] - absa * ar<?=j?>[k]);
<?				end
?>				}
			}

			Waves wafp = weno_r(afp);
			auto fluxP = Eqn::eigen_rightTransform(solver, eigL, wafp, xInt, n);

			Waves wafm = weno_l(afm);
			auto fluxM = Eqn::eigen_rightTransform(solver, eigR, wafm, xInt, n);

			for (int j = 0; j < numIntStates; ++j) {
				flux[j] = fluxP[j] + fluxM[j];
			}
<?

	elseif solver.fluxMethod == "Roe" then

		-- TODO make the following its own function, maybe in solver/roe.cl or solver/roe.lua
		-- so we can call a function instead of copy/paste
		-- but this means making it a function of the lua parameters, like flux limiter.
		-- and a flux limiter means +1 to the numGhost
?>

			auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);

			Waves afp[<?=2*stencilSize-1?>], afm[<?=2*stencilSize-1?>];
<?		for j=0,2*stencilSize-2 do
?>
			{
				int const offsetL<?=j?> = <?=j - stencilSize?> * solver.stepsize[<?=side?>];
				int const offsetR<?=j?> = <?=j+1 - stencilSize?> * solver.stepsize[<?=side?>];

				auto const & UL<?=j?> = U[offsetL<?=j?>];
				auto const & UR<?=j?> = U[offsetR<?=j?>];

				auto const & cellL<?=j?> = cell[offsetL<?=j?>];
				auto const & cellR<?=j?> = cell[offsetR<?=j?>];

				//should we only use a single 'eig'?  seems errors pop up when I use the 'eig' at each interface along the stencil
				//auto eig = Eqn::eigen_forInterface(solver, UL, UR, cellL, cellR, xInt, n);

				auto calcWaves = Eqn::EigenWaveCode(solver, eig, n, xInt);

				Cons UAvg;
				for (int k = 0; k < numIntStates; ++k) {
					UAvg[k] = .5 * (UL<?=j?>[k] + UR<?=j?>[k]);
				}
				afp[<?=j?>] = afm[<?=j?>] = Eqn::eigen_leftTransform(solver, eig, UAvg, xInt, n);

				Cons deltaU;
				for (int k = 0; k < numStates; ++k) {
					deltaU[k] = UR<?=j?>[k] - UL<?=j?>[k];
				}

				Waves deltaUEig = Eqn::eigen_leftTransform(solver, eig, deltaU, xInt, n);

				for (int k = 0; k < numWaves; ++k) {
					real const lambda = calcWaves(solver, eig, n, xInt, k);
					real lambdaPlus = max(lambda, 0.);
					real lambdaMinus = min(lambda, 0.);

					afp[<?=j?>][k] *= lambdaPlus;
					afm[<?=j?>][k] *= lambdaMinus;
					real sgnLambda = lambda >= 0 ? 1 : -1;
					afp[<?=j?>][k] -= .5 * lambdaPlus * deltaUEig[k] * sgnLambda;
					afm[<?=j?>][k] -= .5 * lambdaMinus * deltaUEig[k] * sgnLambda;
				}
			}
<?
		end
?>
			Waves wafp = weno_r(afp);
			Waves wafm = weno_l(afm);
			Waves waf;
			for (int j = 0; j < numWaves; ++j) {
				waf[j] = wafp[j] + wafm[j];
			}

			flux = Eqn::eigen_rightTransform(solver, eig, waf, xInt, n);
<?

	else
		error("unknown fluxMethod "..tostring(solver.fluxMethod))
	end
?>		}<?
end ?>

	}
};

}	// namespace <?=Solver?>

//// MODULE_NAME: calcCellFlux
//// MODULE_DEPENDS: <?=Solver?>

kernel void calcCellFlux(
	constant <?=solver_t?> const * const psolver,
	global <?=cell_t?> const * const cellBuf,
	global <?=cons_t?> * const fluxCellBuf,
	global <?=cons_t?> const * const UBuf
) {
	using namespace <?=Solver?>;
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(0,0);
	auto const & U = UBuf[index];
	auto const & cell = cellBuf[index];
	<? for side=0,solver.dim-1 do ?>{
		real3 xInt = cell.pos; xInt[<?=side?>] -= .5 * solver.grid_dx[<?=side?>];
		fluxCellBuf[<?=side?> + dim * index] = Eqn::fluxFromCons(
			solver,
			U,
			cell,
			Normal::forSide<?=side?>(xInt);
		);	// xInt or cell->pos?  U is based on cell->pos, but the dest flux is xInt
	}<? end ?>
}

//// MODULE_NAME: <?=calcFlux?>
//// MODULE_DEPENDS: <?=Solver?> weno_l/r

kernel void <?=calcFlux?>(
	constant <?=solver_t?> const * const psolver,
	global <?=cons_t?> * const fluxBuf,
	global <?=cons_t?> const * const UBuf/*<?=solver.getULRArg?> ... but why use getULR when we're using WENO? */,
	global <?=cell_t?> const * const cellBuf
) {
	using namespace <?=Solver?>;
	auto const & solver = *psolver;
	WENOSolver::calcFlux(solver, fluxBuf, UBuf, cellBuf);
}
