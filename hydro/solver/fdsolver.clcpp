//// MODULE_NAME: calcFluxAtCell
//// MODULE_DEPENDS: <?=Solver?>

kernel void calcFluxAtCell(
	constant <?=solver_t?> const * const psolver,
	global <?=cons_t?> * const fluxBuf,
	global <?=cons_t?> const * const UBuf,
	global <?=cell_t?> const * const cellBuf
) {
	using namespace <?=Solver?>;
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(0,0);
	auto const & U = UBuf[index];
	auto const & cell = cellBuf[index];
<? for side=0,solver.dim-1 do 
?>	fluxBuf[<?=side?> + dim * index] = Eqn::fluxFromCons(solver, U, cell, Normal::forSide<<?=side?>>(cell.pos));
<? end
?>
}

//// MODULE_NAME: calcDerivFiniteDifference
//// MODULE_DEPENDS: <?=solver_macros?> <?=Solver?>

kernel void calcDerivFiniteDifference(
	constant <?=solver_t?> const * const psolver,
	global <?=cons_t?> * const derivBuf,
	global <?=cons_t?> const * const fluxBuf,
	global <?=cell_t?> const * const cellBuf
) {
	auto const & solver = *psolver;
	<?=SETBOUNDS?>(solver.numGhost, solver.numGhost);
	
	auto & deriv = derivBuf[index];
	auto const * const F = fluxBuf + dim * index;

	//2nd order.  TODO use n'th order.
	<? for j=0,solver.dim-1 do ?>{
		auto const & FL = F[ - dim * solver.stepsize.s<?=j?> + <?=j?>];
		auto const & FR = F[ + dim * solver.stepsize.s<?=j?> + <?=j?>];
		for (int k = 0; k < numIntStates; ++k) {
			deriv.ptr[k] -= (FR.ptr[k] - FL.ptr[k]) / (2. * solver.grid_dx.s<?=j?>);
		}
	}<? end ?>
}
